<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>igm API documentation</title>
<meta name="description" content="Copyright (C) 2021-2022 Guillaume Jouvet &lt;guillaume.jouvet@geo.uzh.ch&gt;
Published under the GNU GPL (Version 3), check at the LICENSE file …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>igm</code></h1>
</header>
<section id="section-intro">
<p>Copyright (C) 2021-2022 Guillaume Jouvet <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#103;&#117;&#105;&#108;&#108;&#97;&#117;&#109;&#101;&#46;&#106;&#111;&#117;&#118;&#101;&#116;&#64;&#103;&#101;&#111;&#46;&#117;&#122;&#104;&#46;&#99;&#104;">&#103;&#117;&#105;&#108;&#108;&#97;&#117;&#109;&#101;&#46;&#106;&#111;&#117;&#118;&#101;&#116;&#64;&#103;&#101;&#111;&#46;&#117;&#122;&#104;&#46;&#99;&#104;</a>
Published under the GNU GPL (Version 3), check at the LICENSE file</p>
<p>This file contains the core functions the Instructed Glacier Model (IGM),
functions are sorted by thema, which are</p>
<h1 id="initialization-contains-all-to-initialize-variables">INITIALIZATION : contains all to initialize variables</h1>
<h1 id="io-ncdf-files-for-data-inputoutput-using-netcdf-file-format">I/O NCDF : Files for data Input/Output using NetCDF file format</h1>
<h1 id="compute-t-and-dt-function-to-compute-adaptive-time-step-and-time">COMPUTE T AND DT : Function to compute adaptive time-step and time</h1>
<h1 id="iceflow-containt-the-function-that-serve-compute-the-emulated-iceflow">ICEFLOW : Containt the function that serve compute the emulated iceflow</h1>
<h1 id="climate-templates-for-function-updating-climate">CLIMATE : Templates for function updating climate</h1>
<h1 id="mass-balance-simple-mass-balance">MASS BALANCE : Simple mass balance</h1>
<h1 id="erosion-erosion-law">EROSION : Erosion law</h1>
<h1 id="transport-this-handles-the-mass-conservation">TRANSPORT : This handles the mass conservation</h1>
<h1 id="3dvel-this-permits-to-export-reconsctruted-3d-ice-velocity-field">3DVEL
: This permits to export reconsctruted 3D ice velocity field</h1>
<h1 id="opti-all-for-the-optimization-data-assimilation">OPTI : All for the optimization / data assimilation</h1>
<h1 id="plot-plotting-functions">PLOT : Plotting functions</h1>
<h1 id="print-info-handle-the-printing-of-output-during-computation">PRINT INFO : handle the printing of output during computation</h1>
<h1 id="run-the-main-function-that-wrap-all-functions-within-an-time-iterative-loop">RUN : the main function that wrap all functions within an time-iterative loop</h1>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
Copyright (C) 2021-2022 Guillaume Jouvet &lt;guillaume.jouvet@geo.uzh.ch&gt;
Published under the GNU GPL (Version 3), check at the LICENSE file

This file contains the core functions the Instructed Glacier Model (IGM),
functions are sorted by thema, which are

#      INITIALIZATION : contains all to initialize variables
#      I/O NCDF : Files for data Input/Output using NetCDF file format
#      COMPUTE T AND DT : Function to compute adaptive time-step and time
#      ICEFLOW : Containt the function that serve compute the emulated iceflow
#      CLIMATE : Templates for function updating climate
#      MASS BALANCE : Simple mass balance
#      EROSION : Erosion law
#      TRANSPORT : This handles the mass conservation
#      3DVEL  : This permits to export reconsctruted 3D ice velocity field
#      OPTI : All for the optimization / data assimilation
#      PLOT : Plotting functions
#      PRINT INFO : handle the printing of output during computation
#      RUN : the main function that wrap all functions within an time-iterative loop

&#34;&#34;&#34;

####################################################################################

import os, sys, shutil, glob
import numpy as np
import matplotlib.pyplot as plt
import datetime, time
import math
import tensorflow as tf
from netCDF4 import Dataset
from scipy.interpolate import interp1d, CubicSpline, RectBivariateSpline, griddata
import argparse
from IPython.display import display, clear_output
from numpy import dtype
from scipy import stats

def str2bool(v):
    return v.lower() in (&#34;true&#34;, &#34;1&#34;)

####################################################################################

class igm:

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               INITIALIZATION
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def __init__(self):
        &#34;&#34;&#34;
        function build class IGM
        &#34;&#34;&#34;
        self.parser = argparse.ArgumentParser(description=&#34;IGM&#34;)
        self.read_config_param()
        self.config = self.parser.parse_args()
        
        config = tf.compat.v1.ConfigProto()
        config.gpu_options.allow_growth = True
        session = tf.compat.v1.Session(config=config)

    def read_config_param(self):

        self.parser.add_argument(
            &#34;--working_dir&#34;, type=str, default=&#34;&#34;, help=&#34;Working directory&#34;
        )
        self.parser.add_argument(
            &#34;--geology_file&#34;, type=str, default=&#34;geology.nc&#34;, help=&#34;Geology input file&#34;
        )
        self.parser.add_argument(
            &#34;--resample&#34;, type=int, default=1, help=&#34;Upsample the data from geology.nc&#34;
        )
        self.parser.add_argument(
            &#34;--tstart&#34;, type=float, default=0.0, help=&#34;Starting time&#34;
        )
        self.parser.add_argument(&#34;--tend&#34;, type=float, default=150.0, help=&#34;End time&#34;)
        self.parser.add_argument(
            &#34;--restartingfile&#34;,
            type=str,
            default=&#34;&#34;,
            help=&#34;Provide restarting file if no empty string&#34;,
        )
        self.parser.add_argument(
            &#34;--verbosity&#34;,
            type=int,
            default=0,
            help=&#34;Verbosity level of IGM (default: 0 = no verbosity)&#34;,
        )
        self.parser.add_argument(
            &#34;--tsave&#34;, type=float, default=10, help=&#34;Save result each X years (10)&#34;
        )
        self.parser.add_argument(
            &#34;--plot_result&#34;,
            type=str2bool,
            default=False,
            help=&#34;Plot results in png&#34;,
        )
        self.parser.add_argument(
            &#34;--plot_live&#34;,
            type=str2bool,
            default=False,
            help=&#34;Display plots live the results during computation&#34;,
        )
        self.parser.add_argument(
            &#34;--usegpu&#34;,
            type=str2bool,
            default=True,
            help=&#34;Use the GPU for ice flow model (True)&#34;,
        )
        self.parser.add_argument(
            &#34;--stop&#34;,
            type=str2bool,
            default=False,
            help=&#34;experimental, just o get fair comp time, to be removed ....&#34;,
        )
        self.parser.add_argument(
            &#34;--init_strflowctrl&#34;,
            type=float,
            default=78,
            help=&#34;Initial strflowctrl&#34;,
        )

        self.parser.add_argument(
            &#34;--init_slidingco&#34;,
            type=float,
            default=0,
            help=&#34;Initial slidingco&#34;,
        )
        self.parser.add_argument(
            &#34;--init_arrhenius&#34;,
            type=float,
            default=78,
            help=&#34;Initial arrhenius&#34;,
        )

        self.parser.add_argument(
            &#34;--optimize&#34;,
            type=str2bool,
            default=False,
            help=&#34;Optimize prior forward modelling  (not available yet)&#34;,
        )
        self.parser.add_argument(
            &#34;--update_topg&#34;,
            type=str2bool,
            default=False,
            help=&#34;Update bedrock (not available yet)&#34;,
        )

        for p in dir(self):
            if &#34;read_config_param_&#34; in p:
                getattr(self, p)()

    ##################################################

    def initialize(self):
        &#34;&#34;&#34;
        function initialize the strict minimum for IGM class, and record parameters
        &#34;&#34;&#34;

        print(
            &#34;+++++++++++++++++++ START IGM ++++++++++++++++++++++++++++++++++++++++++&#34;
        )

        self.t = tf.Variable(float(self.config.tstart))
        self.it = 0
        self.dt = float(self.config.dtmax)
        self.dt_target = float(self.config.dtmax)

        self.saveresult = True

        self.tcomp = {}
        self.tcomp[&#34;All&#34;] = []

        self.device_name = &#34;/GPU:0&#34; * self.config.usegpu + &#34;/CPU:0&#34; * (
            not self.config.usegpu
        )

        os.environ[&#34;CUDA_DEVICE_ORDER&#34;] = &#34;PCI_BUS_ID&#34;  # so the IDs match nvidia-smi

        if self.config.usegpu:
            os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;0&#34;  # &#34;0, 1&#34; for multiple
        else:
            os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;-1&#34;

        # This is used to limite the number of used core to 1 (or user-defined)
        #        tf.config.threading.set_inter_op_parallelism_threads(1)  # another method
        #        tf.config.threading.set_intra_op_parallelism_threads(1)  # another method

        with open(
            os.path.join(self.config.working_dir, &#34;igm-run-parameters.txt&#34;), &#34;w&#34;
        ) as f:
            print(&#34;PARAMETERS ARE ...... &#34;)
            for ck in self.config.__dict__:
                print(&#34;%30s : %s&#34; % (ck, self.config.__dict__[ck]))
                print(&#34;%30s : %s&#34; % (ck, self.config.__dict__[ck]), file=f)

    def load_ncdf_data(self, filename):
        &#34;&#34;&#34;
        Load the geological input files from netcdf file
        &#34;&#34;&#34;
        if self.config.verbosity == 1:
            print(&#34;LOAD NCDF file&#34;)

        nc = Dataset(os.path.join(self.config.working_dir, filename), &#34;r&#34;)

        x = np.squeeze(nc.variables[&#34;x&#34;]).astype(&#34;float32&#34;)
        y = np.squeeze(nc.variables[&#34;y&#34;]).astype(&#34;float32&#34;)
        assert x[1] - x[0] == y[1] - y[0]

        for var in nc.variables:
            if not var in [&#34;x&#34;, &#34;y&#34;]:
                vars()[var] = np.squeeze(nc.variables[var]).astype(&#34;float32&#34;)
                vars()[var] = np.where(vars()[var] &gt; 10 ** 35, np.nan, vars()[var])

        if self.config.resample &gt; 1:
            xx = x[:: self.config.resample]
            yy = y[:: self.config.resample]
            for var in nc.variables:
                if not var in [&#34;x&#34;, &#34;y&#34;]:
                    vars()[var] = RectBivariateSpline(y, x, vars()[var])(yy, xx)
            x = xx
            y = yy

        for var in nc.variables:
            if var in [&#34;x&#34;, &#34;y&#34;]:
                vars(self)[var] = tf.constant(vars()[var].astype(&#34;float32&#34;))
            else:
                vars(self)[var] = tf.Variable(vars()[var].astype(&#34;float32&#34;))

        nc.close()

    def initialize_fields(self):
        &#34;&#34;&#34;
        Initialize fields, complete the loading of geology
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Initialize fields&#34;)

        # at this point, we should have defined at least x, y, usurf
        assert hasattr(self, &#34;x&#34;)
        assert hasattr(self, &#34;y&#34;)

        if hasattr(self, &#34;usurfobs&#34;):
            self.usurf = tf.Variable(self.usurfobs)

        assert hasattr(self, &#34;usurf&#34;)

        if not hasattr(self, &#34;thk&#34;):
            self.thk = tf.Variable(tf.zeros((self.y.shape[0], self.x.shape[0])))

        self.topg = tf.Variable(self.usurf - self.thk)

        if not hasattr(self, &#34;icemask&#34;):
            if hasattr(self, &#34;mask&#34;):
                self.icemask = tf.Variable(self.mask)
            else:
                self.icemask = tf.Variable(tf.ones_like(self.thk))

        if not hasattr(self, &#34;uvelsurf&#34;):
            self.uvelsurf = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;vvelsurf&#34;):
            self.vvelsurf = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;wvelbase&#34;):
            self.wvelbase = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;wvelsurf&#34;):
            self.wvelsurf = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;smb&#34;):
            if hasattr(self, &#34;mb&#34;):
                self.smb = tf.Variable(self.mb)
            else:
                self.smb = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;dhdt&#34;):
            self.dhdt = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;strflowctrl&#34;):
            self.strflowctrl = tf.Variable(
                tf.ones_like(self.thk) * self.config.init_strflowctrl
            )

        if not hasattr(self, &#34;arrhenius&#34;):
            self.arrhenius = tf.Variable(
                tf.ones_like(self.thk) * self.config.init_arrhenius
            )

        if not hasattr(self, &#34;slidingco&#34;):
            self.slidingco = tf.Variable(
                tf.ones_like(self.thk) * self.config.init_slidingco
            )
            
        if self.config.erosion_include:
            self.dtopgdt = tf.Variable( tf.zeros_like(self.thk) )

        self.X, self.Y = tf.meshgrid(self.x, self.y)

        self.dx = self.x[1] - self.x[0]

        self.slopsurfx, self.slopsurfy = self.compute_gradient_tf(
            self.usurf, self.dx, self.dx
        )

        self.ubar = tf.Variable(tf.zeros_like(self.thk))
        self.vbar = tf.Variable(tf.zeros_like(self.thk))
        self.uvelbase = tf.Variable(tf.zeros_like(self.thk))
        self.vvelbase = tf.Variable(tf.zeros_like(self.thk))
        self.divflux = tf.Variable(tf.zeros_like(self.thk))

        self.var_info = {}
        self.var_info[&#34;topg&#34;] = [&#34;Basal Topography&#34;, &#34;m&#34;]
        self.var_info[&#34;usurf&#34;] = [&#34;Surface Topography&#34;, &#34;m&#34;]
        self.var_info[&#34;thk&#34;] = [&#34;Ice Thickness&#34;, &#34;m&#34;]
        self.var_info[&#34;icemask&#34;] = [&#34;Ice mask&#34;, &#34;NO UNIT&#34;]
        self.var_info[&#34;smb&#34;] = [&#34;Surface Mass Balance&#34;, &#34;m/y&#34;]
        self.var_info[&#34;ubar&#34;] = [&#34;x depth-average velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vbar&#34;] = [&#34;y depth-average velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;velbar_mag&#34;] = [&#34;Depth-average velocity magnitude of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;uvelsurf&#34;] = [&#34;x surface velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vvelsurf&#34;] = [&#34;y surface velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;velsurf_mag&#34;] = [&#34;Surface velocity magnitude of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;uvelbase&#34;] = [&#34;x basal velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vvelbase&#34;] = [&#34;y basal velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;velbase_mag&#34;] = [&#34;Basal velocity magnitude of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;divflux&#34;] = [&#34;Divergence of the ice flux&#34;, &#34;m/y&#34;]
        self.var_info[&#34;strflowctrl&#34;] = [
            &#34;arrhenius + 10 * slidingco&#34;,
            &#34;MPa$^{-3}$ a$^{-1}$&#34;,
        ]
        self.var_info[&#34;dtopgdt&#34;] = [&#34;Erosion rate&#34;,&#34;m/y&#34;]
        self.var_info[&#34;arrhenius&#34;] = [&#34;Arrhenius factor&#34;, &#34;MPa$^{-3}$ a$^{-1}$&#34;]
        self.var_info[&#34;slidingco&#34;] = [&#34;Sliding Coefficient&#34;, &#34;km MPa$^{-3}$ a$^{-1}$&#34;]
        self.var_info[&#34;meantemp&#34;] = [&#34;Mean anual surface temperatures&#34;, &#34;°C&#34;]
        self.var_info[&#34;meanprec&#34;] = [&#34;Mean anual precipitation&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vol&#34;] = [&#34;Ice volume&#34;, &#34;km^3&#34;]
        self.var_info[&#34;area&#34;] = [&#34;Glaciated area&#34;, &#34;km^2&#34;]

        self.var_info[&#34;velsurfobs_mag&#34;] = [
            &#34;Observed Surface velocity magnitude of ice&#34;,
            &#34;m/y&#34;,
        ]

    def restart(self):
        &#34;&#34;&#34;
        Permit to restart a simulation from a ncdf file y taking the last iterate
        &#34;&#34;&#34;
        if self.config.verbosity == 1:
            print(&#34;READ RESTARTING FILE, OVERIDE FIELDS WHEN GIVEN&#34;)

        nc = Dataset(self.config.restartingfile, &#34;r&#34;)

        Rx = tf.constant(np.squeeze(nc.variables[&#34;x&#34;]).astype(&#34;float32&#34;))
        Ry = tf.constant(np.squeeze(nc.variables[&#34;y&#34;]).astype(&#34;float32&#34;))

        assert Rx.shape == self.x.shape
        assert Ry.shape == self.y.shape

        for var in nc.variables:
            if not var in [&#34;x&#34;, &#34;y&#34;]:
                vars(self)[var].assign(
                    np.squeeze(nc.variables[var][-1]).astype(&#34;float32&#34;)
                )

        nc.close()

    def stop(self):
        &#34;&#34;&#34;
        this is a dummy stop that serves to syncrohnize CPU and GPU for reliable computational times
        &#34;&#34;&#34;
        ubar_np = self.ubar.numpy()
        thk_np = self.thk.numpy()
        mb_np = self.smb.numpy()

    def whatsize(self, n):
        s = float(n.size * n.itemsize) / (10 ** 6)
        print(&#34;%1.0f Mbytes&#34; % s)

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               I/O NCDF
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_output_ncdf(self):

        self.parser.add_argument(
            &#34;--vars_to_save&#34;,
            type=list,
            default=[
                &#34;topg&#34;,
                &#34;usurf&#34;,
                &#34;thk&#34;,
                &#34;smb&#34;,
                &#34;velbar_mag&#34;,
                &#34;velsurf_mag&#34;,
            ],
            help=&#34;List of variables to be recorded in the ncdef file&#34;,
        )

    def update_ncdf_ex(self, force=False):
        &#34;&#34;&#34;
        Initialize  and write the ncdf output file
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_ncdf_ex&#34;):
            self.tcomp[&#34;Outputs ncdf&#34;] = []
            self.already_called_update_ncdf_ex = True

        if force | self.saveresult:

            self.tcomp[&#34;Outputs ncdf&#34;].append(time.time())

            if &#34;velbar_mag&#34; in self.config.vars_to_save:
                self.velbar_mag = self.getmag(self.ubar, self.vbar)

            if &#34;velsurf_mag&#34; in self.config.vars_to_save:
                self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

            if &#34;velbase_mag&#34; in self.config.vars_to_save:
                self.velbase_mag = self.getmag(self.uvelbase, self.vvelbase)

            if &#34;meanprec&#34; in self.config.vars_to_save:
                self.meanprec = tf.math.reduce_mean(self.precipitation, axis=0)

            if &#34;meantemp&#34; in self.config.vars_to_save:
                self.meantemp = tf.math.reduce_mean(self.air_temp, axis=0)

            if self.it == 0:

                if self.config.verbosity == 1:
                    print(&#34;Initialize NCDF output Files&#34;)

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex.nc&#34;),
                    &#34;w&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                nc.createDimension(&#34;time&#34;, None)
                E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
                E.units = &#34;yr&#34;
                E.long_name = &#34;time&#34;
                E.axis = &#34;T&#34;
                E[0] = self.t.numpy()

                nc.createDimension(&#34;y&#34;, len(self.y))
                E = nc.createVariable(&#34;y&#34;, np.dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;y&#34;
                E.axis = &#34;Y&#34;
                E[:] = self.y.numpy()

                nc.createDimension(&#34;x&#34;, len(self.x))
                E = nc.createVariable(&#34;x&#34;, np.dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;x&#34;
                E.axis = &#34;X&#34;
                E[:] = self.x.numpy()

                for var in self.config.vars_to_save:

                    E = nc.createVariable(
                        var, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
                    )
                    E.long_name = self.var_info[var][0]
                    E.units = self.var_info[var][1]
                    E[0, :, :] = vars(self)[var].numpy()

                nc.close()

            else:

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex.nc&#34;),
                    &#34;a&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                d = nc.variables[&#34;time&#34;][:].shape[0]
                nc.variables[&#34;time&#34;][d] = self.t.numpy()

                for var in self.config.vars_to_save:
                    nc.variables[var][d, :, :] = vars(self)[var].numpy()

                nc.close()

            self.tcomp[&#34;Outputs ncdf&#34;][-1] -= time.time()
            self.tcomp[&#34;Outputs ncdf&#34;][-1] *= -1

    def update_ncdf_ts(self, force=False):
        &#34;&#34;&#34;
        Initialize  and write the ncdf time serie file
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_ncdf_ts&#34;):
            self.already_called_update_ncdf_ts = True

        if force | self.saveresult:

            vol = np.sum(self.thk) * (self.dx ** 2) / 10 ** 9
            area = np.sum(self.thk &gt; 1) * (self.dx ** 2) / 10 ** 6

            if self.it == 0:

                if self.config.verbosity == 1:
                    print(&#34;Initialize NCDF output Files&#34;)

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ts.nc&#34;),
                    &#34;w&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                nc.createDimension(&#34;time&#34;, None)
                E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
                E.units = &#34;yr&#34;
                E.long_name = &#34;time&#34;
                E.axis = &#34;T&#34;
                E[0] = self.t.numpy()

                for var in [&#34;vol&#34;, &#34;area&#34;]:
                    E = nc.createVariable(var, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;))
                    E[0] = vars()[var].numpy()
                    E.long_name = self.var_info[var][0]
                    E.units = self.var_info[var][1]
                nc.close()

            else:

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ts.nc&#34;),
                    &#34;a&#34;,
                    format=&#34;NETCDF4&#34;,
                )
                d = nc.variables[&#34;time&#34;][:].shape[0]

                nc.variables[&#34;time&#34;][d] = self.t.numpy()
                for var in [&#34;vol&#34;, &#34;area&#34;]:
                    nc.variables[var][d] = vars()[var].numpy()
                nc.close()

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               COMPUTE T AND DT
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_t_dt(self):

        # NUMERICL PARAMETER FOR TIME STEP
        self.parser.add_argument(
            &#34;--cfl&#34;, type=float, default=0.3, help=&#34;CFL number must be below 1 (0.3)&#34;
        )
        self.parser.add_argument(
            &#34;--dtmax&#34;,
            type=float,
            default=10.0,
            help=&#34;Maximum time step, used only with slow ice (10.0)&#34;,
        )

    def update_t_dt(self):
        &#34;&#34;&#34;
        compute time step to satisfy the CLF condition and hit requested saving times
        &#34;&#34;&#34;
        if self.config.verbosity == 1:
            print(&#34;Update DT from the CFL condition at time : &#34;, self.t.numpy())

        if not hasattr(self, &#34;already_called_update_t_dt&#34;):
            self.tcomp[&#34;Time step&#34;] = []
            self.already_called_update_t_dt = True

            self.tsave = np.ndarray.tolist(
                np.arange(self.config.tstart, self.config.tend, self.config.tsave)
            ) + [self.config.tend]
            self.itsave = 0

        self.tcomp[&#34;Time step&#34;].append(time.time())

        velomax = max(
            tf.math.reduce_max(tf.math.abs(self.ubar)),
            tf.math.reduce_max(tf.math.abs(self.vbar)),
        ).numpy()

        if velomax &gt; 0:
            self.dt_target = min(self.config.cfl * self.dx / velomax, self.config.dtmax)
        else:
            self.dt_target = self.config.dtmax

        self.dt = self.dt_target

        if self.tsave[self.itsave + 1] &lt;= self.t.numpy() + self.dt:
            self.dt = self.tsave[self.itsave + 1] - self.t.numpy()
            self.t.assign(self.tsave[self.itsave + 1])
            self.saveresult = True
            self.itsave += 1
        else:
            self.t.assign(self.t.numpy() + self.dt)
            self.saveresult = False

        self.it += 1

        self.tcomp[&#34;Time step&#34;][-1] -= time.time()
        self.tcomp[&#34;Time step&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               GET MAG AND GRADIENTS
    ####################################################################################
    ####################################################################################
    ####################################################################################

    @tf.function()
    def getmag(self, u, v):
        &#34;&#34;&#34;
        return the norm of a 2D vector, e.g. to compute velbase_mag
        &#34;&#34;&#34;
        return tf.norm(
            tf.concat([tf.expand_dims(u, axis=-1), tf.expand_dims(v, axis=-1)], axis=2),
            axis=2,
        )

    @tf.function()
    def compute_gradient_tf(self, s, dx, dy):
        &#34;&#34;&#34;
        compute spatial 2D gradient of a given field
        &#34;&#34;&#34;

        EX = tf.concat([s[:, 0:1], 0.5 * (s[:, :-1] + s[:, 1:]), s[:, -1:]], 1)
        diffx = (EX[:, 1:] - EX[:, :-1]) / dx

        EY = tf.concat([s[0:1, :], 0.5 * (s[:-1, :] + s[1:, :]), s[-1:, :]], 0)
        diffy = (EY[1:, :] - EY[:-1, :]) / dy

        return diffx, diffy

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               ICEFLOW
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_fields_and_bounds(self, path):
        &#34;&#34;&#34;
        get fields (input and outputs) from given file
        &#34;&#34;&#34;

        fieldbounds = {}
        fieldin = []
        fieldout = []

        fid = open(os.path.join(path, &#34;fieldin.dat&#34;), &#34;r&#34;)
        for fileline in fid:
            part = fileline.split()
            fieldin.append(part[0])
            fieldbounds[part[0]] = float(part[1])
        fid.close()

        fid = open(os.path.join(path, &#34;fieldout.dat&#34;), &#34;r&#34;)
        for fileline in fid:
            part = fileline.split()
            fieldout.append(part[0])
            fieldbounds[part[0]] = float(part[1])
        fid.close()

        return fieldin, fieldout, fieldbounds

    def read_config_param_iceflow(self):

        self.parser.add_argument(
            &#34;--iceflow_model_lib_path&#34;,
            type=str,
            default=&#34;/home/jouvetg/IGM/model-lib/f12_cfsflow&#34;,
            help=&#34;model directory&#34;,
        )
        self.parser.add_argument(
            &#34;--multiple_window_size&#34;,
            type=int,
            default=0,
            help=&#34;In case the mdel is a unet, it must force window size to be multiple of e.g. 8&#34;,
        )
        self.parser.add_argument(
            &#34;--force_max_velbar&#34;,
            type=float,
            default=0,
            help=&#34;This permits to artificially upper-bound velocities, active if &gt; 0&#34;,
        )

    def initialize_iceflow(self):
        &#34;&#34;&#34;
        set-up the iceflow emulator
        &#34;&#34;&#34;

        dirpath = os.path.join(self.config.iceflow_model_lib_path, str(int(self.dx)))

        assert os.path.isdir(dirpath)

        fieldin, fieldout, fieldbounds = self.read_fields_and_bounds(dirpath)

        self.iceflow_mapping = {}
        self.iceflow_mapping[&#34;fieldin&#34;] = fieldin
        self.iceflow_mapping[&#34;fieldout&#34;] = fieldout
        self.iceflow_fieldbounds = fieldbounds

        self.iceflow_model = tf.keras.models.load_model(
            os.path.join(dirpath, &#34;model.h5&#34;)
        )

        #        print(self.iceflow_model.summary())

        Ny = self.thk.shape[0]
        Nx = self.thk.shape[1]

        if self.config.multiple_window_size &gt; 0:
            NNy = self.config.multiple_window_size * math.ceil(
                Ny / self.config.multiple_window_size
            )
            NNx = self.config.multiple_window_size * math.ceil(
                Nx / self.config.multiple_window_size
            )
            self.PAD = [[0, NNy - Ny], [0, NNx - Nx]]
        else:
            self.PAD = [[0, 0], [0, 0]]

        self.tcomp[&#34;Ice flow&#34;] = []

    def update_iceflow(self):
        &#34;&#34;&#34;
        function update the ice flow using the neural network emulator
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Update ICEFLOW at time : &#34;, igm.t)

        self.tcomp[&#34;Ice flow&#34;].append(time.time())

        X = tf.expand_dims(
            tf.stack(
                [
                    tf.pad(vars(self)[f], self.PAD, &#34;CONSTANT&#34;)
                    / self.iceflow_fieldbounds[f]
                    for f in self.iceflow_mapping[&#34;fieldin&#34;]
                ],
                axis=-1,
            ),
            axis=0,
        )

        Y = self.iceflow_model.predict_on_batch(X)

        Ny, Nx = self.thk.shape
        for kk, f in enumerate(self.iceflow_mapping[&#34;fieldout&#34;]):
            vars(self)[f].assign(
                tf.where(self.thk &gt; 0, Y[0, :Ny, :Nx, kk], 0)
                * self.iceflow_fieldbounds[f]
            )

        if self.config.force_max_velbar &gt; 0:

            self.velbar_mag = self.getmag(self.ubar, self.vbar)

            self.ubar.assign(
                tf.where(
                    self.velbar_mag &gt;= self.config.force_max_velbar,
                    self.config.force_max_velbar * (self.ubar / self.velbar_mag),
                    self.ubar,
                )
            )
            self.vbar.assign(
                tf.where(
                    self.velbar_mag &gt;= self.config.force_max_velbar,
                    self.config.force_max_velbar * (self.vbar / self.velbar_mag),
                    self.vbar,
                )
            )

        self.tcomp[&#34;Ice flow&#34;][-1] -= time.time()
        self.tcomp[&#34;Ice flow&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              CLIMATE
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_climate(self):

        # CLIMATE PARAMETERS
        self.parser.add_argument(
            &#34;--clim_update_freq&#34;,
            type=float,
            default=1,
            help=&#34;Update the climate each X years (1)&#34;,
        )
        self.parser.add_argument(
            &#34;--type_climate&#34;,
            type=str,
            default=&#34;&#34;,
            help=&#34;toy or any custom climate&#34;,
        )

    def update_climate(self, force=False):
        &#34;&#34;&#34;
        compute climate at time t
        &#34;&#34;&#34;

        if len(self.config.type_climate) &gt; 0:

            if not hasattr(self, &#34;already_called_update_climate&#34;):

                getattr(self, &#34;load_climate_data_&#34; + self.config.type_climate)()
                self.tlast_clim = -1.0e5000
                self.tcomp[&#34;Climate&#34;] = []
                self.already_called_update_climate = True

            new_clim_needed = (
                self.t.numpy() - self.tlast_clim
            ) &gt;= self.config.clim_update_freq

            if force | new_clim_needed:

                if self.config.verbosity == 1:
                    print(&#34;Construct climate at time : &#34;, igm.t)

                self.tcomp[&#34;Climate&#34;].append(time.time())

                getattr(self, &#34;update_climate_&#34; + self.config.type_climate)()

                self.tlast_clim = self.t.numpy()

                self.tcomp[&#34;Climate&#34;][-1] -= time.time()
                self.tcomp[&#34;Climate&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                                 MASS BALANCE
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_smb(self):

        self.parser.add_argument(
            &#34;--mb_update_freq&#34;,
            type=float,
            default=1,
            help=&#34;Update the mass balance each X years (1)&#34;,
        )
        self.parser.add_argument(
            &#34;--type_mass_balance&#34;,
            type=str,
            default=&#34;simple&#34;,
            help=&#34;zero, simple, given&#34;,
        )
        self.parser.add_argument(
            &#34;--mb_scaling&#34;, type=float, default=1.0, help=&#34;mass balance scaling&#34;
        )
        self.parser.add_argument(
            &#34;--mb_simple_file&#34;,
            type=str,
            default=&#34;mb_simple_param.txt&#34;,
            help=&#34;mb_simple_file&#34;,
        )
        self.parser.add_argument(
            &#34;--smb_model_lib_path&#34;,
            type=str,
            default=&#34;/home/jouvetg/IGM/model-lib/smb_meteoswissglamos&#34;,
            help=&#34;Model directory in case the smb model in use is &#39;nn&#39;for neural netowrk&#34;,
        )

    def init_smb_simple(self):
        &#34;&#34;&#34;
        initialize simple mass balance
        &#34;&#34;&#34;
        param = np.loadtxt(
            os.path.join(self.config.working_dir, self.config.mb_simple_file),
            skiprows=1,
            dtype=np.float32,
        )

        self.gradabl = interp1d(
            param[:, 0],
            param[:, 1],
            fill_value=(param[0, 1], param[-1, 1]),
            bounds_error=False,
        )
        self.gradacc = interp1d(
            param[:, 0],
            param[:, 2],
            fill_value=(param[0, 2], param[-1, 2]),
            bounds_error=False,
        )
        self.ela = interp1d(
            param[:, 0],
            param[:, 3],
            fill_value=(param[0, 3], param[-1, 3]),
            bounds_error=False,
        )
        self.maxacc = interp1d(
            param[:, 0],
            param[:, 4],
            fill_value=(param[0, 4], param[-1, 4]),
            bounds_error=False,
        )

    def update_smb_simple(self):
        &#34;&#34;&#34;
        mass balance &#39;simple&#39; parametrized by ELA, ablation and accumulation gradients, and max acuumulation
        &#34;&#34;&#34;

        ela = np.float32(self.ela(self.t))
        gradabl = np.float32(self.gradabl(self.t))
        gradacc = np.float32(self.gradacc(self.t))
        maxacc = np.float32(self.maxacc(self.t))

        smb = self.usurf - ela
        smb *= tf.where(tf.less(smb, 0), gradabl, gradacc)
        smb = tf.clip_by_value(smb, -100, maxacc)
        smb = tf.where(self.icemask &gt; 0.5, smb, -10)

        self.smb.assign(smb)

    def init_smb_nn(self):
        &#34;&#34;&#34;
        set-up the smb nn emulator
        &#34;&#34;&#34;

        dirpath = os.path.join(self.config.smb_model_lib_path, str(int(self.dx)))

        assert os.path.isdir(dirpath)

        fieldin, fieldout, fieldbounds = self.read_fields_and_bounds(dirpath)

        self.read_fields_and_bounds(dirpath)

        self.smb_mapping = {}
        self.smb_mapping[&#34;fieldin&#34;] = fieldin
        self.smb_mapping[&#34;fieldout&#34;] = fieldout
        self.smb_fieldbounds = fieldbounds

        self.smb_model = tf.keras.models.load_model(os.path.join(dirpath, &#34;model.h5&#34;))

    def update_smb_nn(self):
        &#34;&#34;&#34;
        function update the smb using the neural network emulator
        &#34;&#34;&#34;

        # this is not a nice implementation, but for now, it does the job
        self.mask = tf.ones_like(self.thk)
        for i in range(12):
            vars(self)[&#34;air_temp_&#34; + str(i)] = self.air_temp[i]
            vars(self)[&#34;precipitation_&#34; + str(i)] = self.precipitation[i]

        X = tf.expand_dims(
            tf.stack(
                [
                    vars(self)[f] / self.smb_fieldbounds[f]
                    for f in self.smb_mapping[&#34;fieldin&#34;]
                ],
                axis=-1,
            ),
            axis=0,
        )

        Y = self.smb_model.predict_on_batch(X)

        # this will return the smb, the only output of the smb nn emulator
        for kk, f in enumerate(self.smb_mapping[&#34;fieldout&#34;]):
            vars(self)[f].assign(Y[0, :, :, kk] * self.smb_fieldbounds[f])

    def update_smb(self, force=False):
        &#34;&#34;&#34;
        update_mass balance
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_smb&#34;):
            self.tlast_mb = -1.0e5000
            self.tcomp[&#34;Mass balance&#34;] = []
            if len(self.config.type_mass_balance) &gt; 0:
                if hasattr(self, &#34;init_smb_&#34; + self.config.type_mass_balance):
                    getattr(self, &#34;init_smb_&#34; + self.config.type_mass_balance)()
            self.already_called_update_smb = True

        if (force) | ((self.t.numpy() - self.tlast_mb) &gt;= self.config.mb_update_freq):

            if self.config.verbosity == 1:
                print(&#34;Construct mass balance at time : &#34;, self.t.numpy())

            self.tcomp[&#34;Mass balance&#34;].append(time.time())

            if len(self.config.type_mass_balance) &gt; 0:
                getattr(self, &#34;update_smb_&#34; + self.config.type_mass_balance)()
            else:
                self.smb.assign(tf.zeros_like(self.topg))

            if hasattr(self, &#34;icemask&#34;):
                self.smb.assign(self.smb * self.icemask)

            if not self.config.mb_scaling == 1:
                self.smb.assign(self.smb * self.config.mb_scaling)

            self.tlast_mb = self.t.numpy()

            if self.config.stop:
                mb_np = self.smb.numpy()

            self.tcomp[&#34;Mass balance&#34;][-1] -= time.time()
            self.tcomp[&#34;Mass balance&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              BASAL EROSION
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_erosion(self):

        self.parser.add_argument(
            &#34;--erosion_include&#34;,
            type=str2bool,
            default=False,
            help=&#34;Include a model for bedrock erosion&#34;,
        )
        self.parser.add_argument(
            &#34;--erosion_cst&#34;,
            type=float,
            default=2.7 * 10 ** (-7),
            help=&#34;Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193–195 (2015)&#34;,
        )

        self.parser.add_argument(
            &#34;--erosion_exp&#34;,
            type=float,
            default=2,
            help=&#34;Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193–195 (2015).&#34;,
        )
        self.parser.add_argument(
            &#34;--erosion_update_freq&#34;,
            type=float,
            default=100,
            help=&#34;Update the erosion only each 100 years&#34;,
        )

    def update_topg(self):
        &#34;&#34;&#34;
        update bedrock due to glacial errosion,
        eroson rate are proportional to a power
        of the sliding velocity magnitude
        &#34;&#34;&#34;

        if self.config.erosion_include:

            if not hasattr(self, &#34;already_called_update_topg&#34;):
                self.tlast_erosion = self.config.tstart
                self.tcomp[&#34;Erosion&#34;] = []
                self.already_called_update_topg = True

            if (self.t.numpy() - self.tlast_erosion) &gt;= self.config.erosion_update_freq:

                if self.config.verbosity == 1:
                    print(&#34;Erode bedrock at time : &#34;, self.t.numpy())

                self.tcomp[&#34;Erosion&#34;].append(time.time())

                self.velbase_mag = self.getmag(self.uvelbase, self.vvelbase)

                self.dtopgdt.assign(self.config.erosion_cst * (self.velbase_mag ** self.config.erosion_exp))

                self.topg.assign(self.topg - (self.t.numpy() - self.tlast_erosion) * self.dtopgdt)

                print(&#39;max erosion is :&#39;, np.max( np.abs ( self.dtopgdt ) ) )

                self.usurf.assign(self.topg + self.thk)

                self.tlast_erosion = self.t.numpy()

                self.tcomp[&#34;Erosion&#34;][-1] -= time.time()
                self.tcomp[&#34;Erosion&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              TRANSPORT
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def update_thk(self):
        &#34;&#34;&#34;
        update ice thickness solving dh/dt + d(u h)/dx + d(v h)/dy = f using
        upwind finite volume, update usurf and slopes
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_icethickness&#34;):
            self.tcomp[&#34;Transport&#34;] = []
            self.already_called_update_icethickness = True

        if self.config.verbosity == 1:
            print(&#34;Ice thickness equation at time : &#34;, self.t.numpy())

        self.tcomp[&#34;Transport&#34;].append(time.time())

        # compute the divergence of the flux
        self.divflux = self.compute_divflux(
            self.ubar, self.vbar, self.thk, self.dx, self.dx
        )

        # Forward Euler with projection to keep ice thickness non-negative
        self.thk.assign(tf.maximum(self.thk + self.dt * (self.smb - self.divflux), 0))

        self.usurf.assign(self.topg + self.thk)

        self.slopsurfx, self.slopsurfy = self.compute_gradient_tf(
            self.usurf, self.dx, self.dx
        )

        self.tcomp[&#34;Transport&#34;][-1] -= time.time()
        self.tcomp[&#34;Transport&#34;][-1] *= -1

    @tf.function()
    def compute_divflux(self, u, v, h, dx, dy):
        &#34;&#34;&#34;
        #   upwind computation of the divergence of the flux : d(u h)/dx + d(v h)/dy
        #   First, u and v are computed on the staggered grid (i.e. cell edges)
        #   Second, one extend h horizontally by a cell layer on any bords (assuming same value)
        #   Third, one compute the flux on the staggered grid slecting upwind quantities
        #   Last, computing the divergence on the staggered grid yields values def on the original grid
        &#34;&#34;&#34;

        ## Compute u and v on the staggered grid
        u = tf.concat(
            [u[:, 0:1], 0.5 * (u[:, :-1] + u[:, 1:]), u[:, -1:]], 1
        )  # has shape (ny,nx+1)
        v = tf.concat(
            [v[0:1, :], 0.5 * (v[:-1, :] + v[1:, :]), v[-1:, :]], 0
        )  # has shape (ny+1,nx)

        # Extend h with constant value at the domain boundaries
        Hx = tf.pad(h, [[0, 0], [1, 1]], &#34;CONSTANT&#34;)  # has shape (ny,nx+2)
        Hy = tf.pad(h, [[1, 1], [0, 0]], &#34;CONSTANT&#34;)  # has shape (ny+2,nx)

        ## Compute fluxes by selcting the upwind quantities
        Qx = u * tf.where(u &gt; 0, Hx[:, :-1], Hx[:, 1:])  # has shape (ny,nx+1)
        Qy = v * tf.where(v &gt; 0, Hy[:-1, :], Hy[1:, :])  # has shape (ny+1,nx)

        ## Computation of the divergence, final shape is (ny,nx)
        return (Qx[:, 1:] - Qx[:, :-1]) / dx + (Qy[1:, :] - Qy[:-1, :]) / dy

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               3DVEL
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_3dvel(self):

        self.parser.add_argument(
            &#34;--vel3d_active&#34;,
            type=int,
            default=False,
            help=&#34;Is the computational of the 3D vel active?&#34;,
        )

        self.parser.add_argument(
            &#34;--dz&#34;,
            type=int,
            default=20,
            help=&#34;Vertical discretization constant spacing&#34;,
        )

        self.parser.add_argument(
            &#34;--maxthk&#34;, type=float, default=1000.0, help=&#34;Vertical maximum thickness&#34;
        )

    def init_3dvel(self):

        if self.config.vel3d_active:

            self.height = np.arange(
                0, self.config.maxthk + 1, self.config.dz
            )  # height with constant dz
            self.ddz = self.height[1:] - self.height[:-1]

            self.nz = tf.Variable(
                tf.zeros((self.thk.shape[0], self.thk.shape[1]), dtype=&#34;int32&#34;)
            )
            self.depth = tf.Variable(
                tf.zeros(
                    (self.height.shape[0], self.thk.shape[0], self.thk.shape[1]),
                    dtype=&#34;float32&#34;,
                )
            )
            self.dz = tf.Variable(
                tf.zeros(
                    (self.height.shape[0] - 1, self.thk.shape[0], self.thk.shape[1]),
                    dtype=&#34;float32&#34;,
                )
            )

            self.U = tf.Variable(tf.zeros_like(self.depth))  # x-vel component
            self.V = tf.Variable(tf.zeros_like(self.depth))  # y-vel component
            self.W = tf.Variable(tf.zeros_like(self.depth))  # z-vel component

            self.tcomp[&#34;3d Vel&#34;] = []

    @tf.function()
    def update_vert_disc_tf(self):

        # nz is the index of the first node above the ice surface
        nz = tf.ones(self.thk.shape, &#34;int32&#34;) * (self.height.shape[0] - 1)
        for k in range(self.height.shape[0] - 1, -1, -1):
            nz = tf.where(self.height[k] &gt; self.thk, k, nz)
        self.nz.assign(tf.where(self.thk &gt;= self.ddz[0], nz, 1))

        # depth is the depth of ice at any grid point, otherwise it is zero
        depth = []
        for k in range(0, self.height.shape[0]):
            depth.append(
                tf.where(
                    (self.thk &gt;= self.ddz[0]) &amp; (k &lt; self.nz),
                    self.thk - self.height[k],
                    0.0,
                )
            )
        self.depth.assign(tf.stack(depth, axis=0))

        # dz is the  vertical spacing,
        dz = []
        for k in range(0, self.height.shape[0] - 1):
            dz.append(tf.ones_like(self.thk) * self.ddz[k])
        self.dz.assign(tf.stack(dz, axis=0))

    @tf.function()
    def update_reconstruct_3dvel_tf(self):

        # Reconstruct the horizontal velocity field from basal and surface velocity assuming a SIA-like profile
        fshear = []
        U = []
        V = []
        W = []

        fshear.append(tf.zeros_like(self.thk))

        for k in range(1, self.height.shape[0]):
            fshear.append(
                fshear[-1]
                + tf.where(k &lt; self.nz, self.dz[k - 1], 0.0) * (self.depth[k] ** 3)
            )

        norm = fshear[-1]

        for k in range(0, self.height.shape[0]):
            fshear[k] /= tf.where(self.nz &gt; 1, norm, 1.0)

        for k in range(0, self.height.shape[0]):
            U.append(self.uvelbase + fshear[k] * (self.uvelsurf - self.uvelbase))
            V.append(self.vvelbase + fshear[k] * (self.vvelsurf - self.vvelbase))

        self.U.assign(tf.stack(U, axis=0))
        self.V.assign(tf.stack(V, axis=0))

        Ui = tf.pad(self.U, [[0, 0], [0, 0], [1, 1]], &#34;SYMMETRIC&#34;)
        Vj = tf.pad(self.V, [[0, 0], [1, 1], [0, 0]], &#34;SYMMETRIC&#34;)

        ######### THis methods reconstruct the vertical velocity using divflux,
        ######### and assuming a SIA-like profile like x- and y- components

        slopsurfx, slopsurfy = self.compute_gradient_tf(self.usurf, self.dx, self.dx)
        sloptopgx, sloptopgy = self.compute_gradient_tf(self.topg, self.dx, self.dx)

        divflux = self.compute_divflux(self.ubar, self.vbar, self.thk, self.dx, self.dx)

        self.wvelbase = self.uvelbase * sloptopgx + self.vvelbase * sloptopgy
        self.wvelsurf = -divflux + self.uvelsurf * slopsurfx + self.vvelsurf * slopsurfy

        for k in range(0, self.height.shape[0]):
            W.append(self.wvelbase + fshear[k] * (self.wvelsurf - self.wvelbase))

        self.W.assign(tf.stack(W, axis=0))

        ### This methods integrates the imcompressiblity conditoons

        # W.append( tf.zeros_like(self.thk) )

        # for k in range(1,self.height.shape[0]):
        #     W.append( W[-1] + tf.where( k&lt;self.nz, \
        #                                 self.dz[k-1] * ( - (Ui[k-1,:, 2:] - Ui[k-1,:,:-2]) / (2*self.dx) \
        #                                                  - (Vj[k-1,2:, :] - Vj[k-1,:-2,:]) / (2*self.dx) ), \
        #                                 0.0 )
        #             )

        # self.W.assign( tf.stack(W,axis=0) )

    def update_3dvel(self):

        if self.config.vel3d_active:

            if self.config.verbosity == 1:
                print(&#34;update_3dvel &#34;)

            self.tcomp[&#34;3d Vel&#34;].append(time.time())

            self.update_vert_disc_tf()

            self.update_reconstruct_3dvel_tf()

            self.update_ncdf_3d_ex()

            self.tcomp[&#34;3d Vel&#34;][-1] -= time.time()
            self.tcomp[&#34;3d Vel&#34;][-1] *= -1

    def update_ncdf_3d_ex(self, force=False):
        &#34;&#34;&#34;
        Initialize  and write the ncdf output file
        &#34;&#34;&#34;

        if force | self.saveresult:

            if self.it == 0:

                if self.config.verbosity == 1:
                    print(&#34;Initialize NCDF output Files&#34;)

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex3d.nc&#34;),
                    &#34;w&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                nc.createDimension(&#34;time&#34;, None)
                E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
                E.units = &#34;yr&#34;
                E.long_name = &#34;time&#34;
                E.axis = &#34;T&#34;
                E[0] = self.t.numpy()

                nc.createDimension(&#34;h&#34;, self.height.shape[0])
                E = nc.createVariable(&#34;h&#34;, np.dtype(&#34;float32&#34;).char, (&#34;h&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;h&#34;
                E.standard_name = &#34;h&#34;
                E.axis = &#34;H&#34;
                E[:] = self.height

                nc.createDimension(&#34;y&#34;, len(self.y))
                E = nc.createVariable(&#34;y&#34;, np.dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;y&#34;
                E.axis = &#34;Y&#34;
                E[:] = self.y.numpy()

                nc.createDimension(&#34;x&#34;, len(self.x))
                E = nc.createVariable(&#34;x&#34;, np.dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;x&#34;
                E.axis = &#34;X&#34;
                E[:] = self.x.numpy()

                E = nc.createVariable(
                    &#34;topg&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m&#34;
                E.long_name = &#34;topg&#34;
                E.standard_name = &#34;topg&#34;
                E[0, :, :] = self.topg.numpy()

                E = nc.createVariable(
                    &#34;usurf&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m&#34;
                E.long_name = &#34;usurf&#34;
                E.standard_name = &#34;usurf&#34;
                E[0, :, :] = self.usurf.numpy()

                E = nc.createVariable(
                    &#34;U&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m/y&#34;
                E.long_name = &#34;U&#34;
                E.standard_name = &#34;U&#34;
                E[0, :, :, :] = self.U.numpy()

                E = nc.createVariable(
                    &#34;V&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m/y&#34;
                E.long_name = &#34;V&#34;
                E.standard_name = &#34;V&#34;
                E[0, :, :, :] = self.V.numpy()

                E = nc.createVariable(
                    &#34;W&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m/y&#34;
                E.long_name = &#34;W&#34;
                E.standard_name = &#34;W&#34;
                E[0, :, :, :] = self.W.numpy()

                nc.close()

            else:

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex3d.nc&#34;),
                    &#34;a&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                d = nc.variables[&#34;time&#34;][:].shape[0]
                nc.variables[&#34;time&#34;][d] = self.t.numpy()
                nc.variables[&#34;U&#34;][d, :, :, :] = self.U.numpy()
                nc.variables[&#34;V&#34;][d, :, :, :] = self.V.numpy()
                nc.variables[&#34;W&#34;][d, :, :, :] = self.W.numpy()
                nc.variables[&#34;usurf&#34;][d, :, :] = self.usurf.numpy()
                nc.variables[&#34;topg&#34;][d, :, :] = self.topg.numpy()

                nc.close()

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               OPTI
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_optimize(self):

        # OPTIMIZATION PARAMETERS
        self.parser.add_argument(
            &#34;--opti_vars_to_save&#34;,
            type=list,
            default=[
                &#34;topg&#34;,
                &#34;usurf&#34;,
                &#34;thk&#34;,
                &#34;strflowctrl&#34;,
                &#34;arrhenius&#34;,
                &#34;slidingco&#34;,
                &#34;velsurf_mag&#34;,
                &#34;velsurfobs_mag&#34;,
                &#34;divflux&#34;,
            ],
            help=&#34;List of variables to be recorded in the ncdef file&#34;,
        )
        self.parser.add_argument(
            &#34;--observation_file&#34;,
            type=str,
            default=&#34;observation.nc&#34;,
            help=&#34;Observation file contains the 2D data observations fields (thkobs, usurfobs, uvelsurfobs, ....) &#34;,
        )
        self.parser.add_argument(
            &#34;--thk_profiles_file&#34;,
            type=str,
            default=&#34;&#34;,
            help=&#34;Provide ice thickness measurements, if empty string it will look for rasterized thk in the input data file&#34;,
        )
        self.parser.add_argument(&#34;--mode_opti&#34;, type=str, default=&#34;thkstrflowctrl&#34;)

        self.parser.add_argument(
            &#34;--opti_thr_strflowctrl&#34;,
            type=float,
            default=78.0,
            help=&#34;threshold value for strflowctrl&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_init_zero_thk&#34;,
            type=str2bool,
            default=&#34;False&#34;,
            help=&#34;Initialize the optimization with zero ice thickness&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_regu_param_thk&#34;,
            type=float,
            default=10.0,
            help=&#34;Regularization weight for the ice thickness in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_regu_param_strflowctrl&#34;,
            type=float,
            default=1.0,
            help=&#34;Regularization weight for the strflowctrl field in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_smooth_anisotropy_factor&#34;,
            type=float,
            default=0.2,
            help=&#34;Smooth anisotropy factor for the ice thickness regularization in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_convexity_weight&#34;,
            type=float,
            default=0.002,
            help=&#34;Convexity weight for the ice thickness regularization in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_usurfobs_std&#34;,
            type=float,
            default=5.0,
            help=&#34;Confidence/STD of the top ice surface as input data for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_strflowctrl_std&#34;,
            type=float,
            default=5.0,
            help=&#34;Confidence/STD of strflowctrl&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_velsurfobs_std&#34;,
            type=float,
            default=3.0,
            help=&#34;Confidence/STD of the surface ice velocities as input data for the optimization (if 0, velsurfobs_std field must be given)&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_thkobs_std&#34;,
            type=float,
            default=5.0,
            help=&#34;Confidence/STD of the ice thickness profiles (unless given)&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_divfluxobs_std&#34;,
            type=float,
            default=1.0,
            help=&#34;Confidence/STD of the flux divergence as input data for the optimization (if 0, divfluxobs_std field must be given)&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_control&#34;,
            type=list,
            default=[&#34;thk&#34;, &#34;strflowctrl&#34;, &#34;usurf&#34;],
            help=&#34;List of optimized variables for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_cost&#34;,
            type=list,
            default=[&#34;velsurf&#34;, &#34;thk&#34;, &#34;usurf&#34;, &#34;divfluxfcz&#34;, &#34;icemask&#34;],
            help=&#34;List of cost components for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_nbitmin&#34;,
            type=int,
            default=50,
            help=&#34;Min iterations for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_nbitmax&#34;,
            type=int,
            default=1000,
            help=&#34;Max iterations for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_step_size&#34;,
            type=float,
            default=0.001,
            help=&#34;Step size for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_make_holes_in_data&#34;,
            type=int,
            default=0,
            help=&#34;This produces artifical holes in data, serve to test the robustness of the method to missing data&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_output_freq&#34;,
            type=int,
            default=50,
            help=&#34;Frequency of the output for the optimization&#34;,
        )

    def make_data_holes(self):
        &#34;&#34;&#34;
        This serves to make holes in surface data (velocities) to test robusness of the optimization
        &#34;&#34;&#34;

        mask_holes = np.zeros_like(self.thk.numpy(), dtype=&#34;int&#34;)

        if (self.config.opti_make_holes_in_data &gt; 0) &amp; (
            self.config.opti_make_holes_in_data &lt; 99
        ):

            np.random.seed(seed=123)

            while (
                np.sum(mask_holes) / np.sum(self.icemaskobs &gt; 0.5)
            ) &lt; self.config.opti_make_holes_in_data * 0.01:

                j = np.random.randint(0, self.thk.shape[0])
                i = np.random.randint(0, self.thk.shape[1])

                if self.icemaskobs[j, i] &gt; 0.5:
                    mask_holes[j, i] = 1

        elif self.config.opti_make_holes_in_data == 100:
            mask_holes = np.ones_like(self.thk.numpy(), dtype=&#34;int&#34;)

        elif self.config.opti_make_holes_in_data == 200:
            mask_holes[self.Y &gt; np.mean(self.y)] = 1

        self.uvelsurfobs = tf.where(
            (self.icemaskobs == 1) &amp; (mask_holes == 0), self.uvelsurfobs, np.nan
        )
        self.vvelsurfobs = tf.where(
            (self.icemaskobs == 1) &amp; (mask_holes == 0), self.vvelsurfobs, np.nan
        )

    def load_thk_profiles(self):
        &#34;&#34;&#34;
        load glacier ice thickness mesured profiles
        &#34;&#34;&#34;

        pathprofile = os.path.join(
            self.config.working_dir, self.config.thk_profiles_file
        )

        if len(glob.glob(pathprofile)) &gt; 0:

            vvv = []
            for g in glob.glob(pathprofile):
                vvv.append(np.loadtxt(g, dtype=np.float32))
            self.profile = np.concatenate(vvv, axis=0)

            # re-index profiles in case there were not properly indexed
            self.profile = [
                self.profile[np.floor(self.profile[:, 0]) == i + 1, :]
                for i in range(int(np.max(self.profile[:, 0])))
            ]

            # Remove empty List from List using list comprehension
            self.profile = [ele for ele in self.profile if len(ele) &gt; 0]

            # compute the distance between points as first entry as it will be usefully later on
            for p in self.profile:
                p[:, 0] = np.insert(
                    np.cumsum(np.sqrt(np.diff(p[:, 1]) ** 2 + np.diff(p[:, 2]) ** 2)),
                    0,
                    0,
                )
        else:
            sys.exit(&#34;thk requested in opti, but file &#34; + pathprofile + &#34; is not found&#34;)

        points = np.stack([item[1:3] for sublist in self.profile for item in sublist])
        jiptprof = []
        for p in points:
            i = (p[0] - np.min(self.X)) / self.dx
            j = (p[1] - np.min(self.Y)) / self.dx
            jiptprof.append([j, i])
        self.jiptprof = tf.expand_dims(jiptprof, axis=0)

        target = np.stack([item[3] for sublist in self.profile for item in sublist])
        self.thktargetprof = tf.Variable(target.astype(&#34;float32&#34;))

        target = np.stack([item[4] for sublist in self.profile for item in sublist])
        self.thktargetprof_std = tf.Variable(target.astype(&#34;float32&#34;))

    def compute_flow_direction_for_anisotropic_smoothing(self):
        &#34;&#34;&#34;
        compute_flow_direction_for_anisotropic_smoothing
        &#34;&#34;&#34;

        uvelsurfobs = tf.where(tf.math.is_nan(self.uvelsurfobs), 0.0, self.uvelsurfobs)
        vvelsurfobs = tf.where(tf.math.is_nan(self.vvelsurfobs), 0.0, self.vvelsurfobs)

        self.flowdirx = (
            uvelsurfobs[1:, 1:]
            + uvelsurfobs[:-1, 1:]
            + uvelsurfobs[1:, :-1]
            + uvelsurfobs[:-1, :-1]
        ) / 4.0
        self.flowdiry = (
            vvelsurfobs[1:, 1:]
            + vvelsurfobs[:-1, 1:]
            + vvelsurfobs[1:, :-1]
            + vvelsurfobs[:-1, :-1]
        ) / 4.0

        from scipy.ndimage import gaussian_filter

        self.flowdirx = gaussian_filter(self.flowdirx, 3, mode=&#34;constant&#34;)
        self.flowdiry = gaussian_filter(self.flowdiry, 3, mode=&#34;constant&#34;)

        # Same as gaussian filter above but for tensorflow is (NOT TESTED)
        # import tensorflow_addons as tfa
        # self.flowdirx.assign( tfa.image.gaussian_filter2d( self.flowdirx , sigma=3, filter_shape=100, padding=&#34;CONSTANT&#34;) )

        self.flowdirx /= self.getmag(self.flowdirx, self.flowdiry)
        self.flowdiry /= self.getmag(self.flowdirx, self.flowdiry)

        self.flowdirx = tf.where(tf.math.is_nan(self.flowdirx), 0.0, self.flowdirx)
        self.flowdiry = tf.where(tf.math.is_nan(self.flowdiry), 0.0, self.flowdiry)

        # this is to plot the observed flow directions
        # fig, axs = plt.subplots(1, 1, figsize=(8,16))
        # plt.quiver(self.flowdirx,self.flowdiry)
        # axs.axis(&#34;equal&#34;)

    def optimize(self):
        &#34;&#34;&#34;
        This is the optimization routine to invert thk, strflowctrl ans usurf from data
        DEFAULT PARAMETERS ARE
        # nbitmin=50, nbitmax=1000, opti_step_size=0.001,
        # init_zero_thk=True,
        # regu_param_thk=1.0, regu_param_strflowctrl=1.0,
        # smooth_anisotropy_factor=0.2, convexity_weight = 0.002,
        # opti_control=[&#39;thk&#39;,&#39;strflowctrl&#39;], opti_cost=[&#39;velsurf&#39;,&#39;thk&#39;],
        &#34;&#34;&#34;

        ###### PERFORM CHECKS PRIOR OPTIMIZATIONS

        # make sure this condition is satisfied
        assert (&#34;usurf&#34; in self.config.opti_cost) == (
            &#34;usurf&#34; in self.config.opti_control
        )

        # make sure the loaded ice flow emulator has these inputs
        assert (
            self.iceflow_mapping[&#34;fieldin&#34;]
            == [&#34;thk&#34;, &#34;slopsurfx&#34;, &#34;slopsurfy&#34;, &#34;arrhenius&#34;, &#34;slidingco&#34;]
        ) | (
            self.iceflow_mapping[&#34;fieldin&#34;]
            == [&#34;thk&#34;, &#34;slopsurfx&#34;, &#34;slopsurfy&#34;, &#34;strflowctrl&#34;]
        )

        # make sure the loaded ice flow emulator has at least these outputs
        assert all(
            [
                (f in self.iceflow_mapping[&#34;fieldout&#34;])
                for f in [&#34;ubar&#34;, &#34;vbar&#34;, &#34;uvelsurf&#34;, &#34;vvelsurf&#34;]
            ]
        )

        # make sure that there are lease some profiles in thkobs
        if &#34;thk&#34; in self.config.opti_cost:
            if self.config.thk_profiles_file == &#34;&#34;:
                assert not tf.reduce_all(tf.math.is_nan(self.thkobs))

        ###### PREPARE DATA PRIOR OPTIMIZATIONS

        if &#34;thk&#34; in self.config.opti_cost:
            if not self.config.thk_profiles_file == &#34;&#34;:
                self.load_thk_profiles()

        if hasattr(self, &#34;uvelsurfobs&#34;) &amp; hasattr(self, &#34;vvelsurfobs&#34;):
            self.velsurfobs = tf.stack([self.uvelsurfobs, self.vvelsurfobs], axis=-1)

        if &#34;divfluxobs&#34; in self.config.opti_cost:
            self.divfluxobs = self.smb - self.dhdt

        if not self.config.opti_smooth_anisotropy_factor == 1:
            self.compute_flow_direction_for_anisotropic_smoothing()

        if self.config.opti_make_holes_in_data &gt; 0:
            self.make_data_holes()

        if hasattr(self, &#34;thkinit&#34;):
            self.thk.assign(self.thkinit)
        else:
            self.thk.assign(tf.zeros_like(self.thk))

        if self.config.opti_init_zero_thk:
            self.thk.assign(tf.zeros_like(self.thk))

        ###### PREPARE OPIMIZER

        optimizer = tf.keras.optimizers.Adam(lr=self.config.opti_step_size)

        # initial_learning_rate * decay_rate ^ (step / decay_steps)
        # lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay( initial_learning_rate=opti_step_size, decay_steps=100, decay_rate=0.9)
        # optimizer = tf.keras.optimizers.Adam(learning_rate=lr_schedule)

        # add scalng for usurf
        self.iceflow_fieldbounds[&#34;usurf&#34;] = (
            self.iceflow_fieldbounds[&#34;slopsurfx&#34;] * self.dx
        )

        ###### PREPARE VARIABLES TO OPTIMIZE

        if self.iceflow_mapping[&#34;fieldin&#34;] == [
            &#34;thk&#34;,
            &#34;slopsurfx&#34;,
            &#34;slopsurfy&#34;,
            &#34;arrhenius&#34;,
            &#34;slidingco&#34;,
        ]:
            self.iceflow_fieldbounds[&#34;strflowctrl&#34;] = (
                self.iceflow_fieldbounds[&#34;arrhenius&#34;]
                + self.iceflow_fieldbounds[&#34;slidingco&#34;]
            )

        thk = tf.Variable(self.thk / self.iceflow_fieldbounds[&#34;thk&#34;])  # normalized vars
        strflowctrl = tf.Variable(
            self.strflowctrl / self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
        )  # normalized vars
        usurf = tf.Variable(
            self.usurf / self.iceflow_fieldbounds[&#34;usurf&#34;]
        )  # normalized vars

        self.costs = []

        self.tcomp[&#34;Optimize&#34;] = []

        # main loop
        for i in range(self.config.opti_nbitmax):

            with tf.GradientTape() as t:

                self.tcomp[&#34;Optimize&#34;].append(time.time())

                # is necessary to remember all operation to derive the gradients w.r.t. control variables
                if &#34;thk&#34; in self.config.opti_control:
                    t.watch(thk)
                if &#34;usurf&#34; in self.config.opti_control:
                    t.watch(usurf)
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    t.watch(strflowctrl)

                # update surface gradient
                if (i == 0) | (&#34;usurf&#34; in self.config.opti_control):
                    slopsurfx, slopsurfy = self.compute_gradient_tf(
                        usurf * self.iceflow_fieldbounds[&#34;usurf&#34;], self.dx, self.dx
                    )
                    slopsurfx = slopsurfx / self.iceflow_fieldbounds[&#34;slopsurfx&#34;]
                    slopsurfy = slopsurfy / self.iceflow_fieldbounds[&#34;slopsurfy&#34;]

                if self.iceflow_mapping[&#34;fieldin&#34;] == [
                    &#34;thk&#34;,
                    &#34;slopsurfx&#34;,
                    &#34;slopsurfy&#34;,
                    &#34;arrhenius&#34;,
                    &#34;slidingco&#34;,
                ]:

                    thrv = (
                        self.config.opti_thr_strflowctrl
                        / self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                    )
                    arrhenius = tf.where(strflowctrl &lt;= thrv, strflowctrl, thrv)
                    slidingco = tf.where(strflowctrl &lt;= thrv, 0, strflowctrl - thrv)

                    # build input of the emulator
                    X = tf.concat(
                        [
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(thk, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfx, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfy, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(arrhenius, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slidingco, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                        ],
                        axis=-1,
                    )

                elif self.iceflow_mapping[&#34;fieldin&#34;] == [
                    &#34;thk&#34;,
                    &#34;slopsurfx&#34;,
                    &#34;slopsurfy&#34;,
                    &#34;strflowctrl&#34;,
                ]:

                    # build input of the emulator
                    X = tf.concat(
                        [
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(thk, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfx, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfy, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(strflowctrl, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                        ],
                        axis=-1,
                    )
                else:
                    # ONLY these 2 above cases were implemented !!!
                    sys.exit(
                        &#34;CHANGE THE ICE FLOW EMULATOR -- IMCOMPATIBLE FOR INVERSION &#34;
                    )

                # evalutae th ice flow emulator
                Y = self.iceflow_model(X)

                # get the dimensions of the working array
                Ny, Nx = self.thk.shape

                # save output variables into igm.variables for outputs
                for kk, f in enumerate(self.iceflow_mapping[&#34;fieldout&#34;]):
                    vars(self)[f].assign(
                        Y[0, :Ny, :Nx, kk] * self.iceflow_fieldbounds[f]
                    )

                # find index of variables in output
                iubar = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;ubar&#34;)
                ivbar = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;vbar&#34;)
                iuvsu = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;uvelsurf&#34;)
                ivvsu = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;vvelsurf&#34;)

                # save output of the emaultor to compute the costs function
                ubar = (
                    Y[0, :Ny, :Nx, iubar] * self.iceflow_fieldbounds[&#34;ubar&#34;]
                )  # NOT normalized vars
                vbar = (
                    Y[0, :Ny, :Nx, ivbar] * self.iceflow_fieldbounds[&#34;vbar&#34;]
                )  # NOT normalized vars
                uvelsurf = (
                    Y[0, :Ny, :Nx, iuvsu] * self.iceflow_fieldbounds[&#34;uvelsurf&#34;]
                )  # NOT normalized vars
                vvelsurf = (
                    Y[0, :Ny, :Nx, ivvsu] * self.iceflow_fieldbounds[&#34;vvelsurf&#34;]
                )  # NOT normalized vars
                velsurf = tf.stack([uvelsurf, vvelsurf], axis=-1)  # NOT normalized vars

                # misfit between surface velocity
                if &#34;velsurf&#34; in self.config.opti_cost:
                    ACT = ~tf.math.is_nan(self.velsurfobs)
                    COST_U = 0.5 * tf.reduce_mean(
                        (
                            (self.velsurfobs[ACT] - velsurf[ACT])
                            / self.config.opti_velsurfobs_std
                        )
                        ** 2
                    )
                else:
                    COST_U = tf.Variable(0.0)

                # misfit between ice thickness profiles
                if &#34;thk&#34; in self.config.opti_cost:
                    if self.config.thk_profiles_file == &#34;&#34;:
                        ACT = ~tf.math.is_nan(self.thkobs)
                        COST_H = 0.5 * tf.reduce_mean(
                            (
                                (
                                    self.thkobs[ACT]
                                    - thk[ACT] * self.iceflow_fieldbounds[&#34;thk&#34;]
                                )
                                / self.config.opti_thkobs_std
                            )
                            ** 2
                        )
                    else:
                        import tensorflow_addons as tfa

                        COST_H = 0.5 * tf.reduce_mean(
                            (
                                (
                                    self.thktargetprof
                                    - tfa.image.interpolate_bilinear(
                                        tf.expand_dims(
                                            tf.expand_dims(
                                                thk * self.iceflow_fieldbounds[&#34;thk&#34;],
                                                axis=0,
                                            ),
                                            axis=-1,
                                        ),
                                        self.jiptprof,
                                        indexing=&#34;ij&#34;,
                                    )[0, :, 0]
                                )
                                / self.thktargetprof_std
                            )
                            ** 2
                        )
                else:
                    COST_H = tf.Variable(0.0)

                # misfit divergence of the flux
                if (&#34;divfluxobs&#34; in self.config.opti_cost) | (
                    &#34;divfluxfcz&#34; in self.config.opti_cost
                ):

                    divflux = self.compute_divflux(
                        ubar,
                        vbar,
                        thk * self.iceflow_fieldbounds[&#34;thk&#34;],
                        self.dx,
                        self.dx,
                    )

                    if &#34;divfluxfcz&#34; in self.config.opti_cost:
                        ACT = self.icemaskobs &gt; 0.5
                        if i % 10 == 0:
                            # his does not need to be comptued any iteration as this is expensive
                            res = stats.linregress(
                                self.usurf[ACT], divflux[ACT]
                            )  # this is a linear regression (usually that&#39;s enough)
                        # or you may go for polynomial fit (more gl, but may leads to errors)
                        #  weights = np.polyfit(self.usurf[ACT],divflux[ACT], 2) 
                        divfluxtar = tf.where(
                            ACT, res.intercept + res.slope * self.usurf, 0.0
                        )
                    #                        divfluxtar = tf.where(ACT, np.poly1d(weights)(self.usurf) , 0.0 )

                    else:
                        divfluxtar = self.divfluxobs

                    ACT = self.icemaskobs &gt; 0.5
                    COST_D = 0.5 * tf.reduce_mean(
                        (
                            (divfluxtar[ACT] - divflux[ACT])
                            / self.config.opti_divfluxobs_std
                        )
                        ** 2
                    )

                else:
                    COST_D = tf.Variable(0.0)

                # misfit between top ice surfaces
                if &#34;usurf&#34; in self.config.opti_cost:
                    ACT = self.icemaskobs &gt; 0.5
                    COST_S = 0.5 * tf.reduce_mean(
                        (
                            (
                                usurf[ACT] * self.iceflow_fieldbounds[&#34;usurf&#34;]
                                - self.usurfobs[ACT]
                            )
                            / self.config.opti_usurfobs_std
                        )
                        ** 2
                    )
                else:
                    COST_S = tf.Variable(0.0)

                # force usurf = usurf - topg
                if &#34;topg&#34; in self.config.opti_cost:
                    ACT = self.icemaskobs == 1
                    COST_T = 10 ** 10 * tf.reduce_mean(
                        (
                            usurf[ACT] * self.iceflow_fieldbounds[&#34;usurf&#34;]
                            - thk[ACT] * self.iceflow_fieldbounds[&#34;thk&#34;]
                            - self.topg[ACT]
                        )
                        ** 2
                    )
                else:
                    COST_T = tf.Variable(0.0)

                # force zero thikness outisde the mask
                if &#34;icemask&#34; in self.config.opti_cost:
                    COST_O = 10 ** 10 * tf.math.reduce_mean(
                        tf.where(self.icemaskobs &gt; 0.5, 0.0, thk ** 2)
                    )
                else:
                    COST_O = tf.Variable(0.0)

                # Here one enforces non-negative ice thickness, and possibly zero-thickness in user-defined ice-free areas.
                if &#34;thk&#34; in self.config.opti_control:
                    COST_HPO = 10 ** 10 * tf.math.reduce_mean(
                        tf.where(thk &gt;= 0, 0.0, thk ** 2)
                    )
                else:
                    COST_HPO = tf.Variable(0.0)

                # # Make sur to keep reasonable values for strflowctrl
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    COST_STR = 0.5 * tf.reduce_mean(
                        (
                            (
                                strflowctrl * self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                                - self.config.opti_thr_strflowctrl
                            )
                            / self.config.opti_strflowctrl_std
                        )
                        ** 2
                    )
                else:
                    COST_STR = tf.Variable(0.0)

                # Here one adds a regularization terms for the ice thickness to the cost function
                if &#34;thk&#34; in self.config.opti_control:
                    dbdx = thk[:, 1:] - thk[:, :-1]
                    dbdx = (dbdx[1:, :] + dbdx[:-1, :]) / 2.0
                    dbdy = thk[1:, :] - thk[:-1, :]
                    dbdy = (dbdy[:, 1:] + dbdy[:, :-1]) / 2.0

                    if self.config.opti_smooth_anisotropy_factor == 1:
                        REGU_H = self.config.opti_regu_param_thk * (
                            tf.nn.l2_loss(dbdx) + tf.nn.l2_loss(dbdy)
                        )
                    else:
                        REGU_H = self.config.opti_regu_param_thk * (
                            tf.nn.l2_loss((dbdx * self.flowdirx + dbdy * self.flowdiry))
                            + self.config.opti_smooth_anisotropy_factor
                            * tf.nn.l2_loss(
                                (dbdx * self.flowdiry - dbdy * self.flowdirx)
                            )
                            - self.config.opti_convexity_weight
                            * tf.math.reduce_sum(thk)
                        )
                else:
                    REGU_H = tf.Variable(0.0)

                # Here one adds a regularization terms for strflowctrl to the cost function
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    dadx = tf.math.abs(strflowctrl[:, 1:] - strflowctrl[:, :-1])
                    dady = tf.math.abs(strflowctrl[1:, :] - strflowctrl[:-1, :])
                    dadx = tf.where(
                        (self.icemaskobs[:, 1:] &gt; 0.5)
                        &amp; (self.icemaskobs[:, :-1] &gt; 0.5),
                        dadx,
                        0.0,
                    )
                    dady = tf.where(
                        (self.icemaskobs[1:, :] &gt; 0.5)
                        &amp; (self.icemaskobs[:-1, :] &gt; 0.5),
                        dady,
                        0.0,
                    )
                    REGU_A = self.config.opti_regu_param_strflowctrl * (
                        tf.nn.l2_loss(dadx) + tf.nn.l2_loss(dady)
                    )
                else:
                    REGU_A = tf.Variable(0.0)

                # sum all component into the main cost function
                COST = (
                    COST_U
                    + COST_H
                    + COST_D
                    + COST_S
                    + COST_T
                    + COST_O
                    + COST_HPO
                    + COST_STR
                    + REGU_H
                    + REGU_A
                )

                vol = (
                    np.sum(thk * self.iceflow_fieldbounds[&#34;thk&#34;])
                    * (self.dx ** 2)
                    / 10 ** 9
                )

                if i % self.config.opti_output_freq == 0:
                    print(
                        &#34; OPTI, step %5.0f , ICE_VOL: %7.2f , COST_U: %7.2f , COST_H: %7.2f , COST_D : %7.2f , COST_S : %7.2f , REGU_H : %7.2f , REGU_A : %7.2f &#34;
                        % (
                            i,
                            vol,
                            COST_U.numpy(),
                            COST_H.numpy(),
                            COST_D.numpy(),
                            COST_S.numpy(),
                            REGU_H.numpy(),
                            REGU_A.numpy(),
                        )
                    )

                self.costs.append(
                    [
                        COST_U.numpy(),
                        COST_H.numpy(),
                        COST_D.numpy(),
                        COST_S.numpy(),
                        REGU_H.numpy(),
                        REGU_A.numpy(),
                    ]
                )

                var_to_opti = []
                if &#34;thk&#34; in self.config.opti_control:
                    var_to_opti.append(thk)
                if &#34;usurf&#34; in self.config.opti_control:
                    var_to_opti.append(usurf)
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    var_to_opti.append(strflowctrl)

                # Compute gradient of COST w.r.t. X
                grads = tf.Variable(t.gradient(COST, var_to_opti))

                # this serve to restict the optimization of controls to the mask
                for ii in range(grads.shape[0]):
                    grads[ii].assign(tf.where((self.icemaskobs &gt; 0.5), grads[ii], 0))

                # One step of descent -&gt; this will update input variable X
                optimizer.apply_gradients(
                    zip([grads[i] for i in range(grads.shape[0])], var_to_opti)
                )

                # get back optimized variables in the pool of igm.variables
                if &#34;thk&#34; in self.config.opti_control:
                    self.thk.assign(thk * self.iceflow_fieldbounds[&#34;thk&#34;])
                    self.thk.assign(tf.where(self.thk &lt; 0.01, 0, self.thk))
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    self.strflowctrl.assign(
                        strflowctrl * self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                    )
                if &#34;usurf&#34; in self.config.opti_control:
                    self.usurf.assign(usurf * self.iceflow_fieldbounds[&#34;usurf&#34;])

                self.divflux = self.compute_divflux(
                    self.ubar, self.vbar, self.thk, self.dx, self.dx
                )

                self.compute_rms_std_optimization(i)

                self.tcomp[&#34;Optimize&#34;][-1] -= time.time()
                self.tcomp[&#34;Optimize&#34;][-1] *= -1

                if i % self.config.opti_output_freq == 0:
                    self.update_plot_inversion(i, self.config.plot_live)
                    self.update_ncdf_optimize(i)
                # self.update_plot_profiles(i,plot_live)

                # stopping criterion: stop if the cost no longer decrease
                # if i&gt;self.config.opti_nbitmin:
                #     cost = [c[0] for c in costs]
                #     if np.mean(cost[-10:])&gt;np.mean(cost[-20:-10]):
                #         break;

        # now that the ice thickness is optimized, we can fix the bed once for all!
        self.topg.assign(self.usurf - self.thk)

        self.output_ncdf_optimize_final()

        self.plot_cost_functions(self.costs, self.config.plot_live)

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;costs.dat&#34;),
            np.stack(self.costs),
            fmt=&#34;%.10f&#34;,
            header=&#34;        COST_U        COST_H      COST_D       COST_S       REGU_H       REGU_A          HPO &#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;rms_std.dat&#34;),
            np.stack(
                [
                    self.rmsthk,
                    self.stdthk,
                    self.rmsvel,
                    self.stdvel,
                    self.rmsdiv,
                    self.stddiv,
                    self.rmsusurf,
                    self.stdusurf,
                ],
                axis=-1,
            ),
            fmt=&#34;%.10f&#34;,
            header=&#34;        rmsthk      stdthk       rmsvel       stdvel       rmsdiv       stddiv       rmsusurf       stdusurf&#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;strflowctrl.dat&#34;),
            np.array(
                [
                    np.mean(self.strflowctrl[self.icemaskobs &gt; 0.5]),
                    np.std(self.strflowctrl[self.icemaskobs &gt; 0.5]),
                ]
            ),
            fmt=&#34;%.3f&#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;volume.dat&#34;),
            np.array([np.sum(self.thk) * self.dx * self.dx / (10 ** 9)]),
            fmt=&#34;%.3f&#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;tcompoptimize.dat&#34;),
            np.array([np.sum([f for f in self.tcomp[&#34;Optimize&#34;]])]),
            fmt=&#34;%.3f&#34;,
        )

    def run_opti(self):

        self.initialize()

        with tf.device(self.device_name):

            self.load_ncdf_data(self.config.observation_file)

            self.initialize_fields()

            self.initialize_iceflow()

            self.optimize()

    def compute_rms_std_optimization(self, i):
        &#34;&#34;&#34;
        compute_std_optimization
        &#34;&#34;&#34;

        I = self.icemaskobs == 1

        if i == 0:
            self.rmsthk = []
            self.stdthk = []
            self.rmsvel = []
            self.stdvel = []
            self.rmsusurf = []
            self.stdusurf = []
            self.rmsdiv = []
            self.stddiv = []

        if hasattr(self, &#34;profile&#34;) | hasattr(self, &#34;thkobs&#34;):
            if self.config.thk_profiles_file == &#34;&#34;:
                ACT = ~tf.math.is_nan(self.thkobs)
                if np.sum(ACT) == 0:
                    self.rmsthk.append(0)
                    self.stdthk.append(0)
                else:
                    self.rmsthk.append(np.nanmean(self.thk[ACT] - self.thkobs[ACT]))
                    self.stdthk.append(np.nanstd(self.thk[ACT] - self.thkobs[ACT]))

            else:
                fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))
                thkdiff = np.concatenate(
                    [
                        (fthk(p[:, 1], p[:, 2], grid=False) - p[:, 3])
                        for p in self.profile
                    ]
                )
                self.rmsthk.append(np.mean(thkdiff))
                self.stdthk.append(np.std(thkdiff))
        else:
            self.rmsthk.append(0)
            self.stdthk.append(0)

        if hasattr(self, &#34;uvelsurfobs&#34;):
            velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf).numpy()
            velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs).numpy()
            ACT = ~np.isnan(velsurfobs_mag)

            self.rmsvel.append(
                np.mean(
                    velsurf_mag[(I &amp; ACT).numpy()] - velsurfobs_mag[(I &amp; ACT).numpy()]
                )
            )
            self.stdvel.append(
                np.std(
                    velsurf_mag[(I &amp; ACT).numpy()] - velsurfobs_mag[(I &amp; ACT).numpy()]
                )
            )
        else:
            self.rmsvel.append(0)
            self.stdvel.append(0)

        if hasattr(self, &#34;divfluxobs&#34;):
            self.rmsdiv.append(np.mean(self.divfluxobs[I] - self.divflux[I]))
            self.stddiv.append(np.std(self.divfluxobs[I] - self.divflux[I]))
        else:
            self.rmsdiv.append(0)
            self.stddiv.append(0)

        if hasattr(self, &#34;usurfobs&#34;):
            self.rmsusurf.append(np.mean(self.usurf[I] - self.usurfobs[I]))
            self.stdusurf.append(np.std(self.usurf[I] - self.usurfobs[I]))
        else:
            self.rmsusurf.append(0)
            self.stdusurf.append(0)

    def update_ncdf_optimize(self, it):
        &#34;&#34;&#34;
        Initialize and write the ncdf optimze file
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Initialize  and write NCDF output Files&#34;)

        if &#34;arrhenius&#34; in self.config.opti_vars_to_save:
            self.arrhenius = tf.where(
                self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
                self.strflowctrl,
                self.config.opti_thr_strflowctrl,
            )

        if &#34;slidingco&#34; in self.config.opti_vars_to_save:
            self.slidingco = tf.where(
                self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
                0,
                self.strflowctrl - self.config.opti_thr_strflowctrl,
            )

        if &#34;topg&#34; in self.config.opti_vars_to_save:
            self.topg.assign(self.usurf - self.thk)

        if &#34;velsurf_mag&#34; in self.config.opti_vars_to_save:
            self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

        if &#34;velsurfobs_mag&#34; in self.config.opti_vars_to_save:
            self.velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs)

        if it == 0:

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;optimize.nc&#34;),
                &#34;w&#34;,
                format=&#34;NETCDF4&#34;,
            )

            nc.createDimension(&#34;iterations&#34;, None)
            E = nc.createVariable(&#34;iterations&#34;, dtype(&#34;float32&#34;).char, (&#34;iterations&#34;,))
            E.units = &#34;None&#34;
            E.long_name = &#34;iterations&#34;
            E.axis = &#34;ITERATIONS&#34;
            E[0] = it

            nc.createDimension(&#34;y&#34;, len(self.y))
            E = nc.createVariable(&#34;y&#34;, dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;y&#34;
            E.axis = &#34;Y&#34;
            E[:] = self.y.numpy()

            nc.createDimension(&#34;x&#34;, len(self.x))
            E = nc.createVariable(&#34;x&#34;, dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;x&#34;
            E.axis = &#34;X&#34;
            E[:] = self.x.numpy()

            for var in self.config.opti_vars_to_save:

                E = nc.createVariable(
                    var, dtype(&#34;float32&#34;).char, (&#34;iterations&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                # E.long_name = self.var_info[var][0]
                # E.units = self.var_info[var][1]
                E[0, :, :] = vars(self)[var].numpy()

            nc.close()

        else:

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;optimize.nc&#34;),
                &#34;a&#34;,
                format=&#34;NETCDF4&#34;,
            )

            d = nc.variables[&#34;iterations&#34;][:].shape[0]

            nc.variables[&#34;iterations&#34;][d] = it

            for var in self.config.opti_vars_to_save:
                nc.variables[var][d, :, :] = vars(self)[var].numpy()

            nc.close()

    def output_ncdf_optimize_final(self):
        &#34;&#34;&#34;
        Write final geology after optimizing
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Write the final geology ncdf file after optimization&#34;)

        nc = Dataset(
            os.path.join(self.config.working_dir, self.config.observation_file), &#34;r&#34;
        )
        varori = [v for v in nc.variables]
        nc.close()

        varori.remove(&#34;x&#34;)
        varori.remove(&#34;y&#34;)
        if not &#34;strflowctrl&#34; in varori:
            varori.append(&#34;strflowctrl&#34;)
        if not &#34;thk&#34; in varori:
            varori.append(&#34;thk&#34;)
        if not &#34;usurf&#34; in varori:
            varori.append(&#34;usurf&#34;)
        if not &#34;icemask&#34; in varori:
            varori.append(&#34;icemask&#34;)

        self.arrhenius = tf.where(
            self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
            self.strflowctrl,
            self.config.opti_thr_strflowctrl,
        )
        self.slidingco = tf.where(
            self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
            0,
            self.strflowctrl - self.config.opti_thr_strflowctrl,
        )
        self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

        self.icemask = tf.where(
            self.thk &gt; 1.0, tf.ones_like(self.thk), tf.zeros_like(self.thk)
        )

        if os.path.isfile(os.path.join(self.config.working_dir, &#34;geology.nc&#34;)):
            filename = &#34;geology-optimized.nc&#34;
        else:
            filename = &#34;geology.nc&#34;

        nc = Dataset(
            os.path.join(self.config.working_dir, filename),
            &#34;w&#34;,
            format=&#34;NETCDF4&#34;,
        )

        nc.createDimension(&#34;y&#34;, len(self.y))
        E = nc.createVariable(&#34;y&#34;, dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
        E.units = &#34;m&#34;
        E.long_name = &#34;y&#34;
        E.axis = &#34;Y&#34;
        E[:] = self.y.numpy()

        nc.createDimension(&#34;x&#34;, len(self.x))
        E = nc.createVariable(&#34;x&#34;, dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
        E.units = &#34;m&#34;
        E.long_name = &#34;x&#34;
        E.axis = &#34;X&#34;
        E[:] = self.x.numpy()

        for var in varori:

            if hasattr(self, var):
                E = nc.createVariable(var, dtype(&#34;float32&#34;).char, (&#34;y&#34;, &#34;x&#34;))
                #                E.long_name = self.var_info[var][0]
                #                E.units     = self.var_info[var][1]
                E[:, :] = vars(self)[var].numpy()

        nc.close()

    def plot_cost_functions(self, costs, plot_live):

        costs = np.stack(costs)

        for i in range(costs.shape[1]):
            costs[:, i] -= np.min(costs[:, i])
            costs[:, i] /= np.max(costs[:, i])

        fig = plt.figure(figsize=(10, 10))
        plt.plot(costs[:, 0], &#34;-k&#34;, label=&#34;COST U&#34;)
        plt.plot(costs[:, 1], &#34;-r&#34;, label=&#34;COST H&#34;)
        plt.plot(costs[:, 2], &#34;-b&#34;, label=&#34;COST D&#34;)
        plt.plot(costs[:, 3], &#34;-g&#34;, label=&#34;COST S&#34;)
        plt.plot(costs[:, 4], &#34;--c&#34;, label=&#34;REGU H&#34;)
        plt.plot(costs[:, 5], &#34;--m&#34;, label=&#34;REGU A&#34;)
        plt.ylim(0, 1)
        plt.legend()

        if plot_live:
            plt.show()
        else:
            plt.savefig(
                os.path.join(self.config.working_dir, &#34;convergence.png&#34;), pad_inches=0
            )
            plt.close(&#34;all&#34;)

    def update_plot_inversion(self, i, plot_live):
        &#34;&#34;&#34;
        Plot thickness, velocity, mand slidingco
        &#34;&#34;&#34;

        if self.config.plot_result:

            if hasattr(self, &#34;uvelsurfobs&#34;):
                velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs).numpy()
            else:
                velsurfobs_mag = np.zeros_like(self.thk.numpy())

            if hasattr(self, &#34;usurfobs&#34;):
                usurfobs = self.usurfobs
            else:
                usurfobs = np.zeros_like(self.thk.numpy())

            ########################################################

            fig = plt.figure(figsize=(18, 13))

            #########################################################

            ax = fig.add_subplot(2, 3, 1)
            extent = [self.x[0], self.x[-1], self.y[0], self.y[-1]]
            im1 = ax.imshow(self.thk, origin=&#34;lower&#34;, extent=extent, vmin=0, vmax=800)
            plt.colorbar(im1)

            if hasattr(self, &#34;profile&#34;):
                fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))
                for j, p in enumerate(self.profile):
                    if j &gt; 0:
                        meanfitprofile = np.mean(
                            fthk(p[:, 1], p[:, 2], grid=False) - p[:, 3]
                        )
                        ax.scatter(p[:, 1], p[:, 2], c=&#34;k&#34;, s=1)
                        ax.text(
                            np.mean(p[:, 1]),
                            np.mean(p[:, 2]),
                            str(int(meanfitprofile)),
                            fontsize=15,
                        )

            ax.set_title(
                &#34;THK, RMS : &#34;
                + str(int(self.rmsthk[-1]))
                + &#34;, STD : &#34;
                + str(int(self.stdthk[-1])),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            #########################################################

            ax = fig.add_subplot(2, 3, 2)
            velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf).numpy()
            im1 = ax.imshow(
                velsurf_mag, origin=&#34;lower&#34;, vmin=0, vmax=np.nanmax(velsurfobs_mag)
            )
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(
                &#34;MOD VEL, RMS : &#34;
                + str(int(self.rmsvel[-1]))
                + &#34;, STD : &#34;
                + str(int(self.stdvel[-1])),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            ########################################################

            ax = fig.add_subplot(2, 3, 3)
            im1 = ax.imshow(self.divflux, origin=&#34;lower&#34;, vmin=-15, vmax=5)
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(
                &#34;MOD DIV, RMS : %5.1f , STD : %5.1f&#34;
                % (self.rmsdiv[-1], self.stddiv[-1]),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            #########################################################

            ax = fig.add_subplot(2, 3, 4)
            im1 = ax.imshow(self.usurf - usurfobs, origin=&#34;lower&#34;, vmin=-10, vmax=10)
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(
                &#34;DELTA USURF, RMS : %5.1f , STD : %5.1f&#34;
                % (self.rmsusurf[-1], self.stdusurf[-1]),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            ########################################################

            ax = fig.add_subplot(2, 3, 5)
            im1 = ax.imshow(
                velsurfobs_mag, origin=&#34;lower&#34;, vmin=0, vmax=np.nanmax(velsurfobs_mag)
            )
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(&#34;OBS VEL (TARGET)&#34;, size=15)
            ax.axis(&#34;off&#34;)

            #######################################################

            ax = fig.add_subplot(2, 3, 6)
            im1 = ax.imshow(self.strflowctrl, origin=&#34;lower&#34;, vmin=50, vmax=110)
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(&#34;strflowctrl&#34;, size=15)
            ax.axis(&#34;off&#34;)

            #########################################################

            plt.tight_layout()

            if plot_live:
                plt.show()
            else:
                plt.savefig(
                    os.path.join(
                        self.config.working_dir, &#34;resu-opti-&#34; + str(i).zfill(4) + &#34;.png&#34;
                    ),
                    pad_inches=0,
                )
                plt.close(&#34;all&#34;)

    def plot_opti_diff(self, file, vari, plot_live=True):
        &#34;&#34;&#34;
        Plot thickness, velocity, mand slidingco
        &#34;&#34;&#34;

        from matplotlib import cm
        from mpl_toolkits.axes_grid1 import make_axes_locatable
        import matplotlib.pyplot as plt
        import xarray as xr

        data = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[vari]

        minvar = np.min(data[-1])
        minvardiff = minvar / 5
        maxvar = np.max(data[-1])
        maxvardiff = maxvar / 5

        if vari == &#34;divflux&#34;:
            maxvar = 10
            maxvardiff = 10
            minvar = -10
            minvardiff = -10

        if vari == &#34;thk&#34;:
            maxvardiff = maxvar / 5
            minvardiff = -maxvar / 5

        if vari == &#34;usurf&#34;:
            maxvardiff = 10
            minvardiff = -10

        extent = [self.x[0], self.x[-1], self.y[0], self.y[-1]]

        dicc = {}
        dicc[&#34;thk&#34;] = &#34;thk&#34;
        dicc[&#34;velsurf_mag&#34;] = &#34;vel&#34;
        dicc[&#34;usurf&#34;] = &#34;usurf&#34;
        dicc[&#34;divflux&#34;] = &#34;div&#34;

        ########################################################

        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 6), dpi=200)

        if vari in [&#34;velsurf_mag&#34;]:  # ,&#39;thk&#39;
            rms = str(int(vars(self)[&#34;rms&#34; + dicc[vari]][0]))
            std = str(int(vars(self)[&#34;std&#34; + dicc[vari]][0]))
            comp = &#34; (RMS: &#34; + rms + &#34;, STD: &#34; + std + &#34;)&#34;
        else:
            comp = &#34;&#34;

        ax1.set_title(&#34;Initial &#34; + vari + comp)
        im1 = ax1.imshow(
            np.where(self.thk &gt; 1, data[0], np.nan),
            origin=&#34;lower&#34;,
            extent=extent,
            vmin=minvar,
            vmax=maxvar,
            cmap=cm.get_cmap(&#34;viridis&#34;, 8),
        )
        divider = make_axes_locatable(ax1)
        cax1 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
        cbar1 = plt.colorbar(im1, format=&#34;%.0f&#34;, cax=cax1, orientation=&#34;vertical&#34;)
        ax1.axis(&#34;off&#34;)

        if vari in [&#34;velsurf_mag&#34;, &#34;thk&#34;]:
            rms = str(int(vars(self)[&#34;rms&#34; + dicc[vari]][-1]))
            std = str(int(vars(self)[&#34;std&#34; + dicc[vari]][-1]))
            comp = &#34; (RMS: &#34; + rms + &#34;, STD: &#34; + std + &#34;)&#34;
        else:
            comp = &#34;&#34;

        ax2.set_title(&#34;Optimized &#34; + vari + comp)
        im2 = ax2.imshow(
            np.where(self.thk &gt; 1, data[-1], np.nan),
            origin=&#34;lower&#34;,
            extent=extent,
            vmin=minvar,
            vmax=maxvar,
            cmap=cm.get_cmap(&#34;viridis&#34;, 8),
        )
        divider = make_axes_locatable(ax2)
        cax2 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
        cbar2 = plt.colorbar(im2, format=&#34;%.0f&#34;, cax=cax2, orientation=&#34;vertical&#34;)
        ax2.axis(&#34;off&#34;)

        if vari == &#34;velsurf_mag&#34;:
            velsurfobs_mag = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[&#34;velsurfobs_mag&#34;]
            tod = np.where(self.thk &gt; 1, velsurfobs_mag[0], np.nan)
            ax3.set_title(&#34;Target&#34;)
            im3 = ax3.imshow(
                tod,
                origin=&#34;lower&#34;,
                extent=extent,
                vmin=minvar,
                vmax=maxvar,
                cmap=cm.get_cmap(&#34;viridis&#34;, 8),
            )
            divider = make_axes_locatable(ax3)
            cax3 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
            cbar3 = plt.colorbar(im3, format=&#34;%.0f&#34;, cax=cax3, orientation=&#34;vertical&#34;)
            ax3.axis(&#34;off&#34;)
        else:
            tod = np.where(self.thk &gt; 1, data[-1] - data[0], np.nan)
            ax3.set_title(&#34;Optimized - Initial&#34;)
            im3 = ax3.imshow(
                tod,
                origin=&#34;lower&#34;,
                vmin=minvardiff,
                vmax=maxvardiff,
                cmap=cm.get_cmap(&#34;RdBu&#34;, 10),
            )
            divider = make_axes_locatable(ax3)
            cax3 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
            cbar3 = plt.colorbar(im3, format=&#34;%.0f&#34;, cax=cax3, orientation=&#34;vertical&#34;)
            ax3.axis(&#34;off&#34;)

        #########################################################

        plt.tight_layout()

        if plot_live:
            plt.show()
        else:
            plt.savefig(
                os.path.join(self.config.working_dir, &#34;resu-opti-&#34; + vari + &#34;-.png&#34;),
                pad_inches=0,
            )
            plt.close(&#34;all&#34;)

    def update_plot_profiles(self, i, plot_live):

        from scipy.interpolate import RectBivariateSpline

        fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))

        N = len(self.profile)
        N1 = int(np.sqrt(N)) + 1
        N2 = N1
        fig, axs = plt.subplots(N1, N2, figsize=(N1 * 10, N2 * 5))
        #            fig, axs = plt.subplots(N,1,figsize=(10,N*4))
        for j, p in enumerate(self.profile):
            if j &gt; 0:
                jj = j // N1
                ii = j % N1
                axs[ii, jj].set_title(&#34; PROFILE N° : &#34; + str(j))
                axs[ii, jj].plot(p[:, 0], p[:, 3], &#34;-k&#34;)
                axs[ii, jj].plot(p[:, 0], fthk(p[:, 1], p[:, 2], grid=False), &#34;-b&#34;)
                axs[ii, jj].axis(&#34;equal&#34;)
        plt.tight_layout()

        if plot_live:
            plt.show()
        else:
            plt.savefig(
                os.path.join(
                    self.config.working_dir, &#34;S1-pro-&#34; + str(i).zfill(4) + &#34;.png&#34;
                ),
                pad_inches=0,
            )
            plt.close(&#34;all&#34;)

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              PLOT
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_plot(self):

        self.parser.add_argument(
            &#34;--varplot&#34;,
            type=str,
            default=&#34;velbar_mag&#34;,
            help=&#34;variable to plot&#34;,
        )
        self.parser.add_argument(
            &#34;--varplot_max&#34;,
            type=float,
            default=500,
            help=&#34;maximum value of the varplot variable used to adjust the scaling of the colorbar&#34;,
        )

    def update_plot(self, force=False):
        &#34;&#34;&#34;
        Plot thickness, velocity, mass balance
        &#34;&#34;&#34;

        if force | (self.saveresult &amp; self.config.plot_result):

            firstime = False
            if not hasattr(self, &#34;already_called_update_plot&#34;):
                self.already_called_update_plot = True
                self.tcomp[&#34;Outputs plot&#34;] = []
                firstime = True

            self.tcomp[&#34;Outputs plot&#34;].append(time.time())

            if self.config.varplot == &#34;velbar_mag&#34;:
                self.velbar_mag = self.getmag(self.ubar, self.vbar)

            if firstime:

                self.fig = plt.figure(dpi=200)
                self.ax = self.fig.add_subplot(1, 1, 1)
                self.ax.axis(&#34;off&#34;)
                im = self.ax.imshow(
                    vars(self)[self.config.varplot],
                    origin=&#34;lower&#34;,
                    cmap=&#34;viridis&#34;,
                    vmin=0,
                    vmax=self.config.varplot_max,
                )
                self.ax.set_title(&#34;YEAR : &#34; + str(self.t.numpy()), size=15)
                self.cbar = plt.colorbar(im)

            else:
                im = self.ax.imshow(
                    vars(self)[self.config.varplot],
                    origin=&#34;lower&#34;,
                    cmap=&#34;viridis&#34;,
                    vmin=0,
                    vmax=self.config.varplot_max,
                )
                self.ax.set_title(&#34;YEAR : &#34; + str(self.t.numpy()), size=15)

            if self.config.plot_live:
                clear_output(wait=True)
                display(self.fig)

            else:
                plt.savefig(
                    os.path.join(
                        self.config.working_dir,
                        self.config.varplot
                        + &#34;-&#34;
                        + str(self.t.numpy()).zfill(4)
                        + &#34;.png&#34;,
                    ),
                    bbox_inches=&#34;tight&#34;,
                    pad_inches=0.2,
                )

            self.tcomp[&#34;Outputs plot&#34;][-1] -= time.time()
            self.tcomp[&#34;Outputs plot&#34;][-1] *= -1

    def plot_computational_pie(self):
        &#34;&#34;&#34;
        Plot to the computational time of each model components in a pie
        &#34;&#34;&#34;

        def make_autopct(values):
            def my_autopct(pct):
                total = sum(values)
                val = int(round(pct * total / 100.0))
                return &#34;{:.0f}&#34;.format(val)

            return my_autopct

        total = []
        name = []

        for i, key in enumerate(self.tcomp.keys()):
            if not key == &#34;All&#34;:
                total.append(np.sum(self.tcomp[key][1:]))
                name.append(key)

        sumallindiv = np.sum(total)

        fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(aspect=&#34;equal&#34;), dpi=200)
        wedges, texts, autotexts = ax.pie(
            total, autopct=make_autopct(total), textprops=dict(color=&#34;w&#34;)
        )
        ax.legend(
            wedges,
            name,
            title=&#34;Model components&#34;,
            loc=&#34;center left&#34;,
            bbox_to_anchor=(1, 0, 0.5, 1),
        )
        plt.setp(autotexts, size=8, weight=&#34;bold&#34;)
        #    ax.set_title(&#34;Matplotlib bakery: A pie&#34;)
        plt.tight_layout()
        plt.savefig(
            os.path.join(self.config.working_dir, &#34;PIE-COMPUTATIONAL.png&#34;), pad_inches=0
        )
        plt.close(&#34;all&#34;)

    def animate_result(self, file, vari, save=False):

        from IPython.display import HTML, display
        import xarray as xr
        from matplotlib import pyplot as plt, animation

        data = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[vari]

        minvar = np.min(data)
        maxvar = np.max(data)

        if vari == &#34;divflux&#34;:
            maxvar = 10
            minvar = -10

        thk = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[&#34;thk&#34;]

        data = xr.where(thk &gt; 1, data, np.nan)

        ratio = self.y.shape[0] / self.x.shape[0]

        fig, ax = plt.subplots(figsize=(6, 6 * ratio), dpi=200)

        # Plot the initial frame.
        cax = data[0, :, :].plot(
            add_colorbar=True, cmap=plt.cm.get_cmap(&#34;jet&#34;, 20), vmin=minvar, vmax=maxvar
        )
        ax.axis(&#34;off&#34;)
        ax.axis(&#34;equal&#34;)

        # dont&#39; show the original frame
        plt.close()

        def animate(i):
            cax.set_array(data[i, :, :].values.flatten())
            if &#34;iterations&#34; in data.coords.variables:
                ax.set_title(&#34;It = &#34; + str(data.coords[&#34;iterations&#34;].values[i])[:13])
            else:
                ax.set_title(&#34;Time = &#34; + str(data.coords[&#34;time&#34;].values[i])[:13])

        ani = animation.FuncAnimation(
            fig, animate, frames=data.shape[0], interval=100
        )  # interval in ms between frames

        HTML(ani.to_html5_video())

        # optionally the animation can be saved in avi
        if save:
            ani.save(file.split(&#34;.&#34;)[0] + &#34;-&#34; + vari + &#34;.mp4&#34;)

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              PRINT INFO
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def print_info(self):
        &#34;&#34;&#34;
        This serves to print key info on the fly during computation
        &#34;&#34;&#34;
        if self.saveresult:
            print(
                &#34;IGM %s : Iterations = %6.0f  |  Time = %8.0f  |  DT = %7.2f  |  Ice Volume (km^3) = %10.2f &#34;
                % (
                    datetime.datetime.now().strftime(&#34;%H:%M:%S&#34;),
                    self.it,
                    self.t,
                    self.dt_target,
                    np.sum(self.thk) * (self.dx ** 2) / 10 ** 9,
                )
            )

    def print_comp_info_live(self):
        &#34;&#34;&#34;
        This serves to print computational info on the fly during computation
        &#34;&#34;&#34;
        if self.saveresult:
            for key in self.tcomp.keys():
                CELA = (
                    key,
                    np.mean(self.tcomp[key][2:]),
                    np.sum(self.tcomp[key][2:]),
                    len(self.tcomp[key][2:]),
                )
                print(
                    &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it  : %8.0f&#34;
                    % CELA
                )

    def print_all_comp_info(self):
        &#34;&#34;&#34;
        This serves to print computational info report
        &#34;&#34;&#34;

        print(&#34;Computational statistics report:&#34;)
        with open(
            os.path.join(self.config.working_dir, &#34;computational-statistics.txt&#34;), &#34;w&#34;
        ) as f:
            for key in self.tcomp.keys():
                CELA = (
                    key,
                    np.mean(self.tcomp[key][2:]),
                    np.sum(self.tcomp[key][2:]),
                    len(self.tcomp[key][2:]),
                )
                print(
                    &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it : %8.0f&#34;
                    % CELA,
                    file=f,
                )
                print(
                    &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it  : %8.0f&#34;
                    % CELA
                )

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              RUN
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def run(self):

        self.initialize()

        with tf.device(self.device_name):

            self.load_ncdf_data(self.config.geology_file)

            self.initialize_fields()

            if len(self.config.restartingfile) &gt; 0:
                self.restart(-1)

            self.initialize_iceflow()

            self.update_climate()

            self.update_smb()

            if self.config.optimize:
                self.optimize()

            self.update_iceflow()

            self.update_ncdf_ex()

            self.update_ncdf_ts()

            if self.config.vel3d_active:
                self.init_3dvel()

            self.print_info()

            while self.t.numpy() &lt; self.config.tend:

                self.tcomp[&#34;All&#34;].append(time.time())

                if self.config.vel3d_active:
                    self.update_3dvel()

                self.update_climate()

                self.update_smb()

                self.update_iceflow()

                self.update_t_dt()

                self.update_thk()

                if self.config.update_topg:
                    self.update_topg()

                self.update_ncdf_ex()

                self.update_ncdf_ts()

                self.update_plot()

                self.print_info()

                self.tcomp[&#34;All&#34;][-1] -= time.time()
                self.tcomp[&#34;All&#34;][-1] *= -1

        self.print_all_comp_info()


####################################################################################
####################################################################################
####################################################################################
#   END   END   END   END   END   END   END   END   END   END   END   END   END
####################################################################################
####################################################################################
####################################################################################</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="igm.str2bool"><code class="name flex">
<span>def <span class="ident">str2bool</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str2bool(v):
    return v.lower() in (&#34;true&#34;, &#34;1&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="igm.igm"><code class="flex name class">
<span>class <span class="ident">igm</span></span>
</code></dt>
<dd>
<div class="desc"><p>function build class IGM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class igm:

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               INITIALIZATION
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def __init__(self):
        &#34;&#34;&#34;
        function build class IGM
        &#34;&#34;&#34;
        self.parser = argparse.ArgumentParser(description=&#34;IGM&#34;)
        self.read_config_param()
        self.config = self.parser.parse_args()
        
        config = tf.compat.v1.ConfigProto()
        config.gpu_options.allow_growth = True
        session = tf.compat.v1.Session(config=config)

    def read_config_param(self):

        self.parser.add_argument(
            &#34;--working_dir&#34;, type=str, default=&#34;&#34;, help=&#34;Working directory&#34;
        )
        self.parser.add_argument(
            &#34;--geology_file&#34;, type=str, default=&#34;geology.nc&#34;, help=&#34;Geology input file&#34;
        )
        self.parser.add_argument(
            &#34;--resample&#34;, type=int, default=1, help=&#34;Upsample the data from geology.nc&#34;
        )
        self.parser.add_argument(
            &#34;--tstart&#34;, type=float, default=0.0, help=&#34;Starting time&#34;
        )
        self.parser.add_argument(&#34;--tend&#34;, type=float, default=150.0, help=&#34;End time&#34;)
        self.parser.add_argument(
            &#34;--restartingfile&#34;,
            type=str,
            default=&#34;&#34;,
            help=&#34;Provide restarting file if no empty string&#34;,
        )
        self.parser.add_argument(
            &#34;--verbosity&#34;,
            type=int,
            default=0,
            help=&#34;Verbosity level of IGM (default: 0 = no verbosity)&#34;,
        )
        self.parser.add_argument(
            &#34;--tsave&#34;, type=float, default=10, help=&#34;Save result each X years (10)&#34;
        )
        self.parser.add_argument(
            &#34;--plot_result&#34;,
            type=str2bool,
            default=False,
            help=&#34;Plot results in png&#34;,
        )
        self.parser.add_argument(
            &#34;--plot_live&#34;,
            type=str2bool,
            default=False,
            help=&#34;Display plots live the results during computation&#34;,
        )
        self.parser.add_argument(
            &#34;--usegpu&#34;,
            type=str2bool,
            default=True,
            help=&#34;Use the GPU for ice flow model (True)&#34;,
        )
        self.parser.add_argument(
            &#34;--stop&#34;,
            type=str2bool,
            default=False,
            help=&#34;experimental, just o get fair comp time, to be removed ....&#34;,
        )
        self.parser.add_argument(
            &#34;--init_strflowctrl&#34;,
            type=float,
            default=78,
            help=&#34;Initial strflowctrl&#34;,
        )

        self.parser.add_argument(
            &#34;--init_slidingco&#34;,
            type=float,
            default=0,
            help=&#34;Initial slidingco&#34;,
        )
        self.parser.add_argument(
            &#34;--init_arrhenius&#34;,
            type=float,
            default=78,
            help=&#34;Initial arrhenius&#34;,
        )

        self.parser.add_argument(
            &#34;--optimize&#34;,
            type=str2bool,
            default=False,
            help=&#34;Optimize prior forward modelling  (not available yet)&#34;,
        )
        self.parser.add_argument(
            &#34;--update_topg&#34;,
            type=str2bool,
            default=False,
            help=&#34;Update bedrock (not available yet)&#34;,
        )

        for p in dir(self):
            if &#34;read_config_param_&#34; in p:
                getattr(self, p)()

    ##################################################

    def initialize(self):
        &#34;&#34;&#34;
        function initialize the strict minimum for IGM class, and record parameters
        &#34;&#34;&#34;

        print(
            &#34;+++++++++++++++++++ START IGM ++++++++++++++++++++++++++++++++++++++++++&#34;
        )

        self.t = tf.Variable(float(self.config.tstart))
        self.it = 0
        self.dt = float(self.config.dtmax)
        self.dt_target = float(self.config.dtmax)

        self.saveresult = True

        self.tcomp = {}
        self.tcomp[&#34;All&#34;] = []

        self.device_name = &#34;/GPU:0&#34; * self.config.usegpu + &#34;/CPU:0&#34; * (
            not self.config.usegpu
        )

        os.environ[&#34;CUDA_DEVICE_ORDER&#34;] = &#34;PCI_BUS_ID&#34;  # so the IDs match nvidia-smi

        if self.config.usegpu:
            os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;0&#34;  # &#34;0, 1&#34; for multiple
        else:
            os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;-1&#34;

        # This is used to limite the number of used core to 1 (or user-defined)
        #        tf.config.threading.set_inter_op_parallelism_threads(1)  # another method
        #        tf.config.threading.set_intra_op_parallelism_threads(1)  # another method

        with open(
            os.path.join(self.config.working_dir, &#34;igm-run-parameters.txt&#34;), &#34;w&#34;
        ) as f:
            print(&#34;PARAMETERS ARE ...... &#34;)
            for ck in self.config.__dict__:
                print(&#34;%30s : %s&#34; % (ck, self.config.__dict__[ck]))
                print(&#34;%30s : %s&#34; % (ck, self.config.__dict__[ck]), file=f)

    def load_ncdf_data(self, filename):
        &#34;&#34;&#34;
        Load the geological input files from netcdf file
        &#34;&#34;&#34;
        if self.config.verbosity == 1:
            print(&#34;LOAD NCDF file&#34;)

        nc = Dataset(os.path.join(self.config.working_dir, filename), &#34;r&#34;)

        x = np.squeeze(nc.variables[&#34;x&#34;]).astype(&#34;float32&#34;)
        y = np.squeeze(nc.variables[&#34;y&#34;]).astype(&#34;float32&#34;)
        assert x[1] - x[0] == y[1] - y[0]

        for var in nc.variables:
            if not var in [&#34;x&#34;, &#34;y&#34;]:
                vars()[var] = np.squeeze(nc.variables[var]).astype(&#34;float32&#34;)
                vars()[var] = np.where(vars()[var] &gt; 10 ** 35, np.nan, vars()[var])

        if self.config.resample &gt; 1:
            xx = x[:: self.config.resample]
            yy = y[:: self.config.resample]
            for var in nc.variables:
                if not var in [&#34;x&#34;, &#34;y&#34;]:
                    vars()[var] = RectBivariateSpline(y, x, vars()[var])(yy, xx)
            x = xx
            y = yy

        for var in nc.variables:
            if var in [&#34;x&#34;, &#34;y&#34;]:
                vars(self)[var] = tf.constant(vars()[var].astype(&#34;float32&#34;))
            else:
                vars(self)[var] = tf.Variable(vars()[var].astype(&#34;float32&#34;))

        nc.close()

    def initialize_fields(self):
        &#34;&#34;&#34;
        Initialize fields, complete the loading of geology
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Initialize fields&#34;)

        # at this point, we should have defined at least x, y, usurf
        assert hasattr(self, &#34;x&#34;)
        assert hasattr(self, &#34;y&#34;)

        if hasattr(self, &#34;usurfobs&#34;):
            self.usurf = tf.Variable(self.usurfobs)

        assert hasattr(self, &#34;usurf&#34;)

        if not hasattr(self, &#34;thk&#34;):
            self.thk = tf.Variable(tf.zeros((self.y.shape[0], self.x.shape[0])))

        self.topg = tf.Variable(self.usurf - self.thk)

        if not hasattr(self, &#34;icemask&#34;):
            if hasattr(self, &#34;mask&#34;):
                self.icemask = tf.Variable(self.mask)
            else:
                self.icemask = tf.Variable(tf.ones_like(self.thk))

        if not hasattr(self, &#34;uvelsurf&#34;):
            self.uvelsurf = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;vvelsurf&#34;):
            self.vvelsurf = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;wvelbase&#34;):
            self.wvelbase = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;wvelsurf&#34;):
            self.wvelsurf = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;smb&#34;):
            if hasattr(self, &#34;mb&#34;):
                self.smb = tf.Variable(self.mb)
            else:
                self.smb = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;dhdt&#34;):
            self.dhdt = tf.Variable(tf.zeros_like(self.thk))

        if not hasattr(self, &#34;strflowctrl&#34;):
            self.strflowctrl = tf.Variable(
                tf.ones_like(self.thk) * self.config.init_strflowctrl
            )

        if not hasattr(self, &#34;arrhenius&#34;):
            self.arrhenius = tf.Variable(
                tf.ones_like(self.thk) * self.config.init_arrhenius
            )

        if not hasattr(self, &#34;slidingco&#34;):
            self.slidingco = tf.Variable(
                tf.ones_like(self.thk) * self.config.init_slidingco
            )
            
        if self.config.erosion_include:
            self.dtopgdt = tf.Variable( tf.zeros_like(self.thk) )

        self.X, self.Y = tf.meshgrid(self.x, self.y)

        self.dx = self.x[1] - self.x[0]

        self.slopsurfx, self.slopsurfy = self.compute_gradient_tf(
            self.usurf, self.dx, self.dx
        )

        self.ubar = tf.Variable(tf.zeros_like(self.thk))
        self.vbar = tf.Variable(tf.zeros_like(self.thk))
        self.uvelbase = tf.Variable(tf.zeros_like(self.thk))
        self.vvelbase = tf.Variable(tf.zeros_like(self.thk))
        self.divflux = tf.Variable(tf.zeros_like(self.thk))

        self.var_info = {}
        self.var_info[&#34;topg&#34;] = [&#34;Basal Topography&#34;, &#34;m&#34;]
        self.var_info[&#34;usurf&#34;] = [&#34;Surface Topography&#34;, &#34;m&#34;]
        self.var_info[&#34;thk&#34;] = [&#34;Ice Thickness&#34;, &#34;m&#34;]
        self.var_info[&#34;icemask&#34;] = [&#34;Ice mask&#34;, &#34;NO UNIT&#34;]
        self.var_info[&#34;smb&#34;] = [&#34;Surface Mass Balance&#34;, &#34;m/y&#34;]
        self.var_info[&#34;ubar&#34;] = [&#34;x depth-average velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vbar&#34;] = [&#34;y depth-average velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;velbar_mag&#34;] = [&#34;Depth-average velocity magnitude of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;uvelsurf&#34;] = [&#34;x surface velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vvelsurf&#34;] = [&#34;y surface velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;velsurf_mag&#34;] = [&#34;Surface velocity magnitude of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;uvelbase&#34;] = [&#34;x basal velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vvelbase&#34;] = [&#34;y basal velocity of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;velbase_mag&#34;] = [&#34;Basal velocity magnitude of ice&#34;, &#34;m/y&#34;]
        self.var_info[&#34;divflux&#34;] = [&#34;Divergence of the ice flux&#34;, &#34;m/y&#34;]
        self.var_info[&#34;strflowctrl&#34;] = [
            &#34;arrhenius + 10 * slidingco&#34;,
            &#34;MPa$^{-3}$ a$^{-1}$&#34;,
        ]
        self.var_info[&#34;dtopgdt&#34;] = [&#34;Erosion rate&#34;,&#34;m/y&#34;]
        self.var_info[&#34;arrhenius&#34;] = [&#34;Arrhenius factor&#34;, &#34;MPa$^{-3}$ a$^{-1}$&#34;]
        self.var_info[&#34;slidingco&#34;] = [&#34;Sliding Coefficient&#34;, &#34;km MPa$^{-3}$ a$^{-1}$&#34;]
        self.var_info[&#34;meantemp&#34;] = [&#34;Mean anual surface temperatures&#34;, &#34;°C&#34;]
        self.var_info[&#34;meanprec&#34;] = [&#34;Mean anual precipitation&#34;, &#34;m/y&#34;]
        self.var_info[&#34;vol&#34;] = [&#34;Ice volume&#34;, &#34;km^3&#34;]
        self.var_info[&#34;area&#34;] = [&#34;Glaciated area&#34;, &#34;km^2&#34;]

        self.var_info[&#34;velsurfobs_mag&#34;] = [
            &#34;Observed Surface velocity magnitude of ice&#34;,
            &#34;m/y&#34;,
        ]

    def restart(self):
        &#34;&#34;&#34;
        Permit to restart a simulation from a ncdf file y taking the last iterate
        &#34;&#34;&#34;
        if self.config.verbosity == 1:
            print(&#34;READ RESTARTING FILE, OVERIDE FIELDS WHEN GIVEN&#34;)

        nc = Dataset(self.config.restartingfile, &#34;r&#34;)

        Rx = tf.constant(np.squeeze(nc.variables[&#34;x&#34;]).astype(&#34;float32&#34;))
        Ry = tf.constant(np.squeeze(nc.variables[&#34;y&#34;]).astype(&#34;float32&#34;))

        assert Rx.shape == self.x.shape
        assert Ry.shape == self.y.shape

        for var in nc.variables:
            if not var in [&#34;x&#34;, &#34;y&#34;]:
                vars(self)[var].assign(
                    np.squeeze(nc.variables[var][-1]).astype(&#34;float32&#34;)
                )

        nc.close()

    def stop(self):
        &#34;&#34;&#34;
        this is a dummy stop that serves to syncrohnize CPU and GPU for reliable computational times
        &#34;&#34;&#34;
        ubar_np = self.ubar.numpy()
        thk_np = self.thk.numpy()
        mb_np = self.smb.numpy()

    def whatsize(self, n):
        s = float(n.size * n.itemsize) / (10 ** 6)
        print(&#34;%1.0f Mbytes&#34; % s)

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               I/O NCDF
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_output_ncdf(self):

        self.parser.add_argument(
            &#34;--vars_to_save&#34;,
            type=list,
            default=[
                &#34;topg&#34;,
                &#34;usurf&#34;,
                &#34;thk&#34;,
                &#34;smb&#34;,
                &#34;velbar_mag&#34;,
                &#34;velsurf_mag&#34;,
            ],
            help=&#34;List of variables to be recorded in the ncdef file&#34;,
        )

    def update_ncdf_ex(self, force=False):
        &#34;&#34;&#34;
        Initialize  and write the ncdf output file
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_ncdf_ex&#34;):
            self.tcomp[&#34;Outputs ncdf&#34;] = []
            self.already_called_update_ncdf_ex = True

        if force | self.saveresult:

            self.tcomp[&#34;Outputs ncdf&#34;].append(time.time())

            if &#34;velbar_mag&#34; in self.config.vars_to_save:
                self.velbar_mag = self.getmag(self.ubar, self.vbar)

            if &#34;velsurf_mag&#34; in self.config.vars_to_save:
                self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

            if &#34;velbase_mag&#34; in self.config.vars_to_save:
                self.velbase_mag = self.getmag(self.uvelbase, self.vvelbase)

            if &#34;meanprec&#34; in self.config.vars_to_save:
                self.meanprec = tf.math.reduce_mean(self.precipitation, axis=0)

            if &#34;meantemp&#34; in self.config.vars_to_save:
                self.meantemp = tf.math.reduce_mean(self.air_temp, axis=0)

            if self.it == 0:

                if self.config.verbosity == 1:
                    print(&#34;Initialize NCDF output Files&#34;)

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex.nc&#34;),
                    &#34;w&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                nc.createDimension(&#34;time&#34;, None)
                E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
                E.units = &#34;yr&#34;
                E.long_name = &#34;time&#34;
                E.axis = &#34;T&#34;
                E[0] = self.t.numpy()

                nc.createDimension(&#34;y&#34;, len(self.y))
                E = nc.createVariable(&#34;y&#34;, np.dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;y&#34;
                E.axis = &#34;Y&#34;
                E[:] = self.y.numpy()

                nc.createDimension(&#34;x&#34;, len(self.x))
                E = nc.createVariable(&#34;x&#34;, np.dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;x&#34;
                E.axis = &#34;X&#34;
                E[:] = self.x.numpy()

                for var in self.config.vars_to_save:

                    E = nc.createVariable(
                        var, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
                    )
                    E.long_name = self.var_info[var][0]
                    E.units = self.var_info[var][1]
                    E[0, :, :] = vars(self)[var].numpy()

                nc.close()

            else:

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex.nc&#34;),
                    &#34;a&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                d = nc.variables[&#34;time&#34;][:].shape[0]
                nc.variables[&#34;time&#34;][d] = self.t.numpy()

                for var in self.config.vars_to_save:
                    nc.variables[var][d, :, :] = vars(self)[var].numpy()

                nc.close()

            self.tcomp[&#34;Outputs ncdf&#34;][-1] -= time.time()
            self.tcomp[&#34;Outputs ncdf&#34;][-1] *= -1

    def update_ncdf_ts(self, force=False):
        &#34;&#34;&#34;
        Initialize  and write the ncdf time serie file
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_ncdf_ts&#34;):
            self.already_called_update_ncdf_ts = True

        if force | self.saveresult:

            vol = np.sum(self.thk) * (self.dx ** 2) / 10 ** 9
            area = np.sum(self.thk &gt; 1) * (self.dx ** 2) / 10 ** 6

            if self.it == 0:

                if self.config.verbosity == 1:
                    print(&#34;Initialize NCDF output Files&#34;)

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ts.nc&#34;),
                    &#34;w&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                nc.createDimension(&#34;time&#34;, None)
                E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
                E.units = &#34;yr&#34;
                E.long_name = &#34;time&#34;
                E.axis = &#34;T&#34;
                E[0] = self.t.numpy()

                for var in [&#34;vol&#34;, &#34;area&#34;]:
                    E = nc.createVariable(var, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;))
                    E[0] = vars()[var].numpy()
                    E.long_name = self.var_info[var][0]
                    E.units = self.var_info[var][1]
                nc.close()

            else:

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ts.nc&#34;),
                    &#34;a&#34;,
                    format=&#34;NETCDF4&#34;,
                )
                d = nc.variables[&#34;time&#34;][:].shape[0]

                nc.variables[&#34;time&#34;][d] = self.t.numpy()
                for var in [&#34;vol&#34;, &#34;area&#34;]:
                    nc.variables[var][d] = vars()[var].numpy()
                nc.close()

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               COMPUTE T AND DT
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_t_dt(self):

        # NUMERICL PARAMETER FOR TIME STEP
        self.parser.add_argument(
            &#34;--cfl&#34;, type=float, default=0.3, help=&#34;CFL number must be below 1 (0.3)&#34;
        )
        self.parser.add_argument(
            &#34;--dtmax&#34;,
            type=float,
            default=10.0,
            help=&#34;Maximum time step, used only with slow ice (10.0)&#34;,
        )

    def update_t_dt(self):
        &#34;&#34;&#34;
        compute time step to satisfy the CLF condition and hit requested saving times
        &#34;&#34;&#34;
        if self.config.verbosity == 1:
            print(&#34;Update DT from the CFL condition at time : &#34;, self.t.numpy())

        if not hasattr(self, &#34;already_called_update_t_dt&#34;):
            self.tcomp[&#34;Time step&#34;] = []
            self.already_called_update_t_dt = True

            self.tsave = np.ndarray.tolist(
                np.arange(self.config.tstart, self.config.tend, self.config.tsave)
            ) + [self.config.tend]
            self.itsave = 0

        self.tcomp[&#34;Time step&#34;].append(time.time())

        velomax = max(
            tf.math.reduce_max(tf.math.abs(self.ubar)),
            tf.math.reduce_max(tf.math.abs(self.vbar)),
        ).numpy()

        if velomax &gt; 0:
            self.dt_target = min(self.config.cfl * self.dx / velomax, self.config.dtmax)
        else:
            self.dt_target = self.config.dtmax

        self.dt = self.dt_target

        if self.tsave[self.itsave + 1] &lt;= self.t.numpy() + self.dt:
            self.dt = self.tsave[self.itsave + 1] - self.t.numpy()
            self.t.assign(self.tsave[self.itsave + 1])
            self.saveresult = True
            self.itsave += 1
        else:
            self.t.assign(self.t.numpy() + self.dt)
            self.saveresult = False

        self.it += 1

        self.tcomp[&#34;Time step&#34;][-1] -= time.time()
        self.tcomp[&#34;Time step&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               GET MAG AND GRADIENTS
    ####################################################################################
    ####################################################################################
    ####################################################################################

    @tf.function()
    def getmag(self, u, v):
        &#34;&#34;&#34;
        return the norm of a 2D vector, e.g. to compute velbase_mag
        &#34;&#34;&#34;
        return tf.norm(
            tf.concat([tf.expand_dims(u, axis=-1), tf.expand_dims(v, axis=-1)], axis=2),
            axis=2,
        )

    @tf.function()
    def compute_gradient_tf(self, s, dx, dy):
        &#34;&#34;&#34;
        compute spatial 2D gradient of a given field
        &#34;&#34;&#34;

        EX = tf.concat([s[:, 0:1], 0.5 * (s[:, :-1] + s[:, 1:]), s[:, -1:]], 1)
        diffx = (EX[:, 1:] - EX[:, :-1]) / dx

        EY = tf.concat([s[0:1, :], 0.5 * (s[:-1, :] + s[1:, :]), s[-1:, :]], 0)
        diffy = (EY[1:, :] - EY[:-1, :]) / dy

        return diffx, diffy

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               ICEFLOW
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_fields_and_bounds(self, path):
        &#34;&#34;&#34;
        get fields (input and outputs) from given file
        &#34;&#34;&#34;

        fieldbounds = {}
        fieldin = []
        fieldout = []

        fid = open(os.path.join(path, &#34;fieldin.dat&#34;), &#34;r&#34;)
        for fileline in fid:
            part = fileline.split()
            fieldin.append(part[0])
            fieldbounds[part[0]] = float(part[1])
        fid.close()

        fid = open(os.path.join(path, &#34;fieldout.dat&#34;), &#34;r&#34;)
        for fileline in fid:
            part = fileline.split()
            fieldout.append(part[0])
            fieldbounds[part[0]] = float(part[1])
        fid.close()

        return fieldin, fieldout, fieldbounds

    def read_config_param_iceflow(self):

        self.parser.add_argument(
            &#34;--iceflow_model_lib_path&#34;,
            type=str,
            default=&#34;/home/jouvetg/IGM/model-lib/f12_cfsflow&#34;,
            help=&#34;model directory&#34;,
        )
        self.parser.add_argument(
            &#34;--multiple_window_size&#34;,
            type=int,
            default=0,
            help=&#34;In case the mdel is a unet, it must force window size to be multiple of e.g. 8&#34;,
        )
        self.parser.add_argument(
            &#34;--force_max_velbar&#34;,
            type=float,
            default=0,
            help=&#34;This permits to artificially upper-bound velocities, active if &gt; 0&#34;,
        )

    def initialize_iceflow(self):
        &#34;&#34;&#34;
        set-up the iceflow emulator
        &#34;&#34;&#34;

        dirpath = os.path.join(self.config.iceflow_model_lib_path, str(int(self.dx)))

        assert os.path.isdir(dirpath)

        fieldin, fieldout, fieldbounds = self.read_fields_and_bounds(dirpath)

        self.iceflow_mapping = {}
        self.iceflow_mapping[&#34;fieldin&#34;] = fieldin
        self.iceflow_mapping[&#34;fieldout&#34;] = fieldout
        self.iceflow_fieldbounds = fieldbounds

        self.iceflow_model = tf.keras.models.load_model(
            os.path.join(dirpath, &#34;model.h5&#34;)
        )

        #        print(self.iceflow_model.summary())

        Ny = self.thk.shape[0]
        Nx = self.thk.shape[1]

        if self.config.multiple_window_size &gt; 0:
            NNy = self.config.multiple_window_size * math.ceil(
                Ny / self.config.multiple_window_size
            )
            NNx = self.config.multiple_window_size * math.ceil(
                Nx / self.config.multiple_window_size
            )
            self.PAD = [[0, NNy - Ny], [0, NNx - Nx]]
        else:
            self.PAD = [[0, 0], [0, 0]]

        self.tcomp[&#34;Ice flow&#34;] = []

    def update_iceflow(self):
        &#34;&#34;&#34;
        function update the ice flow using the neural network emulator
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Update ICEFLOW at time : &#34;, igm.t)

        self.tcomp[&#34;Ice flow&#34;].append(time.time())

        X = tf.expand_dims(
            tf.stack(
                [
                    tf.pad(vars(self)[f], self.PAD, &#34;CONSTANT&#34;)
                    / self.iceflow_fieldbounds[f]
                    for f in self.iceflow_mapping[&#34;fieldin&#34;]
                ],
                axis=-1,
            ),
            axis=0,
        )

        Y = self.iceflow_model.predict_on_batch(X)

        Ny, Nx = self.thk.shape
        for kk, f in enumerate(self.iceflow_mapping[&#34;fieldout&#34;]):
            vars(self)[f].assign(
                tf.where(self.thk &gt; 0, Y[0, :Ny, :Nx, kk], 0)
                * self.iceflow_fieldbounds[f]
            )

        if self.config.force_max_velbar &gt; 0:

            self.velbar_mag = self.getmag(self.ubar, self.vbar)

            self.ubar.assign(
                tf.where(
                    self.velbar_mag &gt;= self.config.force_max_velbar,
                    self.config.force_max_velbar * (self.ubar / self.velbar_mag),
                    self.ubar,
                )
            )
            self.vbar.assign(
                tf.where(
                    self.velbar_mag &gt;= self.config.force_max_velbar,
                    self.config.force_max_velbar * (self.vbar / self.velbar_mag),
                    self.vbar,
                )
            )

        self.tcomp[&#34;Ice flow&#34;][-1] -= time.time()
        self.tcomp[&#34;Ice flow&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              CLIMATE
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_climate(self):

        # CLIMATE PARAMETERS
        self.parser.add_argument(
            &#34;--clim_update_freq&#34;,
            type=float,
            default=1,
            help=&#34;Update the climate each X years (1)&#34;,
        )
        self.parser.add_argument(
            &#34;--type_climate&#34;,
            type=str,
            default=&#34;&#34;,
            help=&#34;toy or any custom climate&#34;,
        )

    def update_climate(self, force=False):
        &#34;&#34;&#34;
        compute climate at time t
        &#34;&#34;&#34;

        if len(self.config.type_climate) &gt; 0:

            if not hasattr(self, &#34;already_called_update_climate&#34;):

                getattr(self, &#34;load_climate_data_&#34; + self.config.type_climate)()
                self.tlast_clim = -1.0e5000
                self.tcomp[&#34;Climate&#34;] = []
                self.already_called_update_climate = True

            new_clim_needed = (
                self.t.numpy() - self.tlast_clim
            ) &gt;= self.config.clim_update_freq

            if force | new_clim_needed:

                if self.config.verbosity == 1:
                    print(&#34;Construct climate at time : &#34;, igm.t)

                self.tcomp[&#34;Climate&#34;].append(time.time())

                getattr(self, &#34;update_climate_&#34; + self.config.type_climate)()

                self.tlast_clim = self.t.numpy()

                self.tcomp[&#34;Climate&#34;][-1] -= time.time()
                self.tcomp[&#34;Climate&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                                 MASS BALANCE
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_smb(self):

        self.parser.add_argument(
            &#34;--mb_update_freq&#34;,
            type=float,
            default=1,
            help=&#34;Update the mass balance each X years (1)&#34;,
        )
        self.parser.add_argument(
            &#34;--type_mass_balance&#34;,
            type=str,
            default=&#34;simple&#34;,
            help=&#34;zero, simple, given&#34;,
        )
        self.parser.add_argument(
            &#34;--mb_scaling&#34;, type=float, default=1.0, help=&#34;mass balance scaling&#34;
        )
        self.parser.add_argument(
            &#34;--mb_simple_file&#34;,
            type=str,
            default=&#34;mb_simple_param.txt&#34;,
            help=&#34;mb_simple_file&#34;,
        )
        self.parser.add_argument(
            &#34;--smb_model_lib_path&#34;,
            type=str,
            default=&#34;/home/jouvetg/IGM/model-lib/smb_meteoswissglamos&#34;,
            help=&#34;Model directory in case the smb model in use is &#39;nn&#39;for neural netowrk&#34;,
        )

    def init_smb_simple(self):
        &#34;&#34;&#34;
        initialize simple mass balance
        &#34;&#34;&#34;
        param = np.loadtxt(
            os.path.join(self.config.working_dir, self.config.mb_simple_file),
            skiprows=1,
            dtype=np.float32,
        )

        self.gradabl = interp1d(
            param[:, 0],
            param[:, 1],
            fill_value=(param[0, 1], param[-1, 1]),
            bounds_error=False,
        )
        self.gradacc = interp1d(
            param[:, 0],
            param[:, 2],
            fill_value=(param[0, 2], param[-1, 2]),
            bounds_error=False,
        )
        self.ela = interp1d(
            param[:, 0],
            param[:, 3],
            fill_value=(param[0, 3], param[-1, 3]),
            bounds_error=False,
        )
        self.maxacc = interp1d(
            param[:, 0],
            param[:, 4],
            fill_value=(param[0, 4], param[-1, 4]),
            bounds_error=False,
        )

    def update_smb_simple(self):
        &#34;&#34;&#34;
        mass balance &#39;simple&#39; parametrized by ELA, ablation and accumulation gradients, and max acuumulation
        &#34;&#34;&#34;

        ela = np.float32(self.ela(self.t))
        gradabl = np.float32(self.gradabl(self.t))
        gradacc = np.float32(self.gradacc(self.t))
        maxacc = np.float32(self.maxacc(self.t))

        smb = self.usurf - ela
        smb *= tf.where(tf.less(smb, 0), gradabl, gradacc)
        smb = tf.clip_by_value(smb, -100, maxacc)
        smb = tf.where(self.icemask &gt; 0.5, smb, -10)

        self.smb.assign(smb)

    def init_smb_nn(self):
        &#34;&#34;&#34;
        set-up the smb nn emulator
        &#34;&#34;&#34;

        dirpath = os.path.join(self.config.smb_model_lib_path, str(int(self.dx)))

        assert os.path.isdir(dirpath)

        fieldin, fieldout, fieldbounds = self.read_fields_and_bounds(dirpath)

        self.read_fields_and_bounds(dirpath)

        self.smb_mapping = {}
        self.smb_mapping[&#34;fieldin&#34;] = fieldin
        self.smb_mapping[&#34;fieldout&#34;] = fieldout
        self.smb_fieldbounds = fieldbounds

        self.smb_model = tf.keras.models.load_model(os.path.join(dirpath, &#34;model.h5&#34;))

    def update_smb_nn(self):
        &#34;&#34;&#34;
        function update the smb using the neural network emulator
        &#34;&#34;&#34;

        # this is not a nice implementation, but for now, it does the job
        self.mask = tf.ones_like(self.thk)
        for i in range(12):
            vars(self)[&#34;air_temp_&#34; + str(i)] = self.air_temp[i]
            vars(self)[&#34;precipitation_&#34; + str(i)] = self.precipitation[i]

        X = tf.expand_dims(
            tf.stack(
                [
                    vars(self)[f] / self.smb_fieldbounds[f]
                    for f in self.smb_mapping[&#34;fieldin&#34;]
                ],
                axis=-1,
            ),
            axis=0,
        )

        Y = self.smb_model.predict_on_batch(X)

        # this will return the smb, the only output of the smb nn emulator
        for kk, f in enumerate(self.smb_mapping[&#34;fieldout&#34;]):
            vars(self)[f].assign(Y[0, :, :, kk] * self.smb_fieldbounds[f])

    def update_smb(self, force=False):
        &#34;&#34;&#34;
        update_mass balance
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_smb&#34;):
            self.tlast_mb = -1.0e5000
            self.tcomp[&#34;Mass balance&#34;] = []
            if len(self.config.type_mass_balance) &gt; 0:
                if hasattr(self, &#34;init_smb_&#34; + self.config.type_mass_balance):
                    getattr(self, &#34;init_smb_&#34; + self.config.type_mass_balance)()
            self.already_called_update_smb = True

        if (force) | ((self.t.numpy() - self.tlast_mb) &gt;= self.config.mb_update_freq):

            if self.config.verbosity == 1:
                print(&#34;Construct mass balance at time : &#34;, self.t.numpy())

            self.tcomp[&#34;Mass balance&#34;].append(time.time())

            if len(self.config.type_mass_balance) &gt; 0:
                getattr(self, &#34;update_smb_&#34; + self.config.type_mass_balance)()
            else:
                self.smb.assign(tf.zeros_like(self.topg))

            if hasattr(self, &#34;icemask&#34;):
                self.smb.assign(self.smb * self.icemask)

            if not self.config.mb_scaling == 1:
                self.smb.assign(self.smb * self.config.mb_scaling)

            self.tlast_mb = self.t.numpy()

            if self.config.stop:
                mb_np = self.smb.numpy()

            self.tcomp[&#34;Mass balance&#34;][-1] -= time.time()
            self.tcomp[&#34;Mass balance&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              BASAL EROSION
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_erosion(self):

        self.parser.add_argument(
            &#34;--erosion_include&#34;,
            type=str2bool,
            default=False,
            help=&#34;Include a model for bedrock erosion&#34;,
        )
        self.parser.add_argument(
            &#34;--erosion_cst&#34;,
            type=float,
            default=2.7 * 10 ** (-7),
            help=&#34;Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193–195 (2015)&#34;,
        )

        self.parser.add_argument(
            &#34;--erosion_exp&#34;,
            type=float,
            default=2,
            help=&#34;Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193–195 (2015).&#34;,
        )
        self.parser.add_argument(
            &#34;--erosion_update_freq&#34;,
            type=float,
            default=100,
            help=&#34;Update the erosion only each 100 years&#34;,
        )

    def update_topg(self):
        &#34;&#34;&#34;
        update bedrock due to glacial errosion,
        eroson rate are proportional to a power
        of the sliding velocity magnitude
        &#34;&#34;&#34;

        if self.config.erosion_include:

            if not hasattr(self, &#34;already_called_update_topg&#34;):
                self.tlast_erosion = self.config.tstart
                self.tcomp[&#34;Erosion&#34;] = []
                self.already_called_update_topg = True

            if (self.t.numpy() - self.tlast_erosion) &gt;= self.config.erosion_update_freq:

                if self.config.verbosity == 1:
                    print(&#34;Erode bedrock at time : &#34;, self.t.numpy())

                self.tcomp[&#34;Erosion&#34;].append(time.time())

                self.velbase_mag = self.getmag(self.uvelbase, self.vvelbase)

                self.dtopgdt.assign(self.config.erosion_cst * (self.velbase_mag ** self.config.erosion_exp))

                self.topg.assign(self.topg - (self.t.numpy() - self.tlast_erosion) * self.dtopgdt)

                print(&#39;max erosion is :&#39;, np.max( np.abs ( self.dtopgdt ) ) )

                self.usurf.assign(self.topg + self.thk)

                self.tlast_erosion = self.t.numpy()

                self.tcomp[&#34;Erosion&#34;][-1] -= time.time()
                self.tcomp[&#34;Erosion&#34;][-1] *= -1

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              TRANSPORT
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def update_thk(self):
        &#34;&#34;&#34;
        update ice thickness solving dh/dt + d(u h)/dx + d(v h)/dy = f using
        upwind finite volume, update usurf and slopes
        &#34;&#34;&#34;

        if not hasattr(self, &#34;already_called_update_icethickness&#34;):
            self.tcomp[&#34;Transport&#34;] = []
            self.already_called_update_icethickness = True

        if self.config.verbosity == 1:
            print(&#34;Ice thickness equation at time : &#34;, self.t.numpy())

        self.tcomp[&#34;Transport&#34;].append(time.time())

        # compute the divergence of the flux
        self.divflux = self.compute_divflux(
            self.ubar, self.vbar, self.thk, self.dx, self.dx
        )

        # Forward Euler with projection to keep ice thickness non-negative
        self.thk.assign(tf.maximum(self.thk + self.dt * (self.smb - self.divflux), 0))

        self.usurf.assign(self.topg + self.thk)

        self.slopsurfx, self.slopsurfy = self.compute_gradient_tf(
            self.usurf, self.dx, self.dx
        )

        self.tcomp[&#34;Transport&#34;][-1] -= time.time()
        self.tcomp[&#34;Transport&#34;][-1] *= -1

    @tf.function()
    def compute_divflux(self, u, v, h, dx, dy):
        &#34;&#34;&#34;
        #   upwind computation of the divergence of the flux : d(u h)/dx + d(v h)/dy
        #   First, u and v are computed on the staggered grid (i.e. cell edges)
        #   Second, one extend h horizontally by a cell layer on any bords (assuming same value)
        #   Third, one compute the flux on the staggered grid slecting upwind quantities
        #   Last, computing the divergence on the staggered grid yields values def on the original grid
        &#34;&#34;&#34;

        ## Compute u and v on the staggered grid
        u = tf.concat(
            [u[:, 0:1], 0.5 * (u[:, :-1] + u[:, 1:]), u[:, -1:]], 1
        )  # has shape (ny,nx+1)
        v = tf.concat(
            [v[0:1, :], 0.5 * (v[:-1, :] + v[1:, :]), v[-1:, :]], 0
        )  # has shape (ny+1,nx)

        # Extend h with constant value at the domain boundaries
        Hx = tf.pad(h, [[0, 0], [1, 1]], &#34;CONSTANT&#34;)  # has shape (ny,nx+2)
        Hy = tf.pad(h, [[1, 1], [0, 0]], &#34;CONSTANT&#34;)  # has shape (ny+2,nx)

        ## Compute fluxes by selcting the upwind quantities
        Qx = u * tf.where(u &gt; 0, Hx[:, :-1], Hx[:, 1:])  # has shape (ny,nx+1)
        Qy = v * tf.where(v &gt; 0, Hy[:-1, :], Hy[1:, :])  # has shape (ny+1,nx)

        ## Computation of the divergence, final shape is (ny,nx)
        return (Qx[:, 1:] - Qx[:, :-1]) / dx + (Qy[1:, :] - Qy[:-1, :]) / dy

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               3DVEL
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_3dvel(self):

        self.parser.add_argument(
            &#34;--vel3d_active&#34;,
            type=int,
            default=False,
            help=&#34;Is the computational of the 3D vel active?&#34;,
        )

        self.parser.add_argument(
            &#34;--dz&#34;,
            type=int,
            default=20,
            help=&#34;Vertical discretization constant spacing&#34;,
        )

        self.parser.add_argument(
            &#34;--maxthk&#34;, type=float, default=1000.0, help=&#34;Vertical maximum thickness&#34;
        )

    def init_3dvel(self):

        if self.config.vel3d_active:

            self.height = np.arange(
                0, self.config.maxthk + 1, self.config.dz
            )  # height with constant dz
            self.ddz = self.height[1:] - self.height[:-1]

            self.nz = tf.Variable(
                tf.zeros((self.thk.shape[0], self.thk.shape[1]), dtype=&#34;int32&#34;)
            )
            self.depth = tf.Variable(
                tf.zeros(
                    (self.height.shape[0], self.thk.shape[0], self.thk.shape[1]),
                    dtype=&#34;float32&#34;,
                )
            )
            self.dz = tf.Variable(
                tf.zeros(
                    (self.height.shape[0] - 1, self.thk.shape[0], self.thk.shape[1]),
                    dtype=&#34;float32&#34;,
                )
            )

            self.U = tf.Variable(tf.zeros_like(self.depth))  # x-vel component
            self.V = tf.Variable(tf.zeros_like(self.depth))  # y-vel component
            self.W = tf.Variable(tf.zeros_like(self.depth))  # z-vel component

            self.tcomp[&#34;3d Vel&#34;] = []

    @tf.function()
    def update_vert_disc_tf(self):

        # nz is the index of the first node above the ice surface
        nz = tf.ones(self.thk.shape, &#34;int32&#34;) * (self.height.shape[0] - 1)
        for k in range(self.height.shape[0] - 1, -1, -1):
            nz = tf.where(self.height[k] &gt; self.thk, k, nz)
        self.nz.assign(tf.where(self.thk &gt;= self.ddz[0], nz, 1))

        # depth is the depth of ice at any grid point, otherwise it is zero
        depth = []
        for k in range(0, self.height.shape[0]):
            depth.append(
                tf.where(
                    (self.thk &gt;= self.ddz[0]) &amp; (k &lt; self.nz),
                    self.thk - self.height[k],
                    0.0,
                )
            )
        self.depth.assign(tf.stack(depth, axis=0))

        # dz is the  vertical spacing,
        dz = []
        for k in range(0, self.height.shape[0] - 1):
            dz.append(tf.ones_like(self.thk) * self.ddz[k])
        self.dz.assign(tf.stack(dz, axis=0))

    @tf.function()
    def update_reconstruct_3dvel_tf(self):

        # Reconstruct the horizontal velocity field from basal and surface velocity assuming a SIA-like profile
        fshear = []
        U = []
        V = []
        W = []

        fshear.append(tf.zeros_like(self.thk))

        for k in range(1, self.height.shape[0]):
            fshear.append(
                fshear[-1]
                + tf.where(k &lt; self.nz, self.dz[k - 1], 0.0) * (self.depth[k] ** 3)
            )

        norm = fshear[-1]

        for k in range(0, self.height.shape[0]):
            fshear[k] /= tf.where(self.nz &gt; 1, norm, 1.0)

        for k in range(0, self.height.shape[0]):
            U.append(self.uvelbase + fshear[k] * (self.uvelsurf - self.uvelbase))
            V.append(self.vvelbase + fshear[k] * (self.vvelsurf - self.vvelbase))

        self.U.assign(tf.stack(U, axis=0))
        self.V.assign(tf.stack(V, axis=0))

        Ui = tf.pad(self.U, [[0, 0], [0, 0], [1, 1]], &#34;SYMMETRIC&#34;)
        Vj = tf.pad(self.V, [[0, 0], [1, 1], [0, 0]], &#34;SYMMETRIC&#34;)

        ######### THis methods reconstruct the vertical velocity using divflux,
        ######### and assuming a SIA-like profile like x- and y- components

        slopsurfx, slopsurfy = self.compute_gradient_tf(self.usurf, self.dx, self.dx)
        sloptopgx, sloptopgy = self.compute_gradient_tf(self.topg, self.dx, self.dx)

        divflux = self.compute_divflux(self.ubar, self.vbar, self.thk, self.dx, self.dx)

        self.wvelbase = self.uvelbase * sloptopgx + self.vvelbase * sloptopgy
        self.wvelsurf = -divflux + self.uvelsurf * slopsurfx + self.vvelsurf * slopsurfy

        for k in range(0, self.height.shape[0]):
            W.append(self.wvelbase + fshear[k] * (self.wvelsurf - self.wvelbase))

        self.W.assign(tf.stack(W, axis=0))

        ### This methods integrates the imcompressiblity conditoons

        # W.append( tf.zeros_like(self.thk) )

        # for k in range(1,self.height.shape[0]):
        #     W.append( W[-1] + tf.where( k&lt;self.nz, \
        #                                 self.dz[k-1] * ( - (Ui[k-1,:, 2:] - Ui[k-1,:,:-2]) / (2*self.dx) \
        #                                                  - (Vj[k-1,2:, :] - Vj[k-1,:-2,:]) / (2*self.dx) ), \
        #                                 0.0 )
        #             )

        # self.W.assign( tf.stack(W,axis=0) )

    def update_3dvel(self):

        if self.config.vel3d_active:

            if self.config.verbosity == 1:
                print(&#34;update_3dvel &#34;)

            self.tcomp[&#34;3d Vel&#34;].append(time.time())

            self.update_vert_disc_tf()

            self.update_reconstruct_3dvel_tf()

            self.update_ncdf_3d_ex()

            self.tcomp[&#34;3d Vel&#34;][-1] -= time.time()
            self.tcomp[&#34;3d Vel&#34;][-1] *= -1

    def update_ncdf_3d_ex(self, force=False):
        &#34;&#34;&#34;
        Initialize  and write the ncdf output file
        &#34;&#34;&#34;

        if force | self.saveresult:

            if self.it == 0:

                if self.config.verbosity == 1:
                    print(&#34;Initialize NCDF output Files&#34;)

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex3d.nc&#34;),
                    &#34;w&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                nc.createDimension(&#34;time&#34;, None)
                E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
                E.units = &#34;yr&#34;
                E.long_name = &#34;time&#34;
                E.axis = &#34;T&#34;
                E[0] = self.t.numpy()

                nc.createDimension(&#34;h&#34;, self.height.shape[0])
                E = nc.createVariable(&#34;h&#34;, np.dtype(&#34;float32&#34;).char, (&#34;h&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;h&#34;
                E.standard_name = &#34;h&#34;
                E.axis = &#34;H&#34;
                E[:] = self.height

                nc.createDimension(&#34;y&#34;, len(self.y))
                E = nc.createVariable(&#34;y&#34;, np.dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;y&#34;
                E.axis = &#34;Y&#34;
                E[:] = self.y.numpy()

                nc.createDimension(&#34;x&#34;, len(self.x))
                E = nc.createVariable(&#34;x&#34;, np.dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
                E.units = &#34;m&#34;
                E.long_name = &#34;x&#34;
                E.axis = &#34;X&#34;
                E[:] = self.x.numpy()

                E = nc.createVariable(
                    &#34;topg&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m&#34;
                E.long_name = &#34;topg&#34;
                E.standard_name = &#34;topg&#34;
                E[0, :, :] = self.topg.numpy()

                E = nc.createVariable(
                    &#34;usurf&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m&#34;
                E.long_name = &#34;usurf&#34;
                E.standard_name = &#34;usurf&#34;
                E[0, :, :] = self.usurf.numpy()

                E = nc.createVariable(
                    &#34;U&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m/y&#34;
                E.long_name = &#34;U&#34;
                E.standard_name = &#34;U&#34;
                E[0, :, :, :] = self.U.numpy()

                E = nc.createVariable(
                    &#34;V&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m/y&#34;
                E.long_name = &#34;V&#34;
                E.standard_name = &#34;V&#34;
                E[0, :, :, :] = self.V.numpy()

                E = nc.createVariable(
                    &#34;W&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.units = &#34;m/y&#34;
                E.long_name = &#34;W&#34;
                E.standard_name = &#34;W&#34;
                E[0, :, :, :] = self.W.numpy()

                nc.close()

            else:

                nc = Dataset(
                    os.path.join(self.config.working_dir, &#34;ex3d.nc&#34;),
                    &#34;a&#34;,
                    format=&#34;NETCDF4&#34;,
                )

                d = nc.variables[&#34;time&#34;][:].shape[0]
                nc.variables[&#34;time&#34;][d] = self.t.numpy()
                nc.variables[&#34;U&#34;][d, :, :, :] = self.U.numpy()
                nc.variables[&#34;V&#34;][d, :, :, :] = self.V.numpy()
                nc.variables[&#34;W&#34;][d, :, :, :] = self.W.numpy()
                nc.variables[&#34;usurf&#34;][d, :, :] = self.usurf.numpy()
                nc.variables[&#34;topg&#34;][d, :, :] = self.topg.numpy()

                nc.close()

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                               OPTI
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_optimize(self):

        # OPTIMIZATION PARAMETERS
        self.parser.add_argument(
            &#34;--opti_vars_to_save&#34;,
            type=list,
            default=[
                &#34;topg&#34;,
                &#34;usurf&#34;,
                &#34;thk&#34;,
                &#34;strflowctrl&#34;,
                &#34;arrhenius&#34;,
                &#34;slidingco&#34;,
                &#34;velsurf_mag&#34;,
                &#34;velsurfobs_mag&#34;,
                &#34;divflux&#34;,
            ],
            help=&#34;List of variables to be recorded in the ncdef file&#34;,
        )
        self.parser.add_argument(
            &#34;--observation_file&#34;,
            type=str,
            default=&#34;observation.nc&#34;,
            help=&#34;Observation file contains the 2D data observations fields (thkobs, usurfobs, uvelsurfobs, ....) &#34;,
        )
        self.parser.add_argument(
            &#34;--thk_profiles_file&#34;,
            type=str,
            default=&#34;&#34;,
            help=&#34;Provide ice thickness measurements, if empty string it will look for rasterized thk in the input data file&#34;,
        )
        self.parser.add_argument(&#34;--mode_opti&#34;, type=str, default=&#34;thkstrflowctrl&#34;)

        self.parser.add_argument(
            &#34;--opti_thr_strflowctrl&#34;,
            type=float,
            default=78.0,
            help=&#34;threshold value for strflowctrl&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_init_zero_thk&#34;,
            type=str2bool,
            default=&#34;False&#34;,
            help=&#34;Initialize the optimization with zero ice thickness&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_regu_param_thk&#34;,
            type=float,
            default=10.0,
            help=&#34;Regularization weight for the ice thickness in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_regu_param_strflowctrl&#34;,
            type=float,
            default=1.0,
            help=&#34;Regularization weight for the strflowctrl field in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_smooth_anisotropy_factor&#34;,
            type=float,
            default=0.2,
            help=&#34;Smooth anisotropy factor for the ice thickness regularization in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_convexity_weight&#34;,
            type=float,
            default=0.002,
            help=&#34;Convexity weight for the ice thickness regularization in the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_usurfobs_std&#34;,
            type=float,
            default=5.0,
            help=&#34;Confidence/STD of the top ice surface as input data for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_strflowctrl_std&#34;,
            type=float,
            default=5.0,
            help=&#34;Confidence/STD of strflowctrl&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_velsurfobs_std&#34;,
            type=float,
            default=3.0,
            help=&#34;Confidence/STD of the surface ice velocities as input data for the optimization (if 0, velsurfobs_std field must be given)&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_thkobs_std&#34;,
            type=float,
            default=5.0,
            help=&#34;Confidence/STD of the ice thickness profiles (unless given)&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_divfluxobs_std&#34;,
            type=float,
            default=1.0,
            help=&#34;Confidence/STD of the flux divergence as input data for the optimization (if 0, divfluxobs_std field must be given)&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_control&#34;,
            type=list,
            default=[&#34;thk&#34;, &#34;strflowctrl&#34;, &#34;usurf&#34;],
            help=&#34;List of optimized variables for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_cost&#34;,
            type=list,
            default=[&#34;velsurf&#34;, &#34;thk&#34;, &#34;usurf&#34;, &#34;divfluxfcz&#34;, &#34;icemask&#34;],
            help=&#34;List of cost components for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_nbitmin&#34;,
            type=int,
            default=50,
            help=&#34;Min iterations for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_nbitmax&#34;,
            type=int,
            default=1000,
            help=&#34;Max iterations for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_step_size&#34;,
            type=float,
            default=0.001,
            help=&#34;Step size for the optimization&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_make_holes_in_data&#34;,
            type=int,
            default=0,
            help=&#34;This produces artifical holes in data, serve to test the robustness of the method to missing data&#34;,
        )
        self.parser.add_argument(
            &#34;--opti_output_freq&#34;,
            type=int,
            default=50,
            help=&#34;Frequency of the output for the optimization&#34;,
        )

    def make_data_holes(self):
        &#34;&#34;&#34;
        This serves to make holes in surface data (velocities) to test robusness of the optimization
        &#34;&#34;&#34;

        mask_holes = np.zeros_like(self.thk.numpy(), dtype=&#34;int&#34;)

        if (self.config.opti_make_holes_in_data &gt; 0) &amp; (
            self.config.opti_make_holes_in_data &lt; 99
        ):

            np.random.seed(seed=123)

            while (
                np.sum(mask_holes) / np.sum(self.icemaskobs &gt; 0.5)
            ) &lt; self.config.opti_make_holes_in_data * 0.01:

                j = np.random.randint(0, self.thk.shape[0])
                i = np.random.randint(0, self.thk.shape[1])

                if self.icemaskobs[j, i] &gt; 0.5:
                    mask_holes[j, i] = 1

        elif self.config.opti_make_holes_in_data == 100:
            mask_holes = np.ones_like(self.thk.numpy(), dtype=&#34;int&#34;)

        elif self.config.opti_make_holes_in_data == 200:
            mask_holes[self.Y &gt; np.mean(self.y)] = 1

        self.uvelsurfobs = tf.where(
            (self.icemaskobs == 1) &amp; (mask_holes == 0), self.uvelsurfobs, np.nan
        )
        self.vvelsurfobs = tf.where(
            (self.icemaskobs == 1) &amp; (mask_holes == 0), self.vvelsurfobs, np.nan
        )

    def load_thk_profiles(self):
        &#34;&#34;&#34;
        load glacier ice thickness mesured profiles
        &#34;&#34;&#34;

        pathprofile = os.path.join(
            self.config.working_dir, self.config.thk_profiles_file
        )

        if len(glob.glob(pathprofile)) &gt; 0:

            vvv = []
            for g in glob.glob(pathprofile):
                vvv.append(np.loadtxt(g, dtype=np.float32))
            self.profile = np.concatenate(vvv, axis=0)

            # re-index profiles in case there were not properly indexed
            self.profile = [
                self.profile[np.floor(self.profile[:, 0]) == i + 1, :]
                for i in range(int(np.max(self.profile[:, 0])))
            ]

            # Remove empty List from List using list comprehension
            self.profile = [ele for ele in self.profile if len(ele) &gt; 0]

            # compute the distance between points as first entry as it will be usefully later on
            for p in self.profile:
                p[:, 0] = np.insert(
                    np.cumsum(np.sqrt(np.diff(p[:, 1]) ** 2 + np.diff(p[:, 2]) ** 2)),
                    0,
                    0,
                )
        else:
            sys.exit(&#34;thk requested in opti, but file &#34; + pathprofile + &#34; is not found&#34;)

        points = np.stack([item[1:3] for sublist in self.profile for item in sublist])
        jiptprof = []
        for p in points:
            i = (p[0] - np.min(self.X)) / self.dx
            j = (p[1] - np.min(self.Y)) / self.dx
            jiptprof.append([j, i])
        self.jiptprof = tf.expand_dims(jiptprof, axis=0)

        target = np.stack([item[3] for sublist in self.profile for item in sublist])
        self.thktargetprof = tf.Variable(target.astype(&#34;float32&#34;))

        target = np.stack([item[4] for sublist in self.profile for item in sublist])
        self.thktargetprof_std = tf.Variable(target.astype(&#34;float32&#34;))

    def compute_flow_direction_for_anisotropic_smoothing(self):
        &#34;&#34;&#34;
        compute_flow_direction_for_anisotropic_smoothing
        &#34;&#34;&#34;

        uvelsurfobs = tf.where(tf.math.is_nan(self.uvelsurfobs), 0.0, self.uvelsurfobs)
        vvelsurfobs = tf.where(tf.math.is_nan(self.vvelsurfobs), 0.0, self.vvelsurfobs)

        self.flowdirx = (
            uvelsurfobs[1:, 1:]
            + uvelsurfobs[:-1, 1:]
            + uvelsurfobs[1:, :-1]
            + uvelsurfobs[:-1, :-1]
        ) / 4.0
        self.flowdiry = (
            vvelsurfobs[1:, 1:]
            + vvelsurfobs[:-1, 1:]
            + vvelsurfobs[1:, :-1]
            + vvelsurfobs[:-1, :-1]
        ) / 4.0

        from scipy.ndimage import gaussian_filter

        self.flowdirx = gaussian_filter(self.flowdirx, 3, mode=&#34;constant&#34;)
        self.flowdiry = gaussian_filter(self.flowdiry, 3, mode=&#34;constant&#34;)

        # Same as gaussian filter above but for tensorflow is (NOT TESTED)
        # import tensorflow_addons as tfa
        # self.flowdirx.assign( tfa.image.gaussian_filter2d( self.flowdirx , sigma=3, filter_shape=100, padding=&#34;CONSTANT&#34;) )

        self.flowdirx /= self.getmag(self.flowdirx, self.flowdiry)
        self.flowdiry /= self.getmag(self.flowdirx, self.flowdiry)

        self.flowdirx = tf.where(tf.math.is_nan(self.flowdirx), 0.0, self.flowdirx)
        self.flowdiry = tf.where(tf.math.is_nan(self.flowdiry), 0.0, self.flowdiry)

        # this is to plot the observed flow directions
        # fig, axs = plt.subplots(1, 1, figsize=(8,16))
        # plt.quiver(self.flowdirx,self.flowdiry)
        # axs.axis(&#34;equal&#34;)

    def optimize(self):
        &#34;&#34;&#34;
        This is the optimization routine to invert thk, strflowctrl ans usurf from data
        DEFAULT PARAMETERS ARE
        # nbitmin=50, nbitmax=1000, opti_step_size=0.001,
        # init_zero_thk=True,
        # regu_param_thk=1.0, regu_param_strflowctrl=1.0,
        # smooth_anisotropy_factor=0.2, convexity_weight = 0.002,
        # opti_control=[&#39;thk&#39;,&#39;strflowctrl&#39;], opti_cost=[&#39;velsurf&#39;,&#39;thk&#39;],
        &#34;&#34;&#34;

        ###### PERFORM CHECKS PRIOR OPTIMIZATIONS

        # make sure this condition is satisfied
        assert (&#34;usurf&#34; in self.config.opti_cost) == (
            &#34;usurf&#34; in self.config.opti_control
        )

        # make sure the loaded ice flow emulator has these inputs
        assert (
            self.iceflow_mapping[&#34;fieldin&#34;]
            == [&#34;thk&#34;, &#34;slopsurfx&#34;, &#34;slopsurfy&#34;, &#34;arrhenius&#34;, &#34;slidingco&#34;]
        ) | (
            self.iceflow_mapping[&#34;fieldin&#34;]
            == [&#34;thk&#34;, &#34;slopsurfx&#34;, &#34;slopsurfy&#34;, &#34;strflowctrl&#34;]
        )

        # make sure the loaded ice flow emulator has at least these outputs
        assert all(
            [
                (f in self.iceflow_mapping[&#34;fieldout&#34;])
                for f in [&#34;ubar&#34;, &#34;vbar&#34;, &#34;uvelsurf&#34;, &#34;vvelsurf&#34;]
            ]
        )

        # make sure that there are lease some profiles in thkobs
        if &#34;thk&#34; in self.config.opti_cost:
            if self.config.thk_profiles_file == &#34;&#34;:
                assert not tf.reduce_all(tf.math.is_nan(self.thkobs))

        ###### PREPARE DATA PRIOR OPTIMIZATIONS

        if &#34;thk&#34; in self.config.opti_cost:
            if not self.config.thk_profiles_file == &#34;&#34;:
                self.load_thk_profiles()

        if hasattr(self, &#34;uvelsurfobs&#34;) &amp; hasattr(self, &#34;vvelsurfobs&#34;):
            self.velsurfobs = tf.stack([self.uvelsurfobs, self.vvelsurfobs], axis=-1)

        if &#34;divfluxobs&#34; in self.config.opti_cost:
            self.divfluxobs = self.smb - self.dhdt

        if not self.config.opti_smooth_anisotropy_factor == 1:
            self.compute_flow_direction_for_anisotropic_smoothing()

        if self.config.opti_make_holes_in_data &gt; 0:
            self.make_data_holes()

        if hasattr(self, &#34;thkinit&#34;):
            self.thk.assign(self.thkinit)
        else:
            self.thk.assign(tf.zeros_like(self.thk))

        if self.config.opti_init_zero_thk:
            self.thk.assign(tf.zeros_like(self.thk))

        ###### PREPARE OPIMIZER

        optimizer = tf.keras.optimizers.Adam(lr=self.config.opti_step_size)

        # initial_learning_rate * decay_rate ^ (step / decay_steps)
        # lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay( initial_learning_rate=opti_step_size, decay_steps=100, decay_rate=0.9)
        # optimizer = tf.keras.optimizers.Adam(learning_rate=lr_schedule)

        # add scalng for usurf
        self.iceflow_fieldbounds[&#34;usurf&#34;] = (
            self.iceflow_fieldbounds[&#34;slopsurfx&#34;] * self.dx
        )

        ###### PREPARE VARIABLES TO OPTIMIZE

        if self.iceflow_mapping[&#34;fieldin&#34;] == [
            &#34;thk&#34;,
            &#34;slopsurfx&#34;,
            &#34;slopsurfy&#34;,
            &#34;arrhenius&#34;,
            &#34;slidingco&#34;,
        ]:
            self.iceflow_fieldbounds[&#34;strflowctrl&#34;] = (
                self.iceflow_fieldbounds[&#34;arrhenius&#34;]
                + self.iceflow_fieldbounds[&#34;slidingco&#34;]
            )

        thk = tf.Variable(self.thk / self.iceflow_fieldbounds[&#34;thk&#34;])  # normalized vars
        strflowctrl = tf.Variable(
            self.strflowctrl / self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
        )  # normalized vars
        usurf = tf.Variable(
            self.usurf / self.iceflow_fieldbounds[&#34;usurf&#34;]
        )  # normalized vars

        self.costs = []

        self.tcomp[&#34;Optimize&#34;] = []

        # main loop
        for i in range(self.config.opti_nbitmax):

            with tf.GradientTape() as t:

                self.tcomp[&#34;Optimize&#34;].append(time.time())

                # is necessary to remember all operation to derive the gradients w.r.t. control variables
                if &#34;thk&#34; in self.config.opti_control:
                    t.watch(thk)
                if &#34;usurf&#34; in self.config.opti_control:
                    t.watch(usurf)
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    t.watch(strflowctrl)

                # update surface gradient
                if (i == 0) | (&#34;usurf&#34; in self.config.opti_control):
                    slopsurfx, slopsurfy = self.compute_gradient_tf(
                        usurf * self.iceflow_fieldbounds[&#34;usurf&#34;], self.dx, self.dx
                    )
                    slopsurfx = slopsurfx / self.iceflow_fieldbounds[&#34;slopsurfx&#34;]
                    slopsurfy = slopsurfy / self.iceflow_fieldbounds[&#34;slopsurfy&#34;]

                if self.iceflow_mapping[&#34;fieldin&#34;] == [
                    &#34;thk&#34;,
                    &#34;slopsurfx&#34;,
                    &#34;slopsurfy&#34;,
                    &#34;arrhenius&#34;,
                    &#34;slidingco&#34;,
                ]:

                    thrv = (
                        self.config.opti_thr_strflowctrl
                        / self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                    )
                    arrhenius = tf.where(strflowctrl &lt;= thrv, strflowctrl, thrv)
                    slidingco = tf.where(strflowctrl &lt;= thrv, 0, strflowctrl - thrv)

                    # build input of the emulator
                    X = tf.concat(
                        [
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(thk, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfx, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfy, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(arrhenius, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slidingco, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                        ],
                        axis=-1,
                    )

                elif self.iceflow_mapping[&#34;fieldin&#34;] == [
                    &#34;thk&#34;,
                    &#34;slopsurfx&#34;,
                    &#34;slopsurfy&#34;,
                    &#34;strflowctrl&#34;,
                ]:

                    # build input of the emulator
                    X = tf.concat(
                        [
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(thk, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfx, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(slopsurfy, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                            tf.expand_dims(
                                tf.expand_dims(
                                    tf.pad(strflowctrl, self.PAD, &#34;CONSTANT&#34;), axis=0
                                ),
                                axis=-1,
                            ),
                        ],
                        axis=-1,
                    )
                else:
                    # ONLY these 2 above cases were implemented !!!
                    sys.exit(
                        &#34;CHANGE THE ICE FLOW EMULATOR -- IMCOMPATIBLE FOR INVERSION &#34;
                    )

                # evalutae th ice flow emulator
                Y = self.iceflow_model(X)

                # get the dimensions of the working array
                Ny, Nx = self.thk.shape

                # save output variables into igm.variables for outputs
                for kk, f in enumerate(self.iceflow_mapping[&#34;fieldout&#34;]):
                    vars(self)[f].assign(
                        Y[0, :Ny, :Nx, kk] * self.iceflow_fieldbounds[f]
                    )

                # find index of variables in output
                iubar = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;ubar&#34;)
                ivbar = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;vbar&#34;)
                iuvsu = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;uvelsurf&#34;)
                ivvsu = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;vvelsurf&#34;)

                # save output of the emaultor to compute the costs function
                ubar = (
                    Y[0, :Ny, :Nx, iubar] * self.iceflow_fieldbounds[&#34;ubar&#34;]
                )  # NOT normalized vars
                vbar = (
                    Y[0, :Ny, :Nx, ivbar] * self.iceflow_fieldbounds[&#34;vbar&#34;]
                )  # NOT normalized vars
                uvelsurf = (
                    Y[0, :Ny, :Nx, iuvsu] * self.iceflow_fieldbounds[&#34;uvelsurf&#34;]
                )  # NOT normalized vars
                vvelsurf = (
                    Y[0, :Ny, :Nx, ivvsu] * self.iceflow_fieldbounds[&#34;vvelsurf&#34;]
                )  # NOT normalized vars
                velsurf = tf.stack([uvelsurf, vvelsurf], axis=-1)  # NOT normalized vars

                # misfit between surface velocity
                if &#34;velsurf&#34; in self.config.opti_cost:
                    ACT = ~tf.math.is_nan(self.velsurfobs)
                    COST_U = 0.5 * tf.reduce_mean(
                        (
                            (self.velsurfobs[ACT] - velsurf[ACT])
                            / self.config.opti_velsurfobs_std
                        )
                        ** 2
                    )
                else:
                    COST_U = tf.Variable(0.0)

                # misfit between ice thickness profiles
                if &#34;thk&#34; in self.config.opti_cost:
                    if self.config.thk_profiles_file == &#34;&#34;:
                        ACT = ~tf.math.is_nan(self.thkobs)
                        COST_H = 0.5 * tf.reduce_mean(
                            (
                                (
                                    self.thkobs[ACT]
                                    - thk[ACT] * self.iceflow_fieldbounds[&#34;thk&#34;]
                                )
                                / self.config.opti_thkobs_std
                            )
                            ** 2
                        )
                    else:
                        import tensorflow_addons as tfa

                        COST_H = 0.5 * tf.reduce_mean(
                            (
                                (
                                    self.thktargetprof
                                    - tfa.image.interpolate_bilinear(
                                        tf.expand_dims(
                                            tf.expand_dims(
                                                thk * self.iceflow_fieldbounds[&#34;thk&#34;],
                                                axis=0,
                                            ),
                                            axis=-1,
                                        ),
                                        self.jiptprof,
                                        indexing=&#34;ij&#34;,
                                    )[0, :, 0]
                                )
                                / self.thktargetprof_std
                            )
                            ** 2
                        )
                else:
                    COST_H = tf.Variable(0.0)

                # misfit divergence of the flux
                if (&#34;divfluxobs&#34; in self.config.opti_cost) | (
                    &#34;divfluxfcz&#34; in self.config.opti_cost
                ):

                    divflux = self.compute_divflux(
                        ubar,
                        vbar,
                        thk * self.iceflow_fieldbounds[&#34;thk&#34;],
                        self.dx,
                        self.dx,
                    )

                    if &#34;divfluxfcz&#34; in self.config.opti_cost:
                        ACT = self.icemaskobs &gt; 0.5
                        if i % 10 == 0:
                            # his does not need to be comptued any iteration as this is expensive
                            res = stats.linregress(
                                self.usurf[ACT], divflux[ACT]
                            )  # this is a linear regression (usually that&#39;s enough)
                        # or you may go for polynomial fit (more gl, but may leads to errors)
                        #  weights = np.polyfit(self.usurf[ACT],divflux[ACT], 2) 
                        divfluxtar = tf.where(
                            ACT, res.intercept + res.slope * self.usurf, 0.0
                        )
                    #                        divfluxtar = tf.where(ACT, np.poly1d(weights)(self.usurf) , 0.0 )

                    else:
                        divfluxtar = self.divfluxobs

                    ACT = self.icemaskobs &gt; 0.5
                    COST_D = 0.5 * tf.reduce_mean(
                        (
                            (divfluxtar[ACT] - divflux[ACT])
                            / self.config.opti_divfluxobs_std
                        )
                        ** 2
                    )

                else:
                    COST_D = tf.Variable(0.0)

                # misfit between top ice surfaces
                if &#34;usurf&#34; in self.config.opti_cost:
                    ACT = self.icemaskobs &gt; 0.5
                    COST_S = 0.5 * tf.reduce_mean(
                        (
                            (
                                usurf[ACT] * self.iceflow_fieldbounds[&#34;usurf&#34;]
                                - self.usurfobs[ACT]
                            )
                            / self.config.opti_usurfobs_std
                        )
                        ** 2
                    )
                else:
                    COST_S = tf.Variable(0.0)

                # force usurf = usurf - topg
                if &#34;topg&#34; in self.config.opti_cost:
                    ACT = self.icemaskobs == 1
                    COST_T = 10 ** 10 * tf.reduce_mean(
                        (
                            usurf[ACT] * self.iceflow_fieldbounds[&#34;usurf&#34;]
                            - thk[ACT] * self.iceflow_fieldbounds[&#34;thk&#34;]
                            - self.topg[ACT]
                        )
                        ** 2
                    )
                else:
                    COST_T = tf.Variable(0.0)

                # force zero thikness outisde the mask
                if &#34;icemask&#34; in self.config.opti_cost:
                    COST_O = 10 ** 10 * tf.math.reduce_mean(
                        tf.where(self.icemaskobs &gt; 0.5, 0.0, thk ** 2)
                    )
                else:
                    COST_O = tf.Variable(0.0)

                # Here one enforces non-negative ice thickness, and possibly zero-thickness in user-defined ice-free areas.
                if &#34;thk&#34; in self.config.opti_control:
                    COST_HPO = 10 ** 10 * tf.math.reduce_mean(
                        tf.where(thk &gt;= 0, 0.0, thk ** 2)
                    )
                else:
                    COST_HPO = tf.Variable(0.0)

                # # Make sur to keep reasonable values for strflowctrl
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    COST_STR = 0.5 * tf.reduce_mean(
                        (
                            (
                                strflowctrl * self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                                - self.config.opti_thr_strflowctrl
                            )
                            / self.config.opti_strflowctrl_std
                        )
                        ** 2
                    )
                else:
                    COST_STR = tf.Variable(0.0)

                # Here one adds a regularization terms for the ice thickness to the cost function
                if &#34;thk&#34; in self.config.opti_control:
                    dbdx = thk[:, 1:] - thk[:, :-1]
                    dbdx = (dbdx[1:, :] + dbdx[:-1, :]) / 2.0
                    dbdy = thk[1:, :] - thk[:-1, :]
                    dbdy = (dbdy[:, 1:] + dbdy[:, :-1]) / 2.0

                    if self.config.opti_smooth_anisotropy_factor == 1:
                        REGU_H = self.config.opti_regu_param_thk * (
                            tf.nn.l2_loss(dbdx) + tf.nn.l2_loss(dbdy)
                        )
                    else:
                        REGU_H = self.config.opti_regu_param_thk * (
                            tf.nn.l2_loss((dbdx * self.flowdirx + dbdy * self.flowdiry))
                            + self.config.opti_smooth_anisotropy_factor
                            * tf.nn.l2_loss(
                                (dbdx * self.flowdiry - dbdy * self.flowdirx)
                            )
                            - self.config.opti_convexity_weight
                            * tf.math.reduce_sum(thk)
                        )
                else:
                    REGU_H = tf.Variable(0.0)

                # Here one adds a regularization terms for strflowctrl to the cost function
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    dadx = tf.math.abs(strflowctrl[:, 1:] - strflowctrl[:, :-1])
                    dady = tf.math.abs(strflowctrl[1:, :] - strflowctrl[:-1, :])
                    dadx = tf.where(
                        (self.icemaskobs[:, 1:] &gt; 0.5)
                        &amp; (self.icemaskobs[:, :-1] &gt; 0.5),
                        dadx,
                        0.0,
                    )
                    dady = tf.where(
                        (self.icemaskobs[1:, :] &gt; 0.5)
                        &amp; (self.icemaskobs[:-1, :] &gt; 0.5),
                        dady,
                        0.0,
                    )
                    REGU_A = self.config.opti_regu_param_strflowctrl * (
                        tf.nn.l2_loss(dadx) + tf.nn.l2_loss(dady)
                    )
                else:
                    REGU_A = tf.Variable(0.0)

                # sum all component into the main cost function
                COST = (
                    COST_U
                    + COST_H
                    + COST_D
                    + COST_S
                    + COST_T
                    + COST_O
                    + COST_HPO
                    + COST_STR
                    + REGU_H
                    + REGU_A
                )

                vol = (
                    np.sum(thk * self.iceflow_fieldbounds[&#34;thk&#34;])
                    * (self.dx ** 2)
                    / 10 ** 9
                )

                if i % self.config.opti_output_freq == 0:
                    print(
                        &#34; OPTI, step %5.0f , ICE_VOL: %7.2f , COST_U: %7.2f , COST_H: %7.2f , COST_D : %7.2f , COST_S : %7.2f , REGU_H : %7.2f , REGU_A : %7.2f &#34;
                        % (
                            i,
                            vol,
                            COST_U.numpy(),
                            COST_H.numpy(),
                            COST_D.numpy(),
                            COST_S.numpy(),
                            REGU_H.numpy(),
                            REGU_A.numpy(),
                        )
                    )

                self.costs.append(
                    [
                        COST_U.numpy(),
                        COST_H.numpy(),
                        COST_D.numpy(),
                        COST_S.numpy(),
                        REGU_H.numpy(),
                        REGU_A.numpy(),
                    ]
                )

                var_to_opti = []
                if &#34;thk&#34; in self.config.opti_control:
                    var_to_opti.append(thk)
                if &#34;usurf&#34; in self.config.opti_control:
                    var_to_opti.append(usurf)
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    var_to_opti.append(strflowctrl)

                # Compute gradient of COST w.r.t. X
                grads = tf.Variable(t.gradient(COST, var_to_opti))

                # this serve to restict the optimization of controls to the mask
                for ii in range(grads.shape[0]):
                    grads[ii].assign(tf.where((self.icemaskobs &gt; 0.5), grads[ii], 0))

                # One step of descent -&gt; this will update input variable X
                optimizer.apply_gradients(
                    zip([grads[i] for i in range(grads.shape[0])], var_to_opti)
                )

                # get back optimized variables in the pool of igm.variables
                if &#34;thk&#34; in self.config.opti_control:
                    self.thk.assign(thk * self.iceflow_fieldbounds[&#34;thk&#34;])
                    self.thk.assign(tf.where(self.thk &lt; 0.01, 0, self.thk))
                if &#34;strflowctrl&#34; in self.config.opti_control:
                    self.strflowctrl.assign(
                        strflowctrl * self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                    )
                if &#34;usurf&#34; in self.config.opti_control:
                    self.usurf.assign(usurf * self.iceflow_fieldbounds[&#34;usurf&#34;])

                self.divflux = self.compute_divflux(
                    self.ubar, self.vbar, self.thk, self.dx, self.dx
                )

                self.compute_rms_std_optimization(i)

                self.tcomp[&#34;Optimize&#34;][-1] -= time.time()
                self.tcomp[&#34;Optimize&#34;][-1] *= -1

                if i % self.config.opti_output_freq == 0:
                    self.update_plot_inversion(i, self.config.plot_live)
                    self.update_ncdf_optimize(i)
                # self.update_plot_profiles(i,plot_live)

                # stopping criterion: stop if the cost no longer decrease
                # if i&gt;self.config.opti_nbitmin:
                #     cost = [c[0] for c in costs]
                #     if np.mean(cost[-10:])&gt;np.mean(cost[-20:-10]):
                #         break;

        # now that the ice thickness is optimized, we can fix the bed once for all!
        self.topg.assign(self.usurf - self.thk)

        self.output_ncdf_optimize_final()

        self.plot_cost_functions(self.costs, self.config.plot_live)

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;costs.dat&#34;),
            np.stack(self.costs),
            fmt=&#34;%.10f&#34;,
            header=&#34;        COST_U        COST_H      COST_D       COST_S       REGU_H       REGU_A          HPO &#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;rms_std.dat&#34;),
            np.stack(
                [
                    self.rmsthk,
                    self.stdthk,
                    self.rmsvel,
                    self.stdvel,
                    self.rmsdiv,
                    self.stddiv,
                    self.rmsusurf,
                    self.stdusurf,
                ],
                axis=-1,
            ),
            fmt=&#34;%.10f&#34;,
            header=&#34;        rmsthk      stdthk       rmsvel       stdvel       rmsdiv       stddiv       rmsusurf       stdusurf&#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;strflowctrl.dat&#34;),
            np.array(
                [
                    np.mean(self.strflowctrl[self.icemaskobs &gt; 0.5]),
                    np.std(self.strflowctrl[self.icemaskobs &gt; 0.5]),
                ]
            ),
            fmt=&#34;%.3f&#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;volume.dat&#34;),
            np.array([np.sum(self.thk) * self.dx * self.dx / (10 ** 9)]),
            fmt=&#34;%.3f&#34;,
        )

        np.savetxt(
            os.path.join(self.config.working_dir, &#34;tcompoptimize.dat&#34;),
            np.array([np.sum([f for f in self.tcomp[&#34;Optimize&#34;]])]),
            fmt=&#34;%.3f&#34;,
        )

    def run_opti(self):

        self.initialize()

        with tf.device(self.device_name):

            self.load_ncdf_data(self.config.observation_file)

            self.initialize_fields()

            self.initialize_iceflow()

            self.optimize()

    def compute_rms_std_optimization(self, i):
        &#34;&#34;&#34;
        compute_std_optimization
        &#34;&#34;&#34;

        I = self.icemaskobs == 1

        if i == 0:
            self.rmsthk = []
            self.stdthk = []
            self.rmsvel = []
            self.stdvel = []
            self.rmsusurf = []
            self.stdusurf = []
            self.rmsdiv = []
            self.stddiv = []

        if hasattr(self, &#34;profile&#34;) | hasattr(self, &#34;thkobs&#34;):
            if self.config.thk_profiles_file == &#34;&#34;:
                ACT = ~tf.math.is_nan(self.thkobs)
                if np.sum(ACT) == 0:
                    self.rmsthk.append(0)
                    self.stdthk.append(0)
                else:
                    self.rmsthk.append(np.nanmean(self.thk[ACT] - self.thkobs[ACT]))
                    self.stdthk.append(np.nanstd(self.thk[ACT] - self.thkobs[ACT]))

            else:
                fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))
                thkdiff = np.concatenate(
                    [
                        (fthk(p[:, 1], p[:, 2], grid=False) - p[:, 3])
                        for p in self.profile
                    ]
                )
                self.rmsthk.append(np.mean(thkdiff))
                self.stdthk.append(np.std(thkdiff))
        else:
            self.rmsthk.append(0)
            self.stdthk.append(0)

        if hasattr(self, &#34;uvelsurfobs&#34;):
            velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf).numpy()
            velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs).numpy()
            ACT = ~np.isnan(velsurfobs_mag)

            self.rmsvel.append(
                np.mean(
                    velsurf_mag[(I &amp; ACT).numpy()] - velsurfobs_mag[(I &amp; ACT).numpy()]
                )
            )
            self.stdvel.append(
                np.std(
                    velsurf_mag[(I &amp; ACT).numpy()] - velsurfobs_mag[(I &amp; ACT).numpy()]
                )
            )
        else:
            self.rmsvel.append(0)
            self.stdvel.append(0)

        if hasattr(self, &#34;divfluxobs&#34;):
            self.rmsdiv.append(np.mean(self.divfluxobs[I] - self.divflux[I]))
            self.stddiv.append(np.std(self.divfluxobs[I] - self.divflux[I]))
        else:
            self.rmsdiv.append(0)
            self.stddiv.append(0)

        if hasattr(self, &#34;usurfobs&#34;):
            self.rmsusurf.append(np.mean(self.usurf[I] - self.usurfobs[I]))
            self.stdusurf.append(np.std(self.usurf[I] - self.usurfobs[I]))
        else:
            self.rmsusurf.append(0)
            self.stdusurf.append(0)

    def update_ncdf_optimize(self, it):
        &#34;&#34;&#34;
        Initialize and write the ncdf optimze file
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Initialize  and write NCDF output Files&#34;)

        if &#34;arrhenius&#34; in self.config.opti_vars_to_save:
            self.arrhenius = tf.where(
                self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
                self.strflowctrl,
                self.config.opti_thr_strflowctrl,
            )

        if &#34;slidingco&#34; in self.config.opti_vars_to_save:
            self.slidingco = tf.where(
                self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
                0,
                self.strflowctrl - self.config.opti_thr_strflowctrl,
            )

        if &#34;topg&#34; in self.config.opti_vars_to_save:
            self.topg.assign(self.usurf - self.thk)

        if &#34;velsurf_mag&#34; in self.config.opti_vars_to_save:
            self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

        if &#34;velsurfobs_mag&#34; in self.config.opti_vars_to_save:
            self.velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs)

        if it == 0:

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;optimize.nc&#34;),
                &#34;w&#34;,
                format=&#34;NETCDF4&#34;,
            )

            nc.createDimension(&#34;iterations&#34;, None)
            E = nc.createVariable(&#34;iterations&#34;, dtype(&#34;float32&#34;).char, (&#34;iterations&#34;,))
            E.units = &#34;None&#34;
            E.long_name = &#34;iterations&#34;
            E.axis = &#34;ITERATIONS&#34;
            E[0] = it

            nc.createDimension(&#34;y&#34;, len(self.y))
            E = nc.createVariable(&#34;y&#34;, dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;y&#34;
            E.axis = &#34;Y&#34;
            E[:] = self.y.numpy()

            nc.createDimension(&#34;x&#34;, len(self.x))
            E = nc.createVariable(&#34;x&#34;, dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;x&#34;
            E.axis = &#34;X&#34;
            E[:] = self.x.numpy()

            for var in self.config.opti_vars_to_save:

                E = nc.createVariable(
                    var, dtype(&#34;float32&#34;).char, (&#34;iterations&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                # E.long_name = self.var_info[var][0]
                # E.units = self.var_info[var][1]
                E[0, :, :] = vars(self)[var].numpy()

            nc.close()

        else:

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;optimize.nc&#34;),
                &#34;a&#34;,
                format=&#34;NETCDF4&#34;,
            )

            d = nc.variables[&#34;iterations&#34;][:].shape[0]

            nc.variables[&#34;iterations&#34;][d] = it

            for var in self.config.opti_vars_to_save:
                nc.variables[var][d, :, :] = vars(self)[var].numpy()

            nc.close()

    def output_ncdf_optimize_final(self):
        &#34;&#34;&#34;
        Write final geology after optimizing
        &#34;&#34;&#34;

        if self.config.verbosity == 1:
            print(&#34;Write the final geology ncdf file after optimization&#34;)

        nc = Dataset(
            os.path.join(self.config.working_dir, self.config.observation_file), &#34;r&#34;
        )
        varori = [v for v in nc.variables]
        nc.close()

        varori.remove(&#34;x&#34;)
        varori.remove(&#34;y&#34;)
        if not &#34;strflowctrl&#34; in varori:
            varori.append(&#34;strflowctrl&#34;)
        if not &#34;thk&#34; in varori:
            varori.append(&#34;thk&#34;)
        if not &#34;usurf&#34; in varori:
            varori.append(&#34;usurf&#34;)
        if not &#34;icemask&#34; in varori:
            varori.append(&#34;icemask&#34;)

        self.arrhenius = tf.where(
            self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
            self.strflowctrl,
            self.config.opti_thr_strflowctrl,
        )
        self.slidingco = tf.where(
            self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
            0,
            self.strflowctrl - self.config.opti_thr_strflowctrl,
        )
        self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

        self.icemask = tf.where(
            self.thk &gt; 1.0, tf.ones_like(self.thk), tf.zeros_like(self.thk)
        )

        if os.path.isfile(os.path.join(self.config.working_dir, &#34;geology.nc&#34;)):
            filename = &#34;geology-optimized.nc&#34;
        else:
            filename = &#34;geology.nc&#34;

        nc = Dataset(
            os.path.join(self.config.working_dir, filename),
            &#34;w&#34;,
            format=&#34;NETCDF4&#34;,
        )

        nc.createDimension(&#34;y&#34;, len(self.y))
        E = nc.createVariable(&#34;y&#34;, dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
        E.units = &#34;m&#34;
        E.long_name = &#34;y&#34;
        E.axis = &#34;Y&#34;
        E[:] = self.y.numpy()

        nc.createDimension(&#34;x&#34;, len(self.x))
        E = nc.createVariable(&#34;x&#34;, dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
        E.units = &#34;m&#34;
        E.long_name = &#34;x&#34;
        E.axis = &#34;X&#34;
        E[:] = self.x.numpy()

        for var in varori:

            if hasattr(self, var):
                E = nc.createVariable(var, dtype(&#34;float32&#34;).char, (&#34;y&#34;, &#34;x&#34;))
                #                E.long_name = self.var_info[var][0]
                #                E.units     = self.var_info[var][1]
                E[:, :] = vars(self)[var].numpy()

        nc.close()

    def plot_cost_functions(self, costs, plot_live):

        costs = np.stack(costs)

        for i in range(costs.shape[1]):
            costs[:, i] -= np.min(costs[:, i])
            costs[:, i] /= np.max(costs[:, i])

        fig = plt.figure(figsize=(10, 10))
        plt.plot(costs[:, 0], &#34;-k&#34;, label=&#34;COST U&#34;)
        plt.plot(costs[:, 1], &#34;-r&#34;, label=&#34;COST H&#34;)
        plt.plot(costs[:, 2], &#34;-b&#34;, label=&#34;COST D&#34;)
        plt.plot(costs[:, 3], &#34;-g&#34;, label=&#34;COST S&#34;)
        plt.plot(costs[:, 4], &#34;--c&#34;, label=&#34;REGU H&#34;)
        plt.plot(costs[:, 5], &#34;--m&#34;, label=&#34;REGU A&#34;)
        plt.ylim(0, 1)
        plt.legend()

        if plot_live:
            plt.show()
        else:
            plt.savefig(
                os.path.join(self.config.working_dir, &#34;convergence.png&#34;), pad_inches=0
            )
            plt.close(&#34;all&#34;)

    def update_plot_inversion(self, i, plot_live):
        &#34;&#34;&#34;
        Plot thickness, velocity, mand slidingco
        &#34;&#34;&#34;

        if self.config.plot_result:

            if hasattr(self, &#34;uvelsurfobs&#34;):
                velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs).numpy()
            else:
                velsurfobs_mag = np.zeros_like(self.thk.numpy())

            if hasattr(self, &#34;usurfobs&#34;):
                usurfobs = self.usurfobs
            else:
                usurfobs = np.zeros_like(self.thk.numpy())

            ########################################################

            fig = plt.figure(figsize=(18, 13))

            #########################################################

            ax = fig.add_subplot(2, 3, 1)
            extent = [self.x[0], self.x[-1], self.y[0], self.y[-1]]
            im1 = ax.imshow(self.thk, origin=&#34;lower&#34;, extent=extent, vmin=0, vmax=800)
            plt.colorbar(im1)

            if hasattr(self, &#34;profile&#34;):
                fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))
                for j, p in enumerate(self.profile):
                    if j &gt; 0:
                        meanfitprofile = np.mean(
                            fthk(p[:, 1], p[:, 2], grid=False) - p[:, 3]
                        )
                        ax.scatter(p[:, 1], p[:, 2], c=&#34;k&#34;, s=1)
                        ax.text(
                            np.mean(p[:, 1]),
                            np.mean(p[:, 2]),
                            str(int(meanfitprofile)),
                            fontsize=15,
                        )

            ax.set_title(
                &#34;THK, RMS : &#34;
                + str(int(self.rmsthk[-1]))
                + &#34;, STD : &#34;
                + str(int(self.stdthk[-1])),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            #########################################################

            ax = fig.add_subplot(2, 3, 2)
            velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf).numpy()
            im1 = ax.imshow(
                velsurf_mag, origin=&#34;lower&#34;, vmin=0, vmax=np.nanmax(velsurfobs_mag)
            )
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(
                &#34;MOD VEL, RMS : &#34;
                + str(int(self.rmsvel[-1]))
                + &#34;, STD : &#34;
                + str(int(self.stdvel[-1])),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            ########################################################

            ax = fig.add_subplot(2, 3, 3)
            im1 = ax.imshow(self.divflux, origin=&#34;lower&#34;, vmin=-15, vmax=5)
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(
                &#34;MOD DIV, RMS : %5.1f , STD : %5.1f&#34;
                % (self.rmsdiv[-1], self.stddiv[-1]),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            #########################################################

            ax = fig.add_subplot(2, 3, 4)
            im1 = ax.imshow(self.usurf - usurfobs, origin=&#34;lower&#34;, vmin=-10, vmax=10)
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(
                &#34;DELTA USURF, RMS : %5.1f , STD : %5.1f&#34;
                % (self.rmsusurf[-1], self.stdusurf[-1]),
                size=15,
            )
            ax.axis(&#34;off&#34;)

            ########################################################

            ax = fig.add_subplot(2, 3, 5)
            im1 = ax.imshow(
                velsurfobs_mag, origin=&#34;lower&#34;, vmin=0, vmax=np.nanmax(velsurfobs_mag)
            )
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(&#34;OBS VEL (TARGET)&#34;, size=15)
            ax.axis(&#34;off&#34;)

            #######################################################

            ax = fig.add_subplot(2, 3, 6)
            im1 = ax.imshow(self.strflowctrl, origin=&#34;lower&#34;, vmin=50, vmax=110)
            plt.colorbar(im1, format=&#34;%.2f&#34;)
            ax.set_title(&#34;strflowctrl&#34;, size=15)
            ax.axis(&#34;off&#34;)

            #########################################################

            plt.tight_layout()

            if plot_live:
                plt.show()
            else:
                plt.savefig(
                    os.path.join(
                        self.config.working_dir, &#34;resu-opti-&#34; + str(i).zfill(4) + &#34;.png&#34;
                    ),
                    pad_inches=0,
                )
                plt.close(&#34;all&#34;)

    def plot_opti_diff(self, file, vari, plot_live=True):
        &#34;&#34;&#34;
        Plot thickness, velocity, mand slidingco
        &#34;&#34;&#34;

        from matplotlib import cm
        from mpl_toolkits.axes_grid1 import make_axes_locatable
        import matplotlib.pyplot as plt
        import xarray as xr

        data = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[vari]

        minvar = np.min(data[-1])
        minvardiff = minvar / 5
        maxvar = np.max(data[-1])
        maxvardiff = maxvar / 5

        if vari == &#34;divflux&#34;:
            maxvar = 10
            maxvardiff = 10
            minvar = -10
            minvardiff = -10

        if vari == &#34;thk&#34;:
            maxvardiff = maxvar / 5
            minvardiff = -maxvar / 5

        if vari == &#34;usurf&#34;:
            maxvardiff = 10
            minvardiff = -10

        extent = [self.x[0], self.x[-1], self.y[0], self.y[-1]]

        dicc = {}
        dicc[&#34;thk&#34;] = &#34;thk&#34;
        dicc[&#34;velsurf_mag&#34;] = &#34;vel&#34;
        dicc[&#34;usurf&#34;] = &#34;usurf&#34;
        dicc[&#34;divflux&#34;] = &#34;div&#34;

        ########################################################

        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 6), dpi=200)

        if vari in [&#34;velsurf_mag&#34;]:  # ,&#39;thk&#39;
            rms = str(int(vars(self)[&#34;rms&#34; + dicc[vari]][0]))
            std = str(int(vars(self)[&#34;std&#34; + dicc[vari]][0]))
            comp = &#34; (RMS: &#34; + rms + &#34;, STD: &#34; + std + &#34;)&#34;
        else:
            comp = &#34;&#34;

        ax1.set_title(&#34;Initial &#34; + vari + comp)
        im1 = ax1.imshow(
            np.where(self.thk &gt; 1, data[0], np.nan),
            origin=&#34;lower&#34;,
            extent=extent,
            vmin=minvar,
            vmax=maxvar,
            cmap=cm.get_cmap(&#34;viridis&#34;, 8),
        )
        divider = make_axes_locatable(ax1)
        cax1 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
        cbar1 = plt.colorbar(im1, format=&#34;%.0f&#34;, cax=cax1, orientation=&#34;vertical&#34;)
        ax1.axis(&#34;off&#34;)

        if vari in [&#34;velsurf_mag&#34;, &#34;thk&#34;]:
            rms = str(int(vars(self)[&#34;rms&#34; + dicc[vari]][-1]))
            std = str(int(vars(self)[&#34;std&#34; + dicc[vari]][-1]))
            comp = &#34; (RMS: &#34; + rms + &#34;, STD: &#34; + std + &#34;)&#34;
        else:
            comp = &#34;&#34;

        ax2.set_title(&#34;Optimized &#34; + vari + comp)
        im2 = ax2.imshow(
            np.where(self.thk &gt; 1, data[-1], np.nan),
            origin=&#34;lower&#34;,
            extent=extent,
            vmin=minvar,
            vmax=maxvar,
            cmap=cm.get_cmap(&#34;viridis&#34;, 8),
        )
        divider = make_axes_locatable(ax2)
        cax2 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
        cbar2 = plt.colorbar(im2, format=&#34;%.0f&#34;, cax=cax2, orientation=&#34;vertical&#34;)
        ax2.axis(&#34;off&#34;)

        if vari == &#34;velsurf_mag&#34;:
            velsurfobs_mag = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[&#34;velsurfobs_mag&#34;]
            tod = np.where(self.thk &gt; 1, velsurfobs_mag[0], np.nan)
            ax3.set_title(&#34;Target&#34;)
            im3 = ax3.imshow(
                tod,
                origin=&#34;lower&#34;,
                extent=extent,
                vmin=minvar,
                vmax=maxvar,
                cmap=cm.get_cmap(&#34;viridis&#34;, 8),
            )
            divider = make_axes_locatable(ax3)
            cax3 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
            cbar3 = plt.colorbar(im3, format=&#34;%.0f&#34;, cax=cax3, orientation=&#34;vertical&#34;)
            ax3.axis(&#34;off&#34;)
        else:
            tod = np.where(self.thk &gt; 1, data[-1] - data[0], np.nan)
            ax3.set_title(&#34;Optimized - Initial&#34;)
            im3 = ax3.imshow(
                tod,
                origin=&#34;lower&#34;,
                vmin=minvardiff,
                vmax=maxvardiff,
                cmap=cm.get_cmap(&#34;RdBu&#34;, 10),
            )
            divider = make_axes_locatable(ax3)
            cax3 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
            cbar3 = plt.colorbar(im3, format=&#34;%.0f&#34;, cax=cax3, orientation=&#34;vertical&#34;)
            ax3.axis(&#34;off&#34;)

        #########################################################

        plt.tight_layout()

        if plot_live:
            plt.show()
        else:
            plt.savefig(
                os.path.join(self.config.working_dir, &#34;resu-opti-&#34; + vari + &#34;-.png&#34;),
                pad_inches=0,
            )
            plt.close(&#34;all&#34;)

    def update_plot_profiles(self, i, plot_live):

        from scipy.interpolate import RectBivariateSpline

        fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))

        N = len(self.profile)
        N1 = int(np.sqrt(N)) + 1
        N2 = N1
        fig, axs = plt.subplots(N1, N2, figsize=(N1 * 10, N2 * 5))
        #            fig, axs = plt.subplots(N,1,figsize=(10,N*4))
        for j, p in enumerate(self.profile):
            if j &gt; 0:
                jj = j // N1
                ii = j % N1
                axs[ii, jj].set_title(&#34; PROFILE N° : &#34; + str(j))
                axs[ii, jj].plot(p[:, 0], p[:, 3], &#34;-k&#34;)
                axs[ii, jj].plot(p[:, 0], fthk(p[:, 1], p[:, 2], grid=False), &#34;-b&#34;)
                axs[ii, jj].axis(&#34;equal&#34;)
        plt.tight_layout()

        if plot_live:
            plt.show()
        else:
            plt.savefig(
                os.path.join(
                    self.config.working_dir, &#34;S1-pro-&#34; + str(i).zfill(4) + &#34;.png&#34;
                ),
                pad_inches=0,
            )
            plt.close(&#34;all&#34;)

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              PLOT
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def read_config_param_plot(self):

        self.parser.add_argument(
            &#34;--varplot&#34;,
            type=str,
            default=&#34;velbar_mag&#34;,
            help=&#34;variable to plot&#34;,
        )
        self.parser.add_argument(
            &#34;--varplot_max&#34;,
            type=float,
            default=500,
            help=&#34;maximum value of the varplot variable used to adjust the scaling of the colorbar&#34;,
        )

    def update_plot(self, force=False):
        &#34;&#34;&#34;
        Plot thickness, velocity, mass balance
        &#34;&#34;&#34;

        if force | (self.saveresult &amp; self.config.plot_result):

            firstime = False
            if not hasattr(self, &#34;already_called_update_plot&#34;):
                self.already_called_update_plot = True
                self.tcomp[&#34;Outputs plot&#34;] = []
                firstime = True

            self.tcomp[&#34;Outputs plot&#34;].append(time.time())

            if self.config.varplot == &#34;velbar_mag&#34;:
                self.velbar_mag = self.getmag(self.ubar, self.vbar)

            if firstime:

                self.fig = plt.figure(dpi=200)
                self.ax = self.fig.add_subplot(1, 1, 1)
                self.ax.axis(&#34;off&#34;)
                im = self.ax.imshow(
                    vars(self)[self.config.varplot],
                    origin=&#34;lower&#34;,
                    cmap=&#34;viridis&#34;,
                    vmin=0,
                    vmax=self.config.varplot_max,
                )
                self.ax.set_title(&#34;YEAR : &#34; + str(self.t.numpy()), size=15)
                self.cbar = plt.colorbar(im)

            else:
                im = self.ax.imshow(
                    vars(self)[self.config.varplot],
                    origin=&#34;lower&#34;,
                    cmap=&#34;viridis&#34;,
                    vmin=0,
                    vmax=self.config.varplot_max,
                )
                self.ax.set_title(&#34;YEAR : &#34; + str(self.t.numpy()), size=15)

            if self.config.plot_live:
                clear_output(wait=True)
                display(self.fig)

            else:
                plt.savefig(
                    os.path.join(
                        self.config.working_dir,
                        self.config.varplot
                        + &#34;-&#34;
                        + str(self.t.numpy()).zfill(4)
                        + &#34;.png&#34;,
                    ),
                    bbox_inches=&#34;tight&#34;,
                    pad_inches=0.2,
                )

            self.tcomp[&#34;Outputs plot&#34;][-1] -= time.time()
            self.tcomp[&#34;Outputs plot&#34;][-1] *= -1

    def plot_computational_pie(self):
        &#34;&#34;&#34;
        Plot to the computational time of each model components in a pie
        &#34;&#34;&#34;

        def make_autopct(values):
            def my_autopct(pct):
                total = sum(values)
                val = int(round(pct * total / 100.0))
                return &#34;{:.0f}&#34;.format(val)

            return my_autopct

        total = []
        name = []

        for i, key in enumerate(self.tcomp.keys()):
            if not key == &#34;All&#34;:
                total.append(np.sum(self.tcomp[key][1:]))
                name.append(key)

        sumallindiv = np.sum(total)

        fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(aspect=&#34;equal&#34;), dpi=200)
        wedges, texts, autotexts = ax.pie(
            total, autopct=make_autopct(total), textprops=dict(color=&#34;w&#34;)
        )
        ax.legend(
            wedges,
            name,
            title=&#34;Model components&#34;,
            loc=&#34;center left&#34;,
            bbox_to_anchor=(1, 0, 0.5, 1),
        )
        plt.setp(autotexts, size=8, weight=&#34;bold&#34;)
        #    ax.set_title(&#34;Matplotlib bakery: A pie&#34;)
        plt.tight_layout()
        plt.savefig(
            os.path.join(self.config.working_dir, &#34;PIE-COMPUTATIONAL.png&#34;), pad_inches=0
        )
        plt.close(&#34;all&#34;)

    def animate_result(self, file, vari, save=False):

        from IPython.display import HTML, display
        import xarray as xr
        from matplotlib import pyplot as plt, animation

        data = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[vari]

        minvar = np.min(data)
        maxvar = np.max(data)

        if vari == &#34;divflux&#34;:
            maxvar = 10
            minvar = -10

        thk = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[&#34;thk&#34;]

        data = xr.where(thk &gt; 1, data, np.nan)

        ratio = self.y.shape[0] / self.x.shape[0]

        fig, ax = plt.subplots(figsize=(6, 6 * ratio), dpi=200)

        # Plot the initial frame.
        cax = data[0, :, :].plot(
            add_colorbar=True, cmap=plt.cm.get_cmap(&#34;jet&#34;, 20), vmin=minvar, vmax=maxvar
        )
        ax.axis(&#34;off&#34;)
        ax.axis(&#34;equal&#34;)

        # dont&#39; show the original frame
        plt.close()

        def animate(i):
            cax.set_array(data[i, :, :].values.flatten())
            if &#34;iterations&#34; in data.coords.variables:
                ax.set_title(&#34;It = &#34; + str(data.coords[&#34;iterations&#34;].values[i])[:13])
            else:
                ax.set_title(&#34;Time = &#34; + str(data.coords[&#34;time&#34;].values[i])[:13])

        ani = animation.FuncAnimation(
            fig, animate, frames=data.shape[0], interval=100
        )  # interval in ms between frames

        HTML(ani.to_html5_video())

        # optionally the animation can be saved in avi
        if save:
            ani.save(file.split(&#34;.&#34;)[0] + &#34;-&#34; + vari + &#34;.mp4&#34;)

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              PRINT INFO
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def print_info(self):
        &#34;&#34;&#34;
        This serves to print key info on the fly during computation
        &#34;&#34;&#34;
        if self.saveresult:
            print(
                &#34;IGM %s : Iterations = %6.0f  |  Time = %8.0f  |  DT = %7.2f  |  Ice Volume (km^3) = %10.2f &#34;
                % (
                    datetime.datetime.now().strftime(&#34;%H:%M:%S&#34;),
                    self.it,
                    self.t,
                    self.dt_target,
                    np.sum(self.thk) * (self.dx ** 2) / 10 ** 9,
                )
            )

    def print_comp_info_live(self):
        &#34;&#34;&#34;
        This serves to print computational info on the fly during computation
        &#34;&#34;&#34;
        if self.saveresult:
            for key in self.tcomp.keys():
                CELA = (
                    key,
                    np.mean(self.tcomp[key][2:]),
                    np.sum(self.tcomp[key][2:]),
                    len(self.tcomp[key][2:]),
                )
                print(
                    &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it  : %8.0f&#34;
                    % CELA
                )

    def print_all_comp_info(self):
        &#34;&#34;&#34;
        This serves to print computational info report
        &#34;&#34;&#34;

        print(&#34;Computational statistics report:&#34;)
        with open(
            os.path.join(self.config.working_dir, &#34;computational-statistics.txt&#34;), &#34;w&#34;
        ) as f:
            for key in self.tcomp.keys():
                CELA = (
                    key,
                    np.mean(self.tcomp[key][2:]),
                    np.sum(self.tcomp[key][2:]),
                    len(self.tcomp[key][2:]),
                )
                print(
                    &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it : %8.0f&#34;
                    % CELA,
                    file=f,
                )
                print(
                    &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it  : %8.0f&#34;
                    % CELA
                )

    ####################################################################################
    ####################################################################################
    ####################################################################################
    #                              RUN
    ####################################################################################
    ####################################################################################
    ####################################################################################

    def run(self):

        self.initialize()

        with tf.device(self.device_name):

            self.load_ncdf_data(self.config.geology_file)

            self.initialize_fields()

            if len(self.config.restartingfile) &gt; 0:
                self.restart(-1)

            self.initialize_iceflow()

            self.update_climate()

            self.update_smb()

            if self.config.optimize:
                self.optimize()

            self.update_iceflow()

            self.update_ncdf_ex()

            self.update_ncdf_ts()

            if self.config.vel3d_active:
                self.init_3dvel()

            self.print_info()

            while self.t.numpy() &lt; self.config.tend:

                self.tcomp[&#34;All&#34;].append(time.time())

                if self.config.vel3d_active:
                    self.update_3dvel()

                self.update_climate()

                self.update_smb()

                self.update_iceflow()

                self.update_t_dt()

                self.update_thk()

                if self.config.update_topg:
                    self.update_topg()

                self.update_ncdf_ex()

                self.update_ncdf_ts()

                self.update_plot()

                self.print_info()

                self.tcomp[&#34;All&#34;][-1] -= time.time()
                self.tcomp[&#34;All&#34;][-1] *= -1

        self.print_all_comp_info()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="igm.igm.animate_result"><code class="name flex">
<span>def <span class="ident">animate_result</span></span>(<span>self, file, vari, save=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_result(self, file, vari, save=False):

    from IPython.display import HTML, display
    import xarray as xr
    from matplotlib import pyplot as plt, animation

    data = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[vari]

    minvar = np.min(data)
    maxvar = np.max(data)

    if vari == &#34;divflux&#34;:
        maxvar = 10
        minvar = -10

    thk = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[&#34;thk&#34;]

    data = xr.where(thk &gt; 1, data, np.nan)

    ratio = self.y.shape[0] / self.x.shape[0]

    fig, ax = plt.subplots(figsize=(6, 6 * ratio), dpi=200)

    # Plot the initial frame.
    cax = data[0, :, :].plot(
        add_colorbar=True, cmap=plt.cm.get_cmap(&#34;jet&#34;, 20), vmin=minvar, vmax=maxvar
    )
    ax.axis(&#34;off&#34;)
    ax.axis(&#34;equal&#34;)

    # dont&#39; show the original frame
    plt.close()

    def animate(i):
        cax.set_array(data[i, :, :].values.flatten())
        if &#34;iterations&#34; in data.coords.variables:
            ax.set_title(&#34;It = &#34; + str(data.coords[&#34;iterations&#34;].values[i])[:13])
        else:
            ax.set_title(&#34;Time = &#34; + str(data.coords[&#34;time&#34;].values[i])[:13])

    ani = animation.FuncAnimation(
        fig, animate, frames=data.shape[0], interval=100
    )  # interval in ms between frames

    HTML(ani.to_html5_video())

    # optionally the animation can be saved in avi
    if save:
        ani.save(file.split(&#34;.&#34;)[0] + &#34;-&#34; + vari + &#34;.mp4&#34;)</code></pre>
</details>
</dd>
<dt id="igm.igm.compute_divflux"><code class="name flex">
<span>def <span class="ident">compute_divflux</span></span>(<span>self, u, v, h, dx, dy)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="upwind-computation-of-the-divergence-of-the-flux-du-hdx-dv-hdy">upwind computation of the divergence of the flux : d(u h)/dx + d(v h)/dy</h1>
<h1 id="first-u-and-v-are-computed-on-the-staggered-grid-ie-cell-edges">First, u and v are computed on the staggered grid (i.e. cell edges)</h1>
<h1 id="second-one-extend-h-horizontally-by-a-cell-layer-on-any-bords-assuming-same-value">Second, one extend h horizontally by a cell layer on any bords (assuming same value)</h1>
<h1 id="third-one-compute-the-flux-on-the-staggered-grid-slecting-upwind-quantities">Third, one compute the flux on the staggered grid slecting upwind quantities</h1>
<h1 id="last-computing-the-divergence-on-the-staggered-grid-yields-values-def-on-the-original-grid">Last, computing the divergence on the staggered grid yields values def on the original grid</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.function()
def compute_divflux(self, u, v, h, dx, dy):
    &#34;&#34;&#34;
    #   upwind computation of the divergence of the flux : d(u h)/dx + d(v h)/dy
    #   First, u and v are computed on the staggered grid (i.e. cell edges)
    #   Second, one extend h horizontally by a cell layer on any bords (assuming same value)
    #   Third, one compute the flux on the staggered grid slecting upwind quantities
    #   Last, computing the divergence on the staggered grid yields values def on the original grid
    &#34;&#34;&#34;

    ## Compute u and v on the staggered grid
    u = tf.concat(
        [u[:, 0:1], 0.5 * (u[:, :-1] + u[:, 1:]), u[:, -1:]], 1
    )  # has shape (ny,nx+1)
    v = tf.concat(
        [v[0:1, :], 0.5 * (v[:-1, :] + v[1:, :]), v[-1:, :]], 0
    )  # has shape (ny+1,nx)

    # Extend h with constant value at the domain boundaries
    Hx = tf.pad(h, [[0, 0], [1, 1]], &#34;CONSTANT&#34;)  # has shape (ny,nx+2)
    Hy = tf.pad(h, [[1, 1], [0, 0]], &#34;CONSTANT&#34;)  # has shape (ny+2,nx)

    ## Compute fluxes by selcting the upwind quantities
    Qx = u * tf.where(u &gt; 0, Hx[:, :-1], Hx[:, 1:])  # has shape (ny,nx+1)
    Qy = v * tf.where(v &gt; 0, Hy[:-1, :], Hy[1:, :])  # has shape (ny+1,nx)

    ## Computation of the divergence, final shape is (ny,nx)
    return (Qx[:, 1:] - Qx[:, :-1]) / dx + (Qy[1:, :] - Qy[:-1, :]) / dy</code></pre>
</details>
</dd>
<dt id="igm.igm.compute_flow_direction_for_anisotropic_smoothing"><code class="name flex">
<span>def <span class="ident">compute_flow_direction_for_anisotropic_smoothing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>compute_flow_direction_for_anisotropic_smoothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_flow_direction_for_anisotropic_smoothing(self):
    &#34;&#34;&#34;
    compute_flow_direction_for_anisotropic_smoothing
    &#34;&#34;&#34;

    uvelsurfobs = tf.where(tf.math.is_nan(self.uvelsurfobs), 0.0, self.uvelsurfobs)
    vvelsurfobs = tf.where(tf.math.is_nan(self.vvelsurfobs), 0.0, self.vvelsurfobs)

    self.flowdirx = (
        uvelsurfobs[1:, 1:]
        + uvelsurfobs[:-1, 1:]
        + uvelsurfobs[1:, :-1]
        + uvelsurfobs[:-1, :-1]
    ) / 4.0
    self.flowdiry = (
        vvelsurfobs[1:, 1:]
        + vvelsurfobs[:-1, 1:]
        + vvelsurfobs[1:, :-1]
        + vvelsurfobs[:-1, :-1]
    ) / 4.0

    from scipy.ndimage import gaussian_filter

    self.flowdirx = gaussian_filter(self.flowdirx, 3, mode=&#34;constant&#34;)
    self.flowdiry = gaussian_filter(self.flowdiry, 3, mode=&#34;constant&#34;)

    # Same as gaussian filter above but for tensorflow is (NOT TESTED)
    # import tensorflow_addons as tfa
    # self.flowdirx.assign( tfa.image.gaussian_filter2d( self.flowdirx , sigma=3, filter_shape=100, padding=&#34;CONSTANT&#34;) )

    self.flowdirx /= self.getmag(self.flowdirx, self.flowdiry)
    self.flowdiry /= self.getmag(self.flowdirx, self.flowdiry)

    self.flowdirx = tf.where(tf.math.is_nan(self.flowdirx), 0.0, self.flowdirx)
    self.flowdiry = tf.where(tf.math.is_nan(self.flowdiry), 0.0, self.flowdiry)

    # this is to plot the observed flow directions
    # fig, axs = plt.subplots(1, 1, figsize=(8,16))
    # plt.quiver(self.flowdirx,self.flowdiry)
    # axs.axis(&#34;equal&#34;)</code></pre>
</details>
</dd>
<dt id="igm.igm.compute_gradient_tf"><code class="name flex">
<span>def <span class="ident">compute_gradient_tf</span></span>(<span>self, s, dx, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>compute spatial 2D gradient of a given field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.function()
def compute_gradient_tf(self, s, dx, dy):
    &#34;&#34;&#34;
    compute spatial 2D gradient of a given field
    &#34;&#34;&#34;

    EX = tf.concat([s[:, 0:1], 0.5 * (s[:, :-1] + s[:, 1:]), s[:, -1:]], 1)
    diffx = (EX[:, 1:] - EX[:, :-1]) / dx

    EY = tf.concat([s[0:1, :], 0.5 * (s[:-1, :] + s[1:, :]), s[-1:, :]], 0)
    diffy = (EY[1:, :] - EY[:-1, :]) / dy

    return diffx, diffy</code></pre>
</details>
</dd>
<dt id="igm.igm.compute_rms_std_optimization"><code class="name flex">
<span>def <span class="ident">compute_rms_std_optimization</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><p>compute_std_optimization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_rms_std_optimization(self, i):
    &#34;&#34;&#34;
    compute_std_optimization
    &#34;&#34;&#34;

    I = self.icemaskobs == 1

    if i == 0:
        self.rmsthk = []
        self.stdthk = []
        self.rmsvel = []
        self.stdvel = []
        self.rmsusurf = []
        self.stdusurf = []
        self.rmsdiv = []
        self.stddiv = []

    if hasattr(self, &#34;profile&#34;) | hasattr(self, &#34;thkobs&#34;):
        if self.config.thk_profiles_file == &#34;&#34;:
            ACT = ~tf.math.is_nan(self.thkobs)
            if np.sum(ACT) == 0:
                self.rmsthk.append(0)
                self.stdthk.append(0)
            else:
                self.rmsthk.append(np.nanmean(self.thk[ACT] - self.thkobs[ACT]))
                self.stdthk.append(np.nanstd(self.thk[ACT] - self.thkobs[ACT]))

        else:
            fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))
            thkdiff = np.concatenate(
                [
                    (fthk(p[:, 1], p[:, 2], grid=False) - p[:, 3])
                    for p in self.profile
                ]
            )
            self.rmsthk.append(np.mean(thkdiff))
            self.stdthk.append(np.std(thkdiff))
    else:
        self.rmsthk.append(0)
        self.stdthk.append(0)

    if hasattr(self, &#34;uvelsurfobs&#34;):
        velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf).numpy()
        velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs).numpy()
        ACT = ~np.isnan(velsurfobs_mag)

        self.rmsvel.append(
            np.mean(
                velsurf_mag[(I &amp; ACT).numpy()] - velsurfobs_mag[(I &amp; ACT).numpy()]
            )
        )
        self.stdvel.append(
            np.std(
                velsurf_mag[(I &amp; ACT).numpy()] - velsurfobs_mag[(I &amp; ACT).numpy()]
            )
        )
    else:
        self.rmsvel.append(0)
        self.stdvel.append(0)

    if hasattr(self, &#34;divfluxobs&#34;):
        self.rmsdiv.append(np.mean(self.divfluxobs[I] - self.divflux[I]))
        self.stddiv.append(np.std(self.divfluxobs[I] - self.divflux[I]))
    else:
        self.rmsdiv.append(0)
        self.stddiv.append(0)

    if hasattr(self, &#34;usurfobs&#34;):
        self.rmsusurf.append(np.mean(self.usurf[I] - self.usurfobs[I]))
        self.stdusurf.append(np.std(self.usurf[I] - self.usurfobs[I]))
    else:
        self.rmsusurf.append(0)
        self.stdusurf.append(0)</code></pre>
</details>
</dd>
<dt id="igm.igm.getmag"><code class="name flex">
<span>def <span class="ident">getmag</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"><p>return the norm of a 2D vector, e.g. to compute velbase_mag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.function()
def getmag(self, u, v):
    &#34;&#34;&#34;
    return the norm of a 2D vector, e.g. to compute velbase_mag
    &#34;&#34;&#34;
    return tf.norm(
        tf.concat([tf.expand_dims(u, axis=-1), tf.expand_dims(v, axis=-1)], axis=2),
        axis=2,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.init_3dvel"><code class="name flex">
<span>def <span class="ident">init_3dvel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_3dvel(self):

    if self.config.vel3d_active:

        self.height = np.arange(
            0, self.config.maxthk + 1, self.config.dz
        )  # height with constant dz
        self.ddz = self.height[1:] - self.height[:-1]

        self.nz = tf.Variable(
            tf.zeros((self.thk.shape[0], self.thk.shape[1]), dtype=&#34;int32&#34;)
        )
        self.depth = tf.Variable(
            tf.zeros(
                (self.height.shape[0], self.thk.shape[0], self.thk.shape[1]),
                dtype=&#34;float32&#34;,
            )
        )
        self.dz = tf.Variable(
            tf.zeros(
                (self.height.shape[0] - 1, self.thk.shape[0], self.thk.shape[1]),
                dtype=&#34;float32&#34;,
            )
        )

        self.U = tf.Variable(tf.zeros_like(self.depth))  # x-vel component
        self.V = tf.Variable(tf.zeros_like(self.depth))  # y-vel component
        self.W = tf.Variable(tf.zeros_like(self.depth))  # z-vel component

        self.tcomp[&#34;3d Vel&#34;] = []</code></pre>
</details>
</dd>
<dt id="igm.igm.init_smb_nn"><code class="name flex">
<span>def <span class="ident">init_smb_nn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>set-up the smb nn emulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_smb_nn(self):
    &#34;&#34;&#34;
    set-up the smb nn emulator
    &#34;&#34;&#34;

    dirpath = os.path.join(self.config.smb_model_lib_path, str(int(self.dx)))

    assert os.path.isdir(dirpath)

    fieldin, fieldout, fieldbounds = self.read_fields_and_bounds(dirpath)

    self.read_fields_and_bounds(dirpath)

    self.smb_mapping = {}
    self.smb_mapping[&#34;fieldin&#34;] = fieldin
    self.smb_mapping[&#34;fieldout&#34;] = fieldout
    self.smb_fieldbounds = fieldbounds

    self.smb_model = tf.keras.models.load_model(os.path.join(dirpath, &#34;model.h5&#34;))</code></pre>
</details>
</dd>
<dt id="igm.igm.init_smb_simple"><code class="name flex">
<span>def <span class="ident">init_smb_simple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>initialize simple mass balance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_smb_simple(self):
    &#34;&#34;&#34;
    initialize simple mass balance
    &#34;&#34;&#34;
    param = np.loadtxt(
        os.path.join(self.config.working_dir, self.config.mb_simple_file),
        skiprows=1,
        dtype=np.float32,
    )

    self.gradabl = interp1d(
        param[:, 0],
        param[:, 1],
        fill_value=(param[0, 1], param[-1, 1]),
        bounds_error=False,
    )
    self.gradacc = interp1d(
        param[:, 0],
        param[:, 2],
        fill_value=(param[0, 2], param[-1, 2]),
        bounds_error=False,
    )
    self.ela = interp1d(
        param[:, 0],
        param[:, 3],
        fill_value=(param[0, 3], param[-1, 3]),
        bounds_error=False,
    )
    self.maxacc = interp1d(
        param[:, 0],
        param[:, 4],
        fill_value=(param[0, 4], param[-1, 4]),
        bounds_error=False,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function initialize the strict minimum for IGM class, and record parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    &#34;&#34;&#34;
    function initialize the strict minimum for IGM class, and record parameters
    &#34;&#34;&#34;

    print(
        &#34;+++++++++++++++++++ START IGM ++++++++++++++++++++++++++++++++++++++++++&#34;
    )

    self.t = tf.Variable(float(self.config.tstart))
    self.it = 0
    self.dt = float(self.config.dtmax)
    self.dt_target = float(self.config.dtmax)

    self.saveresult = True

    self.tcomp = {}
    self.tcomp[&#34;All&#34;] = []

    self.device_name = &#34;/GPU:0&#34; * self.config.usegpu + &#34;/CPU:0&#34; * (
        not self.config.usegpu
    )

    os.environ[&#34;CUDA_DEVICE_ORDER&#34;] = &#34;PCI_BUS_ID&#34;  # so the IDs match nvidia-smi

    if self.config.usegpu:
        os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;0&#34;  # &#34;0, 1&#34; for multiple
    else:
        os.environ[&#34;CUDA_VISIBLE_DEVICES&#34;] = &#34;-1&#34;

    # This is used to limite the number of used core to 1 (or user-defined)
    #        tf.config.threading.set_inter_op_parallelism_threads(1)  # another method
    #        tf.config.threading.set_intra_op_parallelism_threads(1)  # another method

    with open(
        os.path.join(self.config.working_dir, &#34;igm-run-parameters.txt&#34;), &#34;w&#34;
    ) as f:
        print(&#34;PARAMETERS ARE ...... &#34;)
        for ck in self.config.__dict__:
            print(&#34;%30s : %s&#34; % (ck, self.config.__dict__[ck]))
            print(&#34;%30s : %s&#34; % (ck, self.config.__dict__[ck]), file=f)</code></pre>
</details>
</dd>
<dt id="igm.igm.initialize_fields"><code class="name flex">
<span>def <span class="ident">initialize_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize fields, complete the loading of geology</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_fields(self):
    &#34;&#34;&#34;
    Initialize fields, complete the loading of geology
    &#34;&#34;&#34;

    if self.config.verbosity == 1:
        print(&#34;Initialize fields&#34;)

    # at this point, we should have defined at least x, y, usurf
    assert hasattr(self, &#34;x&#34;)
    assert hasattr(self, &#34;y&#34;)

    if hasattr(self, &#34;usurfobs&#34;):
        self.usurf = tf.Variable(self.usurfobs)

    assert hasattr(self, &#34;usurf&#34;)

    if not hasattr(self, &#34;thk&#34;):
        self.thk = tf.Variable(tf.zeros((self.y.shape[0], self.x.shape[0])))

    self.topg = tf.Variable(self.usurf - self.thk)

    if not hasattr(self, &#34;icemask&#34;):
        if hasattr(self, &#34;mask&#34;):
            self.icemask = tf.Variable(self.mask)
        else:
            self.icemask = tf.Variable(tf.ones_like(self.thk))

    if not hasattr(self, &#34;uvelsurf&#34;):
        self.uvelsurf = tf.Variable(tf.zeros_like(self.thk))

    if not hasattr(self, &#34;vvelsurf&#34;):
        self.vvelsurf = tf.Variable(tf.zeros_like(self.thk))

    if not hasattr(self, &#34;wvelbase&#34;):
        self.wvelbase = tf.Variable(tf.zeros_like(self.thk))

    if not hasattr(self, &#34;wvelsurf&#34;):
        self.wvelsurf = tf.Variable(tf.zeros_like(self.thk))

    if not hasattr(self, &#34;smb&#34;):
        if hasattr(self, &#34;mb&#34;):
            self.smb = tf.Variable(self.mb)
        else:
            self.smb = tf.Variable(tf.zeros_like(self.thk))

    if not hasattr(self, &#34;dhdt&#34;):
        self.dhdt = tf.Variable(tf.zeros_like(self.thk))

    if not hasattr(self, &#34;strflowctrl&#34;):
        self.strflowctrl = tf.Variable(
            tf.ones_like(self.thk) * self.config.init_strflowctrl
        )

    if not hasattr(self, &#34;arrhenius&#34;):
        self.arrhenius = tf.Variable(
            tf.ones_like(self.thk) * self.config.init_arrhenius
        )

    if not hasattr(self, &#34;slidingco&#34;):
        self.slidingco = tf.Variable(
            tf.ones_like(self.thk) * self.config.init_slidingco
        )
        
    if self.config.erosion_include:
        self.dtopgdt = tf.Variable( tf.zeros_like(self.thk) )

    self.X, self.Y = tf.meshgrid(self.x, self.y)

    self.dx = self.x[1] - self.x[0]

    self.slopsurfx, self.slopsurfy = self.compute_gradient_tf(
        self.usurf, self.dx, self.dx
    )

    self.ubar = tf.Variable(tf.zeros_like(self.thk))
    self.vbar = tf.Variable(tf.zeros_like(self.thk))
    self.uvelbase = tf.Variable(tf.zeros_like(self.thk))
    self.vvelbase = tf.Variable(tf.zeros_like(self.thk))
    self.divflux = tf.Variable(tf.zeros_like(self.thk))

    self.var_info = {}
    self.var_info[&#34;topg&#34;] = [&#34;Basal Topography&#34;, &#34;m&#34;]
    self.var_info[&#34;usurf&#34;] = [&#34;Surface Topography&#34;, &#34;m&#34;]
    self.var_info[&#34;thk&#34;] = [&#34;Ice Thickness&#34;, &#34;m&#34;]
    self.var_info[&#34;icemask&#34;] = [&#34;Ice mask&#34;, &#34;NO UNIT&#34;]
    self.var_info[&#34;smb&#34;] = [&#34;Surface Mass Balance&#34;, &#34;m/y&#34;]
    self.var_info[&#34;ubar&#34;] = [&#34;x depth-average velocity of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;vbar&#34;] = [&#34;y depth-average velocity of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;velbar_mag&#34;] = [&#34;Depth-average velocity magnitude of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;uvelsurf&#34;] = [&#34;x surface velocity of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;vvelsurf&#34;] = [&#34;y surface velocity of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;velsurf_mag&#34;] = [&#34;Surface velocity magnitude of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;uvelbase&#34;] = [&#34;x basal velocity of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;vvelbase&#34;] = [&#34;y basal velocity of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;velbase_mag&#34;] = [&#34;Basal velocity magnitude of ice&#34;, &#34;m/y&#34;]
    self.var_info[&#34;divflux&#34;] = [&#34;Divergence of the ice flux&#34;, &#34;m/y&#34;]
    self.var_info[&#34;strflowctrl&#34;] = [
        &#34;arrhenius + 10 * slidingco&#34;,
        &#34;MPa$^{-3}$ a$^{-1}$&#34;,
    ]
    self.var_info[&#34;dtopgdt&#34;] = [&#34;Erosion rate&#34;,&#34;m/y&#34;]
    self.var_info[&#34;arrhenius&#34;] = [&#34;Arrhenius factor&#34;, &#34;MPa$^{-3}$ a$^{-1}$&#34;]
    self.var_info[&#34;slidingco&#34;] = [&#34;Sliding Coefficient&#34;, &#34;km MPa$^{-3}$ a$^{-1}$&#34;]
    self.var_info[&#34;meantemp&#34;] = [&#34;Mean anual surface temperatures&#34;, &#34;°C&#34;]
    self.var_info[&#34;meanprec&#34;] = [&#34;Mean anual precipitation&#34;, &#34;m/y&#34;]
    self.var_info[&#34;vol&#34;] = [&#34;Ice volume&#34;, &#34;km^3&#34;]
    self.var_info[&#34;area&#34;] = [&#34;Glaciated area&#34;, &#34;km^2&#34;]

    self.var_info[&#34;velsurfobs_mag&#34;] = [
        &#34;Observed Surface velocity magnitude of ice&#34;,
        &#34;m/y&#34;,
    ]</code></pre>
</details>
</dd>
<dt id="igm.igm.initialize_iceflow"><code class="name flex">
<span>def <span class="ident">initialize_iceflow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>set-up the iceflow emulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_iceflow(self):
    &#34;&#34;&#34;
    set-up the iceflow emulator
    &#34;&#34;&#34;

    dirpath = os.path.join(self.config.iceflow_model_lib_path, str(int(self.dx)))

    assert os.path.isdir(dirpath)

    fieldin, fieldout, fieldbounds = self.read_fields_and_bounds(dirpath)

    self.iceflow_mapping = {}
    self.iceflow_mapping[&#34;fieldin&#34;] = fieldin
    self.iceflow_mapping[&#34;fieldout&#34;] = fieldout
    self.iceflow_fieldbounds = fieldbounds

    self.iceflow_model = tf.keras.models.load_model(
        os.path.join(dirpath, &#34;model.h5&#34;)
    )

    #        print(self.iceflow_model.summary())

    Ny = self.thk.shape[0]
    Nx = self.thk.shape[1]

    if self.config.multiple_window_size &gt; 0:
        NNy = self.config.multiple_window_size * math.ceil(
            Ny / self.config.multiple_window_size
        )
        NNx = self.config.multiple_window_size * math.ceil(
            Nx / self.config.multiple_window_size
        )
        self.PAD = [[0, NNy - Ny], [0, NNx - Nx]]
    else:
        self.PAD = [[0, 0], [0, 0]]

    self.tcomp[&#34;Ice flow&#34;] = []</code></pre>
</details>
</dd>
<dt id="igm.igm.load_ncdf_data"><code class="name flex">
<span>def <span class="ident">load_ncdf_data</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the geological input files from netcdf file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_ncdf_data(self, filename):
    &#34;&#34;&#34;
    Load the geological input files from netcdf file
    &#34;&#34;&#34;
    if self.config.verbosity == 1:
        print(&#34;LOAD NCDF file&#34;)

    nc = Dataset(os.path.join(self.config.working_dir, filename), &#34;r&#34;)

    x = np.squeeze(nc.variables[&#34;x&#34;]).astype(&#34;float32&#34;)
    y = np.squeeze(nc.variables[&#34;y&#34;]).astype(&#34;float32&#34;)
    assert x[1] - x[0] == y[1] - y[0]

    for var in nc.variables:
        if not var in [&#34;x&#34;, &#34;y&#34;]:
            vars()[var] = np.squeeze(nc.variables[var]).astype(&#34;float32&#34;)
            vars()[var] = np.where(vars()[var] &gt; 10 ** 35, np.nan, vars()[var])

    if self.config.resample &gt; 1:
        xx = x[:: self.config.resample]
        yy = y[:: self.config.resample]
        for var in nc.variables:
            if not var in [&#34;x&#34;, &#34;y&#34;]:
                vars()[var] = RectBivariateSpline(y, x, vars()[var])(yy, xx)
        x = xx
        y = yy

    for var in nc.variables:
        if var in [&#34;x&#34;, &#34;y&#34;]:
            vars(self)[var] = tf.constant(vars()[var].astype(&#34;float32&#34;))
        else:
            vars(self)[var] = tf.Variable(vars()[var].astype(&#34;float32&#34;))

    nc.close()</code></pre>
</details>
</dd>
<dt id="igm.igm.load_thk_profiles"><code class="name flex">
<span>def <span class="ident">load_thk_profiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>load glacier ice thickness mesured profiles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_thk_profiles(self):
    &#34;&#34;&#34;
    load glacier ice thickness mesured profiles
    &#34;&#34;&#34;

    pathprofile = os.path.join(
        self.config.working_dir, self.config.thk_profiles_file
    )

    if len(glob.glob(pathprofile)) &gt; 0:

        vvv = []
        for g in glob.glob(pathprofile):
            vvv.append(np.loadtxt(g, dtype=np.float32))
        self.profile = np.concatenate(vvv, axis=0)

        # re-index profiles in case there were not properly indexed
        self.profile = [
            self.profile[np.floor(self.profile[:, 0]) == i + 1, :]
            for i in range(int(np.max(self.profile[:, 0])))
        ]

        # Remove empty List from List using list comprehension
        self.profile = [ele for ele in self.profile if len(ele) &gt; 0]

        # compute the distance between points as first entry as it will be usefully later on
        for p in self.profile:
            p[:, 0] = np.insert(
                np.cumsum(np.sqrt(np.diff(p[:, 1]) ** 2 + np.diff(p[:, 2]) ** 2)),
                0,
                0,
            )
    else:
        sys.exit(&#34;thk requested in opti, but file &#34; + pathprofile + &#34; is not found&#34;)

    points = np.stack([item[1:3] for sublist in self.profile for item in sublist])
    jiptprof = []
    for p in points:
        i = (p[0] - np.min(self.X)) / self.dx
        j = (p[1] - np.min(self.Y)) / self.dx
        jiptprof.append([j, i])
    self.jiptprof = tf.expand_dims(jiptprof, axis=0)

    target = np.stack([item[3] for sublist in self.profile for item in sublist])
    self.thktargetprof = tf.Variable(target.astype(&#34;float32&#34;))

    target = np.stack([item[4] for sublist in self.profile for item in sublist])
    self.thktargetprof_std = tf.Variable(target.astype(&#34;float32&#34;))</code></pre>
</details>
</dd>
<dt id="igm.igm.make_data_holes"><code class="name flex">
<span>def <span class="ident">make_data_holes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This serves to make holes in surface data (velocities) to test robusness of the optimization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_data_holes(self):
    &#34;&#34;&#34;
    This serves to make holes in surface data (velocities) to test robusness of the optimization
    &#34;&#34;&#34;

    mask_holes = np.zeros_like(self.thk.numpy(), dtype=&#34;int&#34;)

    if (self.config.opti_make_holes_in_data &gt; 0) &amp; (
        self.config.opti_make_holes_in_data &lt; 99
    ):

        np.random.seed(seed=123)

        while (
            np.sum(mask_holes) / np.sum(self.icemaskobs &gt; 0.5)
        ) &lt; self.config.opti_make_holes_in_data * 0.01:

            j = np.random.randint(0, self.thk.shape[0])
            i = np.random.randint(0, self.thk.shape[1])

            if self.icemaskobs[j, i] &gt; 0.5:
                mask_holes[j, i] = 1

    elif self.config.opti_make_holes_in_data == 100:
        mask_holes = np.ones_like(self.thk.numpy(), dtype=&#34;int&#34;)

    elif self.config.opti_make_holes_in_data == 200:
        mask_holes[self.Y &gt; np.mean(self.y)] = 1

    self.uvelsurfobs = tf.where(
        (self.icemaskobs == 1) &amp; (mask_holes == 0), self.uvelsurfobs, np.nan
    )
    self.vvelsurfobs = tf.where(
        (self.icemaskobs == 1) &amp; (mask_holes == 0), self.vvelsurfobs, np.nan
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the optimization routine to invert thk, strflowctrl ans usurf from data
DEFAULT PARAMETERS ARE</p>
<h1 id="nbitmin50-nbitmax1000-opti_step_size0001">nbitmin=50, nbitmax=1000, opti_step_size=0.001,</h1>
<h1 id="init_zero_thktrue">init_zero_thk=True,</h1>
<h1 id="regu_param_thk10-regu_param_strflowctrl10">regu_param_thk=1.0, regu_param_strflowctrl=1.0,</h1>
<h1 id="smooth_anisotropy_factor02-convexity_weight-0002">smooth_anisotropy_factor=0.2, convexity_weight = 0.002,</h1>
<h1 id="opti_controlthkstrflowctrl-opti_costvelsurfthk">opti_control=['thk','strflowctrl'], opti_cost=['velsurf','thk'],</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize(self):
    &#34;&#34;&#34;
    This is the optimization routine to invert thk, strflowctrl ans usurf from data
    DEFAULT PARAMETERS ARE
    # nbitmin=50, nbitmax=1000, opti_step_size=0.001,
    # init_zero_thk=True,
    # regu_param_thk=1.0, regu_param_strflowctrl=1.0,
    # smooth_anisotropy_factor=0.2, convexity_weight = 0.002,
    # opti_control=[&#39;thk&#39;,&#39;strflowctrl&#39;], opti_cost=[&#39;velsurf&#39;,&#39;thk&#39;],
    &#34;&#34;&#34;

    ###### PERFORM CHECKS PRIOR OPTIMIZATIONS

    # make sure this condition is satisfied
    assert (&#34;usurf&#34; in self.config.opti_cost) == (
        &#34;usurf&#34; in self.config.opti_control
    )

    # make sure the loaded ice flow emulator has these inputs
    assert (
        self.iceflow_mapping[&#34;fieldin&#34;]
        == [&#34;thk&#34;, &#34;slopsurfx&#34;, &#34;slopsurfy&#34;, &#34;arrhenius&#34;, &#34;slidingco&#34;]
    ) | (
        self.iceflow_mapping[&#34;fieldin&#34;]
        == [&#34;thk&#34;, &#34;slopsurfx&#34;, &#34;slopsurfy&#34;, &#34;strflowctrl&#34;]
    )

    # make sure the loaded ice flow emulator has at least these outputs
    assert all(
        [
            (f in self.iceflow_mapping[&#34;fieldout&#34;])
            for f in [&#34;ubar&#34;, &#34;vbar&#34;, &#34;uvelsurf&#34;, &#34;vvelsurf&#34;]
        ]
    )

    # make sure that there are lease some profiles in thkobs
    if &#34;thk&#34; in self.config.opti_cost:
        if self.config.thk_profiles_file == &#34;&#34;:
            assert not tf.reduce_all(tf.math.is_nan(self.thkobs))

    ###### PREPARE DATA PRIOR OPTIMIZATIONS

    if &#34;thk&#34; in self.config.opti_cost:
        if not self.config.thk_profiles_file == &#34;&#34;:
            self.load_thk_profiles()

    if hasattr(self, &#34;uvelsurfobs&#34;) &amp; hasattr(self, &#34;vvelsurfobs&#34;):
        self.velsurfobs = tf.stack([self.uvelsurfobs, self.vvelsurfobs], axis=-1)

    if &#34;divfluxobs&#34; in self.config.opti_cost:
        self.divfluxobs = self.smb - self.dhdt

    if not self.config.opti_smooth_anisotropy_factor == 1:
        self.compute_flow_direction_for_anisotropic_smoothing()

    if self.config.opti_make_holes_in_data &gt; 0:
        self.make_data_holes()

    if hasattr(self, &#34;thkinit&#34;):
        self.thk.assign(self.thkinit)
    else:
        self.thk.assign(tf.zeros_like(self.thk))

    if self.config.opti_init_zero_thk:
        self.thk.assign(tf.zeros_like(self.thk))

    ###### PREPARE OPIMIZER

    optimizer = tf.keras.optimizers.Adam(lr=self.config.opti_step_size)

    # initial_learning_rate * decay_rate ^ (step / decay_steps)
    # lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay( initial_learning_rate=opti_step_size, decay_steps=100, decay_rate=0.9)
    # optimizer = tf.keras.optimizers.Adam(learning_rate=lr_schedule)

    # add scalng for usurf
    self.iceflow_fieldbounds[&#34;usurf&#34;] = (
        self.iceflow_fieldbounds[&#34;slopsurfx&#34;] * self.dx
    )

    ###### PREPARE VARIABLES TO OPTIMIZE

    if self.iceflow_mapping[&#34;fieldin&#34;] == [
        &#34;thk&#34;,
        &#34;slopsurfx&#34;,
        &#34;slopsurfy&#34;,
        &#34;arrhenius&#34;,
        &#34;slidingco&#34;,
    ]:
        self.iceflow_fieldbounds[&#34;strflowctrl&#34;] = (
            self.iceflow_fieldbounds[&#34;arrhenius&#34;]
            + self.iceflow_fieldbounds[&#34;slidingco&#34;]
        )

    thk = tf.Variable(self.thk / self.iceflow_fieldbounds[&#34;thk&#34;])  # normalized vars
    strflowctrl = tf.Variable(
        self.strflowctrl / self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
    )  # normalized vars
    usurf = tf.Variable(
        self.usurf / self.iceflow_fieldbounds[&#34;usurf&#34;]
    )  # normalized vars

    self.costs = []

    self.tcomp[&#34;Optimize&#34;] = []

    # main loop
    for i in range(self.config.opti_nbitmax):

        with tf.GradientTape() as t:

            self.tcomp[&#34;Optimize&#34;].append(time.time())

            # is necessary to remember all operation to derive the gradients w.r.t. control variables
            if &#34;thk&#34; in self.config.opti_control:
                t.watch(thk)
            if &#34;usurf&#34; in self.config.opti_control:
                t.watch(usurf)
            if &#34;strflowctrl&#34; in self.config.opti_control:
                t.watch(strflowctrl)

            # update surface gradient
            if (i == 0) | (&#34;usurf&#34; in self.config.opti_control):
                slopsurfx, slopsurfy = self.compute_gradient_tf(
                    usurf * self.iceflow_fieldbounds[&#34;usurf&#34;], self.dx, self.dx
                )
                slopsurfx = slopsurfx / self.iceflow_fieldbounds[&#34;slopsurfx&#34;]
                slopsurfy = slopsurfy / self.iceflow_fieldbounds[&#34;slopsurfy&#34;]

            if self.iceflow_mapping[&#34;fieldin&#34;] == [
                &#34;thk&#34;,
                &#34;slopsurfx&#34;,
                &#34;slopsurfy&#34;,
                &#34;arrhenius&#34;,
                &#34;slidingco&#34;,
            ]:

                thrv = (
                    self.config.opti_thr_strflowctrl
                    / self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                )
                arrhenius = tf.where(strflowctrl &lt;= thrv, strflowctrl, thrv)
                slidingco = tf.where(strflowctrl &lt;= thrv, 0, strflowctrl - thrv)

                # build input of the emulator
                X = tf.concat(
                    [
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(thk, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(slopsurfx, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(slopsurfy, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(arrhenius, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(slidingco, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                    ],
                    axis=-1,
                )

            elif self.iceflow_mapping[&#34;fieldin&#34;] == [
                &#34;thk&#34;,
                &#34;slopsurfx&#34;,
                &#34;slopsurfy&#34;,
                &#34;strflowctrl&#34;,
            ]:

                # build input of the emulator
                X = tf.concat(
                    [
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(thk, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(slopsurfx, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(slopsurfy, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                        tf.expand_dims(
                            tf.expand_dims(
                                tf.pad(strflowctrl, self.PAD, &#34;CONSTANT&#34;), axis=0
                            ),
                            axis=-1,
                        ),
                    ],
                    axis=-1,
                )
            else:
                # ONLY these 2 above cases were implemented !!!
                sys.exit(
                    &#34;CHANGE THE ICE FLOW EMULATOR -- IMCOMPATIBLE FOR INVERSION &#34;
                )

            # evalutae th ice flow emulator
            Y = self.iceflow_model(X)

            # get the dimensions of the working array
            Ny, Nx = self.thk.shape

            # save output variables into igm.variables for outputs
            for kk, f in enumerate(self.iceflow_mapping[&#34;fieldout&#34;]):
                vars(self)[f].assign(
                    Y[0, :Ny, :Nx, kk] * self.iceflow_fieldbounds[f]
                )

            # find index of variables in output
            iubar = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;ubar&#34;)
            ivbar = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;vbar&#34;)
            iuvsu = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;uvelsurf&#34;)
            ivvsu = self.iceflow_mapping[&#34;fieldout&#34;].index(&#34;vvelsurf&#34;)

            # save output of the emaultor to compute the costs function
            ubar = (
                Y[0, :Ny, :Nx, iubar] * self.iceflow_fieldbounds[&#34;ubar&#34;]
            )  # NOT normalized vars
            vbar = (
                Y[0, :Ny, :Nx, ivbar] * self.iceflow_fieldbounds[&#34;vbar&#34;]
            )  # NOT normalized vars
            uvelsurf = (
                Y[0, :Ny, :Nx, iuvsu] * self.iceflow_fieldbounds[&#34;uvelsurf&#34;]
            )  # NOT normalized vars
            vvelsurf = (
                Y[0, :Ny, :Nx, ivvsu] * self.iceflow_fieldbounds[&#34;vvelsurf&#34;]
            )  # NOT normalized vars
            velsurf = tf.stack([uvelsurf, vvelsurf], axis=-1)  # NOT normalized vars

            # misfit between surface velocity
            if &#34;velsurf&#34; in self.config.opti_cost:
                ACT = ~tf.math.is_nan(self.velsurfobs)
                COST_U = 0.5 * tf.reduce_mean(
                    (
                        (self.velsurfobs[ACT] - velsurf[ACT])
                        / self.config.opti_velsurfobs_std
                    )
                    ** 2
                )
            else:
                COST_U = tf.Variable(0.0)

            # misfit between ice thickness profiles
            if &#34;thk&#34; in self.config.opti_cost:
                if self.config.thk_profiles_file == &#34;&#34;:
                    ACT = ~tf.math.is_nan(self.thkobs)
                    COST_H = 0.5 * tf.reduce_mean(
                        (
                            (
                                self.thkobs[ACT]
                                - thk[ACT] * self.iceflow_fieldbounds[&#34;thk&#34;]
                            )
                            / self.config.opti_thkobs_std
                        )
                        ** 2
                    )
                else:
                    import tensorflow_addons as tfa

                    COST_H = 0.5 * tf.reduce_mean(
                        (
                            (
                                self.thktargetprof
                                - tfa.image.interpolate_bilinear(
                                    tf.expand_dims(
                                        tf.expand_dims(
                                            thk * self.iceflow_fieldbounds[&#34;thk&#34;],
                                            axis=0,
                                        ),
                                        axis=-1,
                                    ),
                                    self.jiptprof,
                                    indexing=&#34;ij&#34;,
                                )[0, :, 0]
                            )
                            / self.thktargetprof_std
                        )
                        ** 2
                    )
            else:
                COST_H = tf.Variable(0.0)

            # misfit divergence of the flux
            if (&#34;divfluxobs&#34; in self.config.opti_cost) | (
                &#34;divfluxfcz&#34; in self.config.opti_cost
            ):

                divflux = self.compute_divflux(
                    ubar,
                    vbar,
                    thk * self.iceflow_fieldbounds[&#34;thk&#34;],
                    self.dx,
                    self.dx,
                )

                if &#34;divfluxfcz&#34; in self.config.opti_cost:
                    ACT = self.icemaskobs &gt; 0.5
                    if i % 10 == 0:
                        # his does not need to be comptued any iteration as this is expensive
                        res = stats.linregress(
                            self.usurf[ACT], divflux[ACT]
                        )  # this is a linear regression (usually that&#39;s enough)
                    # or you may go for polynomial fit (more gl, but may leads to errors)
                    #  weights = np.polyfit(self.usurf[ACT],divflux[ACT], 2) 
                    divfluxtar = tf.where(
                        ACT, res.intercept + res.slope * self.usurf, 0.0
                    )
                #                        divfluxtar = tf.where(ACT, np.poly1d(weights)(self.usurf) , 0.0 )

                else:
                    divfluxtar = self.divfluxobs

                ACT = self.icemaskobs &gt; 0.5
                COST_D = 0.5 * tf.reduce_mean(
                    (
                        (divfluxtar[ACT] - divflux[ACT])
                        / self.config.opti_divfluxobs_std
                    )
                    ** 2
                )

            else:
                COST_D = tf.Variable(0.0)

            # misfit between top ice surfaces
            if &#34;usurf&#34; in self.config.opti_cost:
                ACT = self.icemaskobs &gt; 0.5
                COST_S = 0.5 * tf.reduce_mean(
                    (
                        (
                            usurf[ACT] * self.iceflow_fieldbounds[&#34;usurf&#34;]
                            - self.usurfobs[ACT]
                        )
                        / self.config.opti_usurfobs_std
                    )
                    ** 2
                )
            else:
                COST_S = tf.Variable(0.0)

            # force usurf = usurf - topg
            if &#34;topg&#34; in self.config.opti_cost:
                ACT = self.icemaskobs == 1
                COST_T = 10 ** 10 * tf.reduce_mean(
                    (
                        usurf[ACT] * self.iceflow_fieldbounds[&#34;usurf&#34;]
                        - thk[ACT] * self.iceflow_fieldbounds[&#34;thk&#34;]
                        - self.topg[ACT]
                    )
                    ** 2
                )
            else:
                COST_T = tf.Variable(0.0)

            # force zero thikness outisde the mask
            if &#34;icemask&#34; in self.config.opti_cost:
                COST_O = 10 ** 10 * tf.math.reduce_mean(
                    tf.where(self.icemaskobs &gt; 0.5, 0.0, thk ** 2)
                )
            else:
                COST_O = tf.Variable(0.0)

            # Here one enforces non-negative ice thickness, and possibly zero-thickness in user-defined ice-free areas.
            if &#34;thk&#34; in self.config.opti_control:
                COST_HPO = 10 ** 10 * tf.math.reduce_mean(
                    tf.where(thk &gt;= 0, 0.0, thk ** 2)
                )
            else:
                COST_HPO = tf.Variable(0.0)

            # # Make sur to keep reasonable values for strflowctrl
            if &#34;strflowctrl&#34; in self.config.opti_control:
                COST_STR = 0.5 * tf.reduce_mean(
                    (
                        (
                            strflowctrl * self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                            - self.config.opti_thr_strflowctrl
                        )
                        / self.config.opti_strflowctrl_std
                    )
                    ** 2
                )
            else:
                COST_STR = tf.Variable(0.0)

            # Here one adds a regularization terms for the ice thickness to the cost function
            if &#34;thk&#34; in self.config.opti_control:
                dbdx = thk[:, 1:] - thk[:, :-1]
                dbdx = (dbdx[1:, :] + dbdx[:-1, :]) / 2.0
                dbdy = thk[1:, :] - thk[:-1, :]
                dbdy = (dbdy[:, 1:] + dbdy[:, :-1]) / 2.0

                if self.config.opti_smooth_anisotropy_factor == 1:
                    REGU_H = self.config.opti_regu_param_thk * (
                        tf.nn.l2_loss(dbdx) + tf.nn.l2_loss(dbdy)
                    )
                else:
                    REGU_H = self.config.opti_regu_param_thk * (
                        tf.nn.l2_loss((dbdx * self.flowdirx + dbdy * self.flowdiry))
                        + self.config.opti_smooth_anisotropy_factor
                        * tf.nn.l2_loss(
                            (dbdx * self.flowdiry - dbdy * self.flowdirx)
                        )
                        - self.config.opti_convexity_weight
                        * tf.math.reduce_sum(thk)
                    )
            else:
                REGU_H = tf.Variable(0.0)

            # Here one adds a regularization terms for strflowctrl to the cost function
            if &#34;strflowctrl&#34; in self.config.opti_control:
                dadx = tf.math.abs(strflowctrl[:, 1:] - strflowctrl[:, :-1])
                dady = tf.math.abs(strflowctrl[1:, :] - strflowctrl[:-1, :])
                dadx = tf.where(
                    (self.icemaskobs[:, 1:] &gt; 0.5)
                    &amp; (self.icemaskobs[:, :-1] &gt; 0.5),
                    dadx,
                    0.0,
                )
                dady = tf.where(
                    (self.icemaskobs[1:, :] &gt; 0.5)
                    &amp; (self.icemaskobs[:-1, :] &gt; 0.5),
                    dady,
                    0.0,
                )
                REGU_A = self.config.opti_regu_param_strflowctrl * (
                    tf.nn.l2_loss(dadx) + tf.nn.l2_loss(dady)
                )
            else:
                REGU_A = tf.Variable(0.0)

            # sum all component into the main cost function
            COST = (
                COST_U
                + COST_H
                + COST_D
                + COST_S
                + COST_T
                + COST_O
                + COST_HPO
                + COST_STR
                + REGU_H
                + REGU_A
            )

            vol = (
                np.sum(thk * self.iceflow_fieldbounds[&#34;thk&#34;])
                * (self.dx ** 2)
                / 10 ** 9
            )

            if i % self.config.opti_output_freq == 0:
                print(
                    &#34; OPTI, step %5.0f , ICE_VOL: %7.2f , COST_U: %7.2f , COST_H: %7.2f , COST_D : %7.2f , COST_S : %7.2f , REGU_H : %7.2f , REGU_A : %7.2f &#34;
                    % (
                        i,
                        vol,
                        COST_U.numpy(),
                        COST_H.numpy(),
                        COST_D.numpy(),
                        COST_S.numpy(),
                        REGU_H.numpy(),
                        REGU_A.numpy(),
                    )
                )

            self.costs.append(
                [
                    COST_U.numpy(),
                    COST_H.numpy(),
                    COST_D.numpy(),
                    COST_S.numpy(),
                    REGU_H.numpy(),
                    REGU_A.numpy(),
                ]
            )

            var_to_opti = []
            if &#34;thk&#34; in self.config.opti_control:
                var_to_opti.append(thk)
            if &#34;usurf&#34; in self.config.opti_control:
                var_to_opti.append(usurf)
            if &#34;strflowctrl&#34; in self.config.opti_control:
                var_to_opti.append(strflowctrl)

            # Compute gradient of COST w.r.t. X
            grads = tf.Variable(t.gradient(COST, var_to_opti))

            # this serve to restict the optimization of controls to the mask
            for ii in range(grads.shape[0]):
                grads[ii].assign(tf.where((self.icemaskobs &gt; 0.5), grads[ii], 0))

            # One step of descent -&gt; this will update input variable X
            optimizer.apply_gradients(
                zip([grads[i] for i in range(grads.shape[0])], var_to_opti)
            )

            # get back optimized variables in the pool of igm.variables
            if &#34;thk&#34; in self.config.opti_control:
                self.thk.assign(thk * self.iceflow_fieldbounds[&#34;thk&#34;])
                self.thk.assign(tf.where(self.thk &lt; 0.01, 0, self.thk))
            if &#34;strflowctrl&#34; in self.config.opti_control:
                self.strflowctrl.assign(
                    strflowctrl * self.iceflow_fieldbounds[&#34;strflowctrl&#34;]
                )
            if &#34;usurf&#34; in self.config.opti_control:
                self.usurf.assign(usurf * self.iceflow_fieldbounds[&#34;usurf&#34;])

            self.divflux = self.compute_divflux(
                self.ubar, self.vbar, self.thk, self.dx, self.dx
            )

            self.compute_rms_std_optimization(i)

            self.tcomp[&#34;Optimize&#34;][-1] -= time.time()
            self.tcomp[&#34;Optimize&#34;][-1] *= -1

            if i % self.config.opti_output_freq == 0:
                self.update_plot_inversion(i, self.config.plot_live)
                self.update_ncdf_optimize(i)
            # self.update_plot_profiles(i,plot_live)

            # stopping criterion: stop if the cost no longer decrease
            # if i&gt;self.config.opti_nbitmin:
            #     cost = [c[0] for c in costs]
            #     if np.mean(cost[-10:])&gt;np.mean(cost[-20:-10]):
            #         break;

    # now that the ice thickness is optimized, we can fix the bed once for all!
    self.topg.assign(self.usurf - self.thk)

    self.output_ncdf_optimize_final()

    self.plot_cost_functions(self.costs, self.config.plot_live)

    np.savetxt(
        os.path.join(self.config.working_dir, &#34;costs.dat&#34;),
        np.stack(self.costs),
        fmt=&#34;%.10f&#34;,
        header=&#34;        COST_U        COST_H      COST_D       COST_S       REGU_H       REGU_A          HPO &#34;,
    )

    np.savetxt(
        os.path.join(self.config.working_dir, &#34;rms_std.dat&#34;),
        np.stack(
            [
                self.rmsthk,
                self.stdthk,
                self.rmsvel,
                self.stdvel,
                self.rmsdiv,
                self.stddiv,
                self.rmsusurf,
                self.stdusurf,
            ],
            axis=-1,
        ),
        fmt=&#34;%.10f&#34;,
        header=&#34;        rmsthk      stdthk       rmsvel       stdvel       rmsdiv       stddiv       rmsusurf       stdusurf&#34;,
    )

    np.savetxt(
        os.path.join(self.config.working_dir, &#34;strflowctrl.dat&#34;),
        np.array(
            [
                np.mean(self.strflowctrl[self.icemaskobs &gt; 0.5]),
                np.std(self.strflowctrl[self.icemaskobs &gt; 0.5]),
            ]
        ),
        fmt=&#34;%.3f&#34;,
    )

    np.savetxt(
        os.path.join(self.config.working_dir, &#34;volume.dat&#34;),
        np.array([np.sum(self.thk) * self.dx * self.dx / (10 ** 9)]),
        fmt=&#34;%.3f&#34;,
    )

    np.savetxt(
        os.path.join(self.config.working_dir, &#34;tcompoptimize.dat&#34;),
        np.array([np.sum([f for f in self.tcomp[&#34;Optimize&#34;]])]),
        fmt=&#34;%.3f&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.output_ncdf_optimize_final"><code class="name flex">
<span>def <span class="ident">output_ncdf_optimize_final</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Write final geology after optimizing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_ncdf_optimize_final(self):
    &#34;&#34;&#34;
    Write final geology after optimizing
    &#34;&#34;&#34;

    if self.config.verbosity == 1:
        print(&#34;Write the final geology ncdf file after optimization&#34;)

    nc = Dataset(
        os.path.join(self.config.working_dir, self.config.observation_file), &#34;r&#34;
    )
    varori = [v for v in nc.variables]
    nc.close()

    varori.remove(&#34;x&#34;)
    varori.remove(&#34;y&#34;)
    if not &#34;strflowctrl&#34; in varori:
        varori.append(&#34;strflowctrl&#34;)
    if not &#34;thk&#34; in varori:
        varori.append(&#34;thk&#34;)
    if not &#34;usurf&#34; in varori:
        varori.append(&#34;usurf&#34;)
    if not &#34;icemask&#34; in varori:
        varori.append(&#34;icemask&#34;)

    self.arrhenius = tf.where(
        self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
        self.strflowctrl,
        self.config.opti_thr_strflowctrl,
    )
    self.slidingco = tf.where(
        self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
        0,
        self.strflowctrl - self.config.opti_thr_strflowctrl,
    )
    self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

    self.icemask = tf.where(
        self.thk &gt; 1.0, tf.ones_like(self.thk), tf.zeros_like(self.thk)
    )

    if os.path.isfile(os.path.join(self.config.working_dir, &#34;geology.nc&#34;)):
        filename = &#34;geology-optimized.nc&#34;
    else:
        filename = &#34;geology.nc&#34;

    nc = Dataset(
        os.path.join(self.config.working_dir, filename),
        &#34;w&#34;,
        format=&#34;NETCDF4&#34;,
    )

    nc.createDimension(&#34;y&#34;, len(self.y))
    E = nc.createVariable(&#34;y&#34;, dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
    E.units = &#34;m&#34;
    E.long_name = &#34;y&#34;
    E.axis = &#34;Y&#34;
    E[:] = self.y.numpy()

    nc.createDimension(&#34;x&#34;, len(self.x))
    E = nc.createVariable(&#34;x&#34;, dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
    E.units = &#34;m&#34;
    E.long_name = &#34;x&#34;
    E.axis = &#34;X&#34;
    E[:] = self.x.numpy()

    for var in varori:

        if hasattr(self, var):
            E = nc.createVariable(var, dtype(&#34;float32&#34;).char, (&#34;y&#34;, &#34;x&#34;))
            #                E.long_name = self.var_info[var][0]
            #                E.units     = self.var_info[var][1]
            E[:, :] = vars(self)[var].numpy()

    nc.close()</code></pre>
</details>
</dd>
<dt id="igm.igm.plot_computational_pie"><code class="name flex">
<span>def <span class="ident">plot_computational_pie</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot to the computational time of each model components in a pie</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_computational_pie(self):
    &#34;&#34;&#34;
    Plot to the computational time of each model components in a pie
    &#34;&#34;&#34;

    def make_autopct(values):
        def my_autopct(pct):
            total = sum(values)
            val = int(round(pct * total / 100.0))
            return &#34;{:.0f}&#34;.format(val)

        return my_autopct

    total = []
    name = []

    for i, key in enumerate(self.tcomp.keys()):
        if not key == &#34;All&#34;:
            total.append(np.sum(self.tcomp[key][1:]))
            name.append(key)

    sumallindiv = np.sum(total)

    fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(aspect=&#34;equal&#34;), dpi=200)
    wedges, texts, autotexts = ax.pie(
        total, autopct=make_autopct(total), textprops=dict(color=&#34;w&#34;)
    )
    ax.legend(
        wedges,
        name,
        title=&#34;Model components&#34;,
        loc=&#34;center left&#34;,
        bbox_to_anchor=(1, 0, 0.5, 1),
    )
    plt.setp(autotexts, size=8, weight=&#34;bold&#34;)
    #    ax.set_title(&#34;Matplotlib bakery: A pie&#34;)
    plt.tight_layout()
    plt.savefig(
        os.path.join(self.config.working_dir, &#34;PIE-COMPUTATIONAL.png&#34;), pad_inches=0
    )
    plt.close(&#34;all&#34;)</code></pre>
</details>
</dd>
<dt id="igm.igm.plot_cost_functions"><code class="name flex">
<span>def <span class="ident">plot_cost_functions</span></span>(<span>self, costs, plot_live)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cost_functions(self, costs, plot_live):

    costs = np.stack(costs)

    for i in range(costs.shape[1]):
        costs[:, i] -= np.min(costs[:, i])
        costs[:, i] /= np.max(costs[:, i])

    fig = plt.figure(figsize=(10, 10))
    plt.plot(costs[:, 0], &#34;-k&#34;, label=&#34;COST U&#34;)
    plt.plot(costs[:, 1], &#34;-r&#34;, label=&#34;COST H&#34;)
    plt.plot(costs[:, 2], &#34;-b&#34;, label=&#34;COST D&#34;)
    plt.plot(costs[:, 3], &#34;-g&#34;, label=&#34;COST S&#34;)
    plt.plot(costs[:, 4], &#34;--c&#34;, label=&#34;REGU H&#34;)
    plt.plot(costs[:, 5], &#34;--m&#34;, label=&#34;REGU A&#34;)
    plt.ylim(0, 1)
    plt.legend()

    if plot_live:
        plt.show()
    else:
        plt.savefig(
            os.path.join(self.config.working_dir, &#34;convergence.png&#34;), pad_inches=0
        )
        plt.close(&#34;all&#34;)</code></pre>
</details>
</dd>
<dt id="igm.igm.plot_opti_diff"><code class="name flex">
<span>def <span class="ident">plot_opti_diff</span></span>(<span>self, file, vari, plot_live=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot thickness, velocity, mand slidingco</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_opti_diff(self, file, vari, plot_live=True):
    &#34;&#34;&#34;
    Plot thickness, velocity, mand slidingco
    &#34;&#34;&#34;

    from matplotlib import cm
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    import matplotlib.pyplot as plt
    import xarray as xr

    data = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[vari]

    minvar = np.min(data[-1])
    minvardiff = minvar / 5
    maxvar = np.max(data[-1])
    maxvardiff = maxvar / 5

    if vari == &#34;divflux&#34;:
        maxvar = 10
        maxvardiff = 10
        minvar = -10
        minvardiff = -10

    if vari == &#34;thk&#34;:
        maxvardiff = maxvar / 5
        minvardiff = -maxvar / 5

    if vari == &#34;usurf&#34;:
        maxvardiff = 10
        minvardiff = -10

    extent = [self.x[0], self.x[-1], self.y[0], self.y[-1]]

    dicc = {}
    dicc[&#34;thk&#34;] = &#34;thk&#34;
    dicc[&#34;velsurf_mag&#34;] = &#34;vel&#34;
    dicc[&#34;usurf&#34;] = &#34;usurf&#34;
    dicc[&#34;divflux&#34;] = &#34;div&#34;

    ########################################################

    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 6), dpi=200)

    if vari in [&#34;velsurf_mag&#34;]:  # ,&#39;thk&#39;
        rms = str(int(vars(self)[&#34;rms&#34; + dicc[vari]][0]))
        std = str(int(vars(self)[&#34;std&#34; + dicc[vari]][0]))
        comp = &#34; (RMS: &#34; + rms + &#34;, STD: &#34; + std + &#34;)&#34;
    else:
        comp = &#34;&#34;

    ax1.set_title(&#34;Initial &#34; + vari + comp)
    im1 = ax1.imshow(
        np.where(self.thk &gt; 1, data[0], np.nan),
        origin=&#34;lower&#34;,
        extent=extent,
        vmin=minvar,
        vmax=maxvar,
        cmap=cm.get_cmap(&#34;viridis&#34;, 8),
    )
    divider = make_axes_locatable(ax1)
    cax1 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
    cbar1 = plt.colorbar(im1, format=&#34;%.0f&#34;, cax=cax1, orientation=&#34;vertical&#34;)
    ax1.axis(&#34;off&#34;)

    if vari in [&#34;velsurf_mag&#34;, &#34;thk&#34;]:
        rms = str(int(vars(self)[&#34;rms&#34; + dicc[vari]][-1]))
        std = str(int(vars(self)[&#34;std&#34; + dicc[vari]][-1]))
        comp = &#34; (RMS: &#34; + rms + &#34;, STD: &#34; + std + &#34;)&#34;
    else:
        comp = &#34;&#34;

    ax2.set_title(&#34;Optimized &#34; + vari + comp)
    im2 = ax2.imshow(
        np.where(self.thk &gt; 1, data[-1], np.nan),
        origin=&#34;lower&#34;,
        extent=extent,
        vmin=minvar,
        vmax=maxvar,
        cmap=cm.get_cmap(&#34;viridis&#34;, 8),
    )
    divider = make_axes_locatable(ax2)
    cax2 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
    cbar2 = plt.colorbar(im2, format=&#34;%.0f&#34;, cax=cax2, orientation=&#34;vertical&#34;)
    ax2.axis(&#34;off&#34;)

    if vari == &#34;velsurf_mag&#34;:
        velsurfobs_mag = xr.open_dataset(file, engine=&#34;netcdf4&#34;)[&#34;velsurfobs_mag&#34;]
        tod = np.where(self.thk &gt; 1, velsurfobs_mag[0], np.nan)
        ax3.set_title(&#34;Target&#34;)
        im3 = ax3.imshow(
            tod,
            origin=&#34;lower&#34;,
            extent=extent,
            vmin=minvar,
            vmax=maxvar,
            cmap=cm.get_cmap(&#34;viridis&#34;, 8),
        )
        divider = make_axes_locatable(ax3)
        cax3 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
        cbar3 = plt.colorbar(im3, format=&#34;%.0f&#34;, cax=cax3, orientation=&#34;vertical&#34;)
        ax3.axis(&#34;off&#34;)
    else:
        tod = np.where(self.thk &gt; 1, data[-1] - data[0], np.nan)
        ax3.set_title(&#34;Optimized - Initial&#34;)
        im3 = ax3.imshow(
            tod,
            origin=&#34;lower&#34;,
            vmin=minvardiff,
            vmax=maxvardiff,
            cmap=cm.get_cmap(&#34;RdBu&#34;, 10),
        )
        divider = make_axes_locatable(ax3)
        cax3 = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
        cbar3 = plt.colorbar(im3, format=&#34;%.0f&#34;, cax=cax3, orientation=&#34;vertical&#34;)
        ax3.axis(&#34;off&#34;)

    #########################################################

    plt.tight_layout()

    if plot_live:
        plt.show()
    else:
        plt.savefig(
            os.path.join(self.config.working_dir, &#34;resu-opti-&#34; + vari + &#34;-.png&#34;),
            pad_inches=0,
        )
        plt.close(&#34;all&#34;)</code></pre>
</details>
</dd>
<dt id="igm.igm.print_all_comp_info"><code class="name flex">
<span>def <span class="ident">print_all_comp_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This serves to print computational info report</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_all_comp_info(self):
    &#34;&#34;&#34;
    This serves to print computational info report
    &#34;&#34;&#34;

    print(&#34;Computational statistics report:&#34;)
    with open(
        os.path.join(self.config.working_dir, &#34;computational-statistics.txt&#34;), &#34;w&#34;
    ) as f:
        for key in self.tcomp.keys():
            CELA = (
                key,
                np.mean(self.tcomp[key][2:]),
                np.sum(self.tcomp[key][2:]),
                len(self.tcomp[key][2:]),
            )
            print(
                &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it : %8.0f&#34;
                % CELA,
                file=f,
            )
            print(
                &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it  : %8.0f&#34;
                % CELA
            )</code></pre>
</details>
</dd>
<dt id="igm.igm.print_comp_info_live"><code class="name flex">
<span>def <span class="ident">print_comp_info_live</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This serves to print computational info on the fly during computation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_comp_info_live(self):
    &#34;&#34;&#34;
    This serves to print computational info on the fly during computation
    &#34;&#34;&#34;
    if self.saveresult:
        for key in self.tcomp.keys():
            CELA = (
                key,
                np.mean(self.tcomp[key][2:]),
                np.sum(self.tcomp[key][2:]),
                len(self.tcomp[key][2:]),
            )
            print(
                &#34;     %15s  |  mean time per it : %8.4f  |  total : %8.4f  |  number it  : %8.0f&#34;
                % CELA
            )</code></pre>
</details>
</dd>
<dt id="igm.igm.print_info"><code class="name flex">
<span>def <span class="ident">print_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This serves to print key info on the fly during computation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_info(self):
    &#34;&#34;&#34;
    This serves to print key info on the fly during computation
    &#34;&#34;&#34;
    if self.saveresult:
        print(
            &#34;IGM %s : Iterations = %6.0f  |  Time = %8.0f  |  DT = %7.2f  |  Ice Volume (km^3) = %10.2f &#34;
            % (
                datetime.datetime.now().strftime(&#34;%H:%M:%S&#34;),
                self.it,
                self.t,
                self.dt_target,
                np.sum(self.thk) * (self.dx ** 2) / 10 ** 9,
            )
        )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param"><code class="name flex">
<span>def <span class="ident">read_config_param</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param(self):

    self.parser.add_argument(
        &#34;--working_dir&#34;, type=str, default=&#34;&#34;, help=&#34;Working directory&#34;
    )
    self.parser.add_argument(
        &#34;--geology_file&#34;, type=str, default=&#34;geology.nc&#34;, help=&#34;Geology input file&#34;
    )
    self.parser.add_argument(
        &#34;--resample&#34;, type=int, default=1, help=&#34;Upsample the data from geology.nc&#34;
    )
    self.parser.add_argument(
        &#34;--tstart&#34;, type=float, default=0.0, help=&#34;Starting time&#34;
    )
    self.parser.add_argument(&#34;--tend&#34;, type=float, default=150.0, help=&#34;End time&#34;)
    self.parser.add_argument(
        &#34;--restartingfile&#34;,
        type=str,
        default=&#34;&#34;,
        help=&#34;Provide restarting file if no empty string&#34;,
    )
    self.parser.add_argument(
        &#34;--verbosity&#34;,
        type=int,
        default=0,
        help=&#34;Verbosity level of IGM (default: 0 = no verbosity)&#34;,
    )
    self.parser.add_argument(
        &#34;--tsave&#34;, type=float, default=10, help=&#34;Save result each X years (10)&#34;
    )
    self.parser.add_argument(
        &#34;--plot_result&#34;,
        type=str2bool,
        default=False,
        help=&#34;Plot results in png&#34;,
    )
    self.parser.add_argument(
        &#34;--plot_live&#34;,
        type=str2bool,
        default=False,
        help=&#34;Display plots live the results during computation&#34;,
    )
    self.parser.add_argument(
        &#34;--usegpu&#34;,
        type=str2bool,
        default=True,
        help=&#34;Use the GPU for ice flow model (True)&#34;,
    )
    self.parser.add_argument(
        &#34;--stop&#34;,
        type=str2bool,
        default=False,
        help=&#34;experimental, just o get fair comp time, to be removed ....&#34;,
    )
    self.parser.add_argument(
        &#34;--init_strflowctrl&#34;,
        type=float,
        default=78,
        help=&#34;Initial strflowctrl&#34;,
    )

    self.parser.add_argument(
        &#34;--init_slidingco&#34;,
        type=float,
        default=0,
        help=&#34;Initial slidingco&#34;,
    )
    self.parser.add_argument(
        &#34;--init_arrhenius&#34;,
        type=float,
        default=78,
        help=&#34;Initial arrhenius&#34;,
    )

    self.parser.add_argument(
        &#34;--optimize&#34;,
        type=str2bool,
        default=False,
        help=&#34;Optimize prior forward modelling  (not available yet)&#34;,
    )
    self.parser.add_argument(
        &#34;--update_topg&#34;,
        type=str2bool,
        default=False,
        help=&#34;Update bedrock (not available yet)&#34;,
    )

    for p in dir(self):
        if &#34;read_config_param_&#34; in p:
            getattr(self, p)()</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_3dvel"><code class="name flex">
<span>def <span class="ident">read_config_param_3dvel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_3dvel(self):

    self.parser.add_argument(
        &#34;--vel3d_active&#34;,
        type=int,
        default=False,
        help=&#34;Is the computational of the 3D vel active?&#34;,
    )

    self.parser.add_argument(
        &#34;--dz&#34;,
        type=int,
        default=20,
        help=&#34;Vertical discretization constant spacing&#34;,
    )

    self.parser.add_argument(
        &#34;--maxthk&#34;, type=float, default=1000.0, help=&#34;Vertical maximum thickness&#34;
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_climate"><code class="name flex">
<span>def <span class="ident">read_config_param_climate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_climate(self):

    # CLIMATE PARAMETERS
    self.parser.add_argument(
        &#34;--clim_update_freq&#34;,
        type=float,
        default=1,
        help=&#34;Update the climate each X years (1)&#34;,
    )
    self.parser.add_argument(
        &#34;--type_climate&#34;,
        type=str,
        default=&#34;&#34;,
        help=&#34;toy or any custom climate&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_erosion"><code class="name flex">
<span>def <span class="ident">read_config_param_erosion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_erosion(self):

    self.parser.add_argument(
        &#34;--erosion_include&#34;,
        type=str2bool,
        default=False,
        help=&#34;Include a model for bedrock erosion&#34;,
    )
    self.parser.add_argument(
        &#34;--erosion_cst&#34;,
        type=float,
        default=2.7 * 10 ** (-7),
        help=&#34;Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193–195 (2015)&#34;,
    )

    self.parser.add_argument(
        &#34;--erosion_exp&#34;,
        type=float,
        default=2,
        help=&#34;Herman, F. et al. Erosion by an Alpine glacier. Science 350, 193–195 (2015).&#34;,
    )
    self.parser.add_argument(
        &#34;--erosion_update_freq&#34;,
        type=float,
        default=100,
        help=&#34;Update the erosion only each 100 years&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_iceflow"><code class="name flex">
<span>def <span class="ident">read_config_param_iceflow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_iceflow(self):

    self.parser.add_argument(
        &#34;--iceflow_model_lib_path&#34;,
        type=str,
        default=&#34;/home/jouvetg/IGM/model-lib/f12_cfsflow&#34;,
        help=&#34;model directory&#34;,
    )
    self.parser.add_argument(
        &#34;--multiple_window_size&#34;,
        type=int,
        default=0,
        help=&#34;In case the mdel is a unet, it must force window size to be multiple of e.g. 8&#34;,
    )
    self.parser.add_argument(
        &#34;--force_max_velbar&#34;,
        type=float,
        default=0,
        help=&#34;This permits to artificially upper-bound velocities, active if &gt; 0&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_optimize"><code class="name flex">
<span>def <span class="ident">read_config_param_optimize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_optimize(self):

    # OPTIMIZATION PARAMETERS
    self.parser.add_argument(
        &#34;--opti_vars_to_save&#34;,
        type=list,
        default=[
            &#34;topg&#34;,
            &#34;usurf&#34;,
            &#34;thk&#34;,
            &#34;strflowctrl&#34;,
            &#34;arrhenius&#34;,
            &#34;slidingco&#34;,
            &#34;velsurf_mag&#34;,
            &#34;velsurfobs_mag&#34;,
            &#34;divflux&#34;,
        ],
        help=&#34;List of variables to be recorded in the ncdef file&#34;,
    )
    self.parser.add_argument(
        &#34;--observation_file&#34;,
        type=str,
        default=&#34;observation.nc&#34;,
        help=&#34;Observation file contains the 2D data observations fields (thkobs, usurfobs, uvelsurfobs, ....) &#34;,
    )
    self.parser.add_argument(
        &#34;--thk_profiles_file&#34;,
        type=str,
        default=&#34;&#34;,
        help=&#34;Provide ice thickness measurements, if empty string it will look for rasterized thk in the input data file&#34;,
    )
    self.parser.add_argument(&#34;--mode_opti&#34;, type=str, default=&#34;thkstrflowctrl&#34;)

    self.parser.add_argument(
        &#34;--opti_thr_strflowctrl&#34;,
        type=float,
        default=78.0,
        help=&#34;threshold value for strflowctrl&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_init_zero_thk&#34;,
        type=str2bool,
        default=&#34;False&#34;,
        help=&#34;Initialize the optimization with zero ice thickness&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_regu_param_thk&#34;,
        type=float,
        default=10.0,
        help=&#34;Regularization weight for the ice thickness in the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_regu_param_strflowctrl&#34;,
        type=float,
        default=1.0,
        help=&#34;Regularization weight for the strflowctrl field in the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_smooth_anisotropy_factor&#34;,
        type=float,
        default=0.2,
        help=&#34;Smooth anisotropy factor for the ice thickness regularization in the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_convexity_weight&#34;,
        type=float,
        default=0.002,
        help=&#34;Convexity weight for the ice thickness regularization in the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_usurfobs_std&#34;,
        type=float,
        default=5.0,
        help=&#34;Confidence/STD of the top ice surface as input data for the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_strflowctrl_std&#34;,
        type=float,
        default=5.0,
        help=&#34;Confidence/STD of strflowctrl&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_velsurfobs_std&#34;,
        type=float,
        default=3.0,
        help=&#34;Confidence/STD of the surface ice velocities as input data for the optimization (if 0, velsurfobs_std field must be given)&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_thkobs_std&#34;,
        type=float,
        default=5.0,
        help=&#34;Confidence/STD of the ice thickness profiles (unless given)&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_divfluxobs_std&#34;,
        type=float,
        default=1.0,
        help=&#34;Confidence/STD of the flux divergence as input data for the optimization (if 0, divfluxobs_std field must be given)&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_control&#34;,
        type=list,
        default=[&#34;thk&#34;, &#34;strflowctrl&#34;, &#34;usurf&#34;],
        help=&#34;List of optimized variables for the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_cost&#34;,
        type=list,
        default=[&#34;velsurf&#34;, &#34;thk&#34;, &#34;usurf&#34;, &#34;divfluxfcz&#34;, &#34;icemask&#34;],
        help=&#34;List of cost components for the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_nbitmin&#34;,
        type=int,
        default=50,
        help=&#34;Min iterations for the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_nbitmax&#34;,
        type=int,
        default=1000,
        help=&#34;Max iterations for the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_step_size&#34;,
        type=float,
        default=0.001,
        help=&#34;Step size for the optimization&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_make_holes_in_data&#34;,
        type=int,
        default=0,
        help=&#34;This produces artifical holes in data, serve to test the robustness of the method to missing data&#34;,
    )
    self.parser.add_argument(
        &#34;--opti_output_freq&#34;,
        type=int,
        default=50,
        help=&#34;Frequency of the output for the optimization&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_output_ncdf"><code class="name flex">
<span>def <span class="ident">read_config_param_output_ncdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_output_ncdf(self):

    self.parser.add_argument(
        &#34;--vars_to_save&#34;,
        type=list,
        default=[
            &#34;topg&#34;,
            &#34;usurf&#34;,
            &#34;thk&#34;,
            &#34;smb&#34;,
            &#34;velbar_mag&#34;,
            &#34;velsurf_mag&#34;,
        ],
        help=&#34;List of variables to be recorded in the ncdef file&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_plot"><code class="name flex">
<span>def <span class="ident">read_config_param_plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_plot(self):

    self.parser.add_argument(
        &#34;--varplot&#34;,
        type=str,
        default=&#34;velbar_mag&#34;,
        help=&#34;variable to plot&#34;,
    )
    self.parser.add_argument(
        &#34;--varplot_max&#34;,
        type=float,
        default=500,
        help=&#34;maximum value of the varplot variable used to adjust the scaling of the colorbar&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_smb"><code class="name flex">
<span>def <span class="ident">read_config_param_smb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_smb(self):

    self.parser.add_argument(
        &#34;--mb_update_freq&#34;,
        type=float,
        default=1,
        help=&#34;Update the mass balance each X years (1)&#34;,
    )
    self.parser.add_argument(
        &#34;--type_mass_balance&#34;,
        type=str,
        default=&#34;simple&#34;,
        help=&#34;zero, simple, given&#34;,
    )
    self.parser.add_argument(
        &#34;--mb_scaling&#34;, type=float, default=1.0, help=&#34;mass balance scaling&#34;
    )
    self.parser.add_argument(
        &#34;--mb_simple_file&#34;,
        type=str,
        default=&#34;mb_simple_param.txt&#34;,
        help=&#34;mb_simple_file&#34;,
    )
    self.parser.add_argument(
        &#34;--smb_model_lib_path&#34;,
        type=str,
        default=&#34;/home/jouvetg/IGM/model-lib/smb_meteoswissglamos&#34;,
        help=&#34;Model directory in case the smb model in use is &#39;nn&#39;for neural netowrk&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_config_param_t_dt"><code class="name flex">
<span>def <span class="ident">read_config_param_t_dt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_config_param_t_dt(self):

    # NUMERICL PARAMETER FOR TIME STEP
    self.parser.add_argument(
        &#34;--cfl&#34;, type=float, default=0.3, help=&#34;CFL number must be below 1 (0.3)&#34;
    )
    self.parser.add_argument(
        &#34;--dtmax&#34;,
        type=float,
        default=10.0,
        help=&#34;Maximum time step, used only with slow ice (10.0)&#34;,
    )</code></pre>
</details>
</dd>
<dt id="igm.igm.read_fields_and_bounds"><code class="name flex">
<span>def <span class="ident">read_fields_and_bounds</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>get fields (input and outputs) from given file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_fields_and_bounds(self, path):
    &#34;&#34;&#34;
    get fields (input and outputs) from given file
    &#34;&#34;&#34;

    fieldbounds = {}
    fieldin = []
    fieldout = []

    fid = open(os.path.join(path, &#34;fieldin.dat&#34;), &#34;r&#34;)
    for fileline in fid:
        part = fileline.split()
        fieldin.append(part[0])
        fieldbounds[part[0]] = float(part[1])
    fid.close()

    fid = open(os.path.join(path, &#34;fieldout.dat&#34;), &#34;r&#34;)
    for fileline in fid:
        part = fileline.split()
        fieldout.append(part[0])
        fieldbounds[part[0]] = float(part[1])
    fid.close()

    return fieldin, fieldout, fieldbounds</code></pre>
</details>
</dd>
<dt id="igm.igm.restart"><code class="name flex">
<span>def <span class="ident">restart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Permit to restart a simulation from a ncdf file y taking the last iterate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restart(self):
    &#34;&#34;&#34;
    Permit to restart a simulation from a ncdf file y taking the last iterate
    &#34;&#34;&#34;
    if self.config.verbosity == 1:
        print(&#34;READ RESTARTING FILE, OVERIDE FIELDS WHEN GIVEN&#34;)

    nc = Dataset(self.config.restartingfile, &#34;r&#34;)

    Rx = tf.constant(np.squeeze(nc.variables[&#34;x&#34;]).astype(&#34;float32&#34;))
    Ry = tf.constant(np.squeeze(nc.variables[&#34;y&#34;]).astype(&#34;float32&#34;))

    assert Rx.shape == self.x.shape
    assert Ry.shape == self.y.shape

    for var in nc.variables:
        if not var in [&#34;x&#34;, &#34;y&#34;]:
            vars(self)[var].assign(
                np.squeeze(nc.variables[var][-1]).astype(&#34;float32&#34;)
            )

    nc.close()</code></pre>
</details>
</dd>
<dt id="igm.igm.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):

    self.initialize()

    with tf.device(self.device_name):

        self.load_ncdf_data(self.config.geology_file)

        self.initialize_fields()

        if len(self.config.restartingfile) &gt; 0:
            self.restart(-1)

        self.initialize_iceflow()

        self.update_climate()

        self.update_smb()

        if self.config.optimize:
            self.optimize()

        self.update_iceflow()

        self.update_ncdf_ex()

        self.update_ncdf_ts()

        if self.config.vel3d_active:
            self.init_3dvel()

        self.print_info()

        while self.t.numpy() &lt; self.config.tend:

            self.tcomp[&#34;All&#34;].append(time.time())

            if self.config.vel3d_active:
                self.update_3dvel()

            self.update_climate()

            self.update_smb()

            self.update_iceflow()

            self.update_t_dt()

            self.update_thk()

            if self.config.update_topg:
                self.update_topg()

            self.update_ncdf_ex()

            self.update_ncdf_ts()

            self.update_plot()

            self.print_info()

            self.tcomp[&#34;All&#34;][-1] -= time.time()
            self.tcomp[&#34;All&#34;][-1] *= -1

    self.print_all_comp_info()</code></pre>
</details>
</dd>
<dt id="igm.igm.run_opti"><code class="name flex">
<span>def <span class="ident">run_opti</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_opti(self):

    self.initialize()

    with tf.device(self.device_name):

        self.load_ncdf_data(self.config.observation_file)

        self.initialize_fields()

        self.initialize_iceflow()

        self.optimize()</code></pre>
</details>
</dd>
<dt id="igm.igm.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this is a dummy stop that serves to syncrohnize CPU and GPU for reliable computational times</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;
    this is a dummy stop that serves to syncrohnize CPU and GPU for reliable computational times
    &#34;&#34;&#34;
    ubar_np = self.ubar.numpy()
    thk_np = self.thk.numpy()
    mb_np = self.smb.numpy()</code></pre>
</details>
</dd>
<dt id="igm.igm.update_3dvel"><code class="name flex">
<span>def <span class="ident">update_3dvel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_3dvel(self):

    if self.config.vel3d_active:

        if self.config.verbosity == 1:
            print(&#34;update_3dvel &#34;)

        self.tcomp[&#34;3d Vel&#34;].append(time.time())

        self.update_vert_disc_tf()

        self.update_reconstruct_3dvel_tf()

        self.update_ncdf_3d_ex()

        self.tcomp[&#34;3d Vel&#34;][-1] -= time.time()
        self.tcomp[&#34;3d Vel&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_climate"><code class="name flex">
<span>def <span class="ident">update_climate</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>compute climate at time t</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_climate(self, force=False):
    &#34;&#34;&#34;
    compute climate at time t
    &#34;&#34;&#34;

    if len(self.config.type_climate) &gt; 0:

        if not hasattr(self, &#34;already_called_update_climate&#34;):

            getattr(self, &#34;load_climate_data_&#34; + self.config.type_climate)()
            self.tlast_clim = -1.0e5000
            self.tcomp[&#34;Climate&#34;] = []
            self.already_called_update_climate = True

        new_clim_needed = (
            self.t.numpy() - self.tlast_clim
        ) &gt;= self.config.clim_update_freq

        if force | new_clim_needed:

            if self.config.verbosity == 1:
                print(&#34;Construct climate at time : &#34;, igm.t)

            self.tcomp[&#34;Climate&#34;].append(time.time())

            getattr(self, &#34;update_climate_&#34; + self.config.type_climate)()

            self.tlast_clim = self.t.numpy()

            self.tcomp[&#34;Climate&#34;][-1] -= time.time()
            self.tcomp[&#34;Climate&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_iceflow"><code class="name flex">
<span>def <span class="ident">update_iceflow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function update the ice flow using the neural network emulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_iceflow(self):
    &#34;&#34;&#34;
    function update the ice flow using the neural network emulator
    &#34;&#34;&#34;

    if self.config.verbosity == 1:
        print(&#34;Update ICEFLOW at time : &#34;, igm.t)

    self.tcomp[&#34;Ice flow&#34;].append(time.time())

    X = tf.expand_dims(
        tf.stack(
            [
                tf.pad(vars(self)[f], self.PAD, &#34;CONSTANT&#34;)
                / self.iceflow_fieldbounds[f]
                for f in self.iceflow_mapping[&#34;fieldin&#34;]
            ],
            axis=-1,
        ),
        axis=0,
    )

    Y = self.iceflow_model.predict_on_batch(X)

    Ny, Nx = self.thk.shape
    for kk, f in enumerate(self.iceflow_mapping[&#34;fieldout&#34;]):
        vars(self)[f].assign(
            tf.where(self.thk &gt; 0, Y[0, :Ny, :Nx, kk], 0)
            * self.iceflow_fieldbounds[f]
        )

    if self.config.force_max_velbar &gt; 0:

        self.velbar_mag = self.getmag(self.ubar, self.vbar)

        self.ubar.assign(
            tf.where(
                self.velbar_mag &gt;= self.config.force_max_velbar,
                self.config.force_max_velbar * (self.ubar / self.velbar_mag),
                self.ubar,
            )
        )
        self.vbar.assign(
            tf.where(
                self.velbar_mag &gt;= self.config.force_max_velbar,
                self.config.force_max_velbar * (self.vbar / self.velbar_mag),
                self.vbar,
            )
        )

    self.tcomp[&#34;Ice flow&#34;][-1] -= time.time()
    self.tcomp[&#34;Ice flow&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_ncdf_3d_ex"><code class="name flex">
<span>def <span class="ident">update_ncdf_3d_ex</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize
and write the ncdf output file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ncdf_3d_ex(self, force=False):
    &#34;&#34;&#34;
    Initialize  and write the ncdf output file
    &#34;&#34;&#34;

    if force | self.saveresult:

        if self.it == 0:

            if self.config.verbosity == 1:
                print(&#34;Initialize NCDF output Files&#34;)

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;ex3d.nc&#34;),
                &#34;w&#34;,
                format=&#34;NETCDF4&#34;,
            )

            nc.createDimension(&#34;time&#34;, None)
            E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
            E.units = &#34;yr&#34;
            E.long_name = &#34;time&#34;
            E.axis = &#34;T&#34;
            E[0] = self.t.numpy()

            nc.createDimension(&#34;h&#34;, self.height.shape[0])
            E = nc.createVariable(&#34;h&#34;, np.dtype(&#34;float32&#34;).char, (&#34;h&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;h&#34;
            E.standard_name = &#34;h&#34;
            E.axis = &#34;H&#34;
            E[:] = self.height

            nc.createDimension(&#34;y&#34;, len(self.y))
            E = nc.createVariable(&#34;y&#34;, np.dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;y&#34;
            E.axis = &#34;Y&#34;
            E[:] = self.y.numpy()

            nc.createDimension(&#34;x&#34;, len(self.x))
            E = nc.createVariable(&#34;x&#34;, np.dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;x&#34;
            E.axis = &#34;X&#34;
            E[:] = self.x.numpy()

            E = nc.createVariable(
                &#34;topg&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
            )
            E.units = &#34;m&#34;
            E.long_name = &#34;topg&#34;
            E.standard_name = &#34;topg&#34;
            E[0, :, :] = self.topg.numpy()

            E = nc.createVariable(
                &#34;usurf&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
            )
            E.units = &#34;m&#34;
            E.long_name = &#34;usurf&#34;
            E.standard_name = &#34;usurf&#34;
            E[0, :, :] = self.usurf.numpy()

            E = nc.createVariable(
                &#34;U&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
            )
            E.units = &#34;m/y&#34;
            E.long_name = &#34;U&#34;
            E.standard_name = &#34;U&#34;
            E[0, :, :, :] = self.U.numpy()

            E = nc.createVariable(
                &#34;V&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
            )
            E.units = &#34;m/y&#34;
            E.long_name = &#34;V&#34;
            E.standard_name = &#34;V&#34;
            E[0, :, :, :] = self.V.numpy()

            E = nc.createVariable(
                &#34;W&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;h&#34;, &#34;y&#34;, &#34;x&#34;)
            )
            E.units = &#34;m/y&#34;
            E.long_name = &#34;W&#34;
            E.standard_name = &#34;W&#34;
            E[0, :, :, :] = self.W.numpy()

            nc.close()

        else:

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;ex3d.nc&#34;),
                &#34;a&#34;,
                format=&#34;NETCDF4&#34;,
            )

            d = nc.variables[&#34;time&#34;][:].shape[0]
            nc.variables[&#34;time&#34;][d] = self.t.numpy()
            nc.variables[&#34;U&#34;][d, :, :, :] = self.U.numpy()
            nc.variables[&#34;V&#34;][d, :, :, :] = self.V.numpy()
            nc.variables[&#34;W&#34;][d, :, :, :] = self.W.numpy()
            nc.variables[&#34;usurf&#34;][d, :, :] = self.usurf.numpy()
            nc.variables[&#34;topg&#34;][d, :, :] = self.topg.numpy()

            nc.close()</code></pre>
</details>
</dd>
<dt id="igm.igm.update_ncdf_ex"><code class="name flex">
<span>def <span class="ident">update_ncdf_ex</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize
and write the ncdf output file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ncdf_ex(self, force=False):
    &#34;&#34;&#34;
    Initialize  and write the ncdf output file
    &#34;&#34;&#34;

    if not hasattr(self, &#34;already_called_update_ncdf_ex&#34;):
        self.tcomp[&#34;Outputs ncdf&#34;] = []
        self.already_called_update_ncdf_ex = True

    if force | self.saveresult:

        self.tcomp[&#34;Outputs ncdf&#34;].append(time.time())

        if &#34;velbar_mag&#34; in self.config.vars_to_save:
            self.velbar_mag = self.getmag(self.ubar, self.vbar)

        if &#34;velsurf_mag&#34; in self.config.vars_to_save:
            self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

        if &#34;velbase_mag&#34; in self.config.vars_to_save:
            self.velbase_mag = self.getmag(self.uvelbase, self.vvelbase)

        if &#34;meanprec&#34; in self.config.vars_to_save:
            self.meanprec = tf.math.reduce_mean(self.precipitation, axis=0)

        if &#34;meantemp&#34; in self.config.vars_to_save:
            self.meantemp = tf.math.reduce_mean(self.air_temp, axis=0)

        if self.it == 0:

            if self.config.verbosity == 1:
                print(&#34;Initialize NCDF output Files&#34;)

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;ex.nc&#34;),
                &#34;w&#34;,
                format=&#34;NETCDF4&#34;,
            )

            nc.createDimension(&#34;time&#34;, None)
            E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
            E.units = &#34;yr&#34;
            E.long_name = &#34;time&#34;
            E.axis = &#34;T&#34;
            E[0] = self.t.numpy()

            nc.createDimension(&#34;y&#34;, len(self.y))
            E = nc.createVariable(&#34;y&#34;, np.dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;y&#34;
            E.axis = &#34;Y&#34;
            E[:] = self.y.numpy()

            nc.createDimension(&#34;x&#34;, len(self.x))
            E = nc.createVariable(&#34;x&#34;, np.dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
            E.units = &#34;m&#34;
            E.long_name = &#34;x&#34;
            E.axis = &#34;X&#34;
            E[:] = self.x.numpy()

            for var in self.config.vars_to_save:

                E = nc.createVariable(
                    var, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;, &#34;y&#34;, &#34;x&#34;)
                )
                E.long_name = self.var_info[var][0]
                E.units = self.var_info[var][1]
                E[0, :, :] = vars(self)[var].numpy()

            nc.close()

        else:

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;ex.nc&#34;),
                &#34;a&#34;,
                format=&#34;NETCDF4&#34;,
            )

            d = nc.variables[&#34;time&#34;][:].shape[0]
            nc.variables[&#34;time&#34;][d] = self.t.numpy()

            for var in self.config.vars_to_save:
                nc.variables[var][d, :, :] = vars(self)[var].numpy()

            nc.close()

        self.tcomp[&#34;Outputs ncdf&#34;][-1] -= time.time()
        self.tcomp[&#34;Outputs ncdf&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_ncdf_optimize"><code class="name flex">
<span>def <span class="ident">update_ncdf_optimize</span></span>(<span>self, it)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize and write the ncdf optimze file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ncdf_optimize(self, it):
    &#34;&#34;&#34;
    Initialize and write the ncdf optimze file
    &#34;&#34;&#34;

    if self.config.verbosity == 1:
        print(&#34;Initialize  and write NCDF output Files&#34;)

    if &#34;arrhenius&#34; in self.config.opti_vars_to_save:
        self.arrhenius = tf.where(
            self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
            self.strflowctrl,
            self.config.opti_thr_strflowctrl,
        )

    if &#34;slidingco&#34; in self.config.opti_vars_to_save:
        self.slidingco = tf.where(
            self.strflowctrl &lt;= self.config.opti_thr_strflowctrl,
            0,
            self.strflowctrl - self.config.opti_thr_strflowctrl,
        )

    if &#34;topg&#34; in self.config.opti_vars_to_save:
        self.topg.assign(self.usurf - self.thk)

    if &#34;velsurf_mag&#34; in self.config.opti_vars_to_save:
        self.velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf)

    if &#34;velsurfobs_mag&#34; in self.config.opti_vars_to_save:
        self.velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs)

    if it == 0:

        nc = Dataset(
            os.path.join(self.config.working_dir, &#34;optimize.nc&#34;),
            &#34;w&#34;,
            format=&#34;NETCDF4&#34;,
        )

        nc.createDimension(&#34;iterations&#34;, None)
        E = nc.createVariable(&#34;iterations&#34;, dtype(&#34;float32&#34;).char, (&#34;iterations&#34;,))
        E.units = &#34;None&#34;
        E.long_name = &#34;iterations&#34;
        E.axis = &#34;ITERATIONS&#34;
        E[0] = it

        nc.createDimension(&#34;y&#34;, len(self.y))
        E = nc.createVariable(&#34;y&#34;, dtype(&#34;float32&#34;).char, (&#34;y&#34;,))
        E.units = &#34;m&#34;
        E.long_name = &#34;y&#34;
        E.axis = &#34;Y&#34;
        E[:] = self.y.numpy()

        nc.createDimension(&#34;x&#34;, len(self.x))
        E = nc.createVariable(&#34;x&#34;, dtype(&#34;float32&#34;).char, (&#34;x&#34;,))
        E.units = &#34;m&#34;
        E.long_name = &#34;x&#34;
        E.axis = &#34;X&#34;
        E[:] = self.x.numpy()

        for var in self.config.opti_vars_to_save:

            E = nc.createVariable(
                var, dtype(&#34;float32&#34;).char, (&#34;iterations&#34;, &#34;y&#34;, &#34;x&#34;)
            )
            # E.long_name = self.var_info[var][0]
            # E.units = self.var_info[var][1]
            E[0, :, :] = vars(self)[var].numpy()

        nc.close()

    else:

        nc = Dataset(
            os.path.join(self.config.working_dir, &#34;optimize.nc&#34;),
            &#34;a&#34;,
            format=&#34;NETCDF4&#34;,
        )

        d = nc.variables[&#34;iterations&#34;][:].shape[0]

        nc.variables[&#34;iterations&#34;][d] = it

        for var in self.config.opti_vars_to_save:
            nc.variables[var][d, :, :] = vars(self)[var].numpy()

        nc.close()</code></pre>
</details>
</dd>
<dt id="igm.igm.update_ncdf_ts"><code class="name flex">
<span>def <span class="ident">update_ncdf_ts</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize
and write the ncdf time serie file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ncdf_ts(self, force=False):
    &#34;&#34;&#34;
    Initialize  and write the ncdf time serie file
    &#34;&#34;&#34;

    if not hasattr(self, &#34;already_called_update_ncdf_ts&#34;):
        self.already_called_update_ncdf_ts = True

    if force | self.saveresult:

        vol = np.sum(self.thk) * (self.dx ** 2) / 10 ** 9
        area = np.sum(self.thk &gt; 1) * (self.dx ** 2) / 10 ** 6

        if self.it == 0:

            if self.config.verbosity == 1:
                print(&#34;Initialize NCDF output Files&#34;)

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;ts.nc&#34;),
                &#34;w&#34;,
                format=&#34;NETCDF4&#34;,
            )

            nc.createDimension(&#34;time&#34;, None)
            E = nc.createVariable(&#34;time&#34;, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;,))
            E.units = &#34;yr&#34;
            E.long_name = &#34;time&#34;
            E.axis = &#34;T&#34;
            E[0] = self.t.numpy()

            for var in [&#34;vol&#34;, &#34;area&#34;]:
                E = nc.createVariable(var, np.dtype(&#34;float32&#34;).char, (&#34;time&#34;))
                E[0] = vars()[var].numpy()
                E.long_name = self.var_info[var][0]
                E.units = self.var_info[var][1]
            nc.close()

        else:

            nc = Dataset(
                os.path.join(self.config.working_dir, &#34;ts.nc&#34;),
                &#34;a&#34;,
                format=&#34;NETCDF4&#34;,
            )
            d = nc.variables[&#34;time&#34;][:].shape[0]

            nc.variables[&#34;time&#34;][d] = self.t.numpy()
            for var in [&#34;vol&#34;, &#34;area&#34;]:
                nc.variables[var][d] = vars()[var].numpy()
            nc.close()</code></pre>
</details>
</dd>
<dt id="igm.igm.update_plot"><code class="name flex">
<span>def <span class="ident">update_plot</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot thickness, velocity, mass balance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot(self, force=False):
    &#34;&#34;&#34;
    Plot thickness, velocity, mass balance
    &#34;&#34;&#34;

    if force | (self.saveresult &amp; self.config.plot_result):

        firstime = False
        if not hasattr(self, &#34;already_called_update_plot&#34;):
            self.already_called_update_plot = True
            self.tcomp[&#34;Outputs plot&#34;] = []
            firstime = True

        self.tcomp[&#34;Outputs plot&#34;].append(time.time())

        if self.config.varplot == &#34;velbar_mag&#34;:
            self.velbar_mag = self.getmag(self.ubar, self.vbar)

        if firstime:

            self.fig = plt.figure(dpi=200)
            self.ax = self.fig.add_subplot(1, 1, 1)
            self.ax.axis(&#34;off&#34;)
            im = self.ax.imshow(
                vars(self)[self.config.varplot],
                origin=&#34;lower&#34;,
                cmap=&#34;viridis&#34;,
                vmin=0,
                vmax=self.config.varplot_max,
            )
            self.ax.set_title(&#34;YEAR : &#34; + str(self.t.numpy()), size=15)
            self.cbar = plt.colorbar(im)

        else:
            im = self.ax.imshow(
                vars(self)[self.config.varplot],
                origin=&#34;lower&#34;,
                cmap=&#34;viridis&#34;,
                vmin=0,
                vmax=self.config.varplot_max,
            )
            self.ax.set_title(&#34;YEAR : &#34; + str(self.t.numpy()), size=15)

        if self.config.plot_live:
            clear_output(wait=True)
            display(self.fig)

        else:
            plt.savefig(
                os.path.join(
                    self.config.working_dir,
                    self.config.varplot
                    + &#34;-&#34;
                    + str(self.t.numpy()).zfill(4)
                    + &#34;.png&#34;,
                ),
                bbox_inches=&#34;tight&#34;,
                pad_inches=0.2,
            )

        self.tcomp[&#34;Outputs plot&#34;][-1] -= time.time()
        self.tcomp[&#34;Outputs plot&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_plot_inversion"><code class="name flex">
<span>def <span class="ident">update_plot_inversion</span></span>(<span>self, i, plot_live)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot thickness, velocity, mand slidingco</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot_inversion(self, i, plot_live):
    &#34;&#34;&#34;
    Plot thickness, velocity, mand slidingco
    &#34;&#34;&#34;

    if self.config.plot_result:

        if hasattr(self, &#34;uvelsurfobs&#34;):
            velsurfobs_mag = self.getmag(self.uvelsurfobs, self.vvelsurfobs).numpy()
        else:
            velsurfobs_mag = np.zeros_like(self.thk.numpy())

        if hasattr(self, &#34;usurfobs&#34;):
            usurfobs = self.usurfobs
        else:
            usurfobs = np.zeros_like(self.thk.numpy())

        ########################################################

        fig = plt.figure(figsize=(18, 13))

        #########################################################

        ax = fig.add_subplot(2, 3, 1)
        extent = [self.x[0], self.x[-1], self.y[0], self.y[-1]]
        im1 = ax.imshow(self.thk, origin=&#34;lower&#34;, extent=extent, vmin=0, vmax=800)
        plt.colorbar(im1)

        if hasattr(self, &#34;profile&#34;):
            fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))
            for j, p in enumerate(self.profile):
                if j &gt; 0:
                    meanfitprofile = np.mean(
                        fthk(p[:, 1], p[:, 2], grid=False) - p[:, 3]
                    )
                    ax.scatter(p[:, 1], p[:, 2], c=&#34;k&#34;, s=1)
                    ax.text(
                        np.mean(p[:, 1]),
                        np.mean(p[:, 2]),
                        str(int(meanfitprofile)),
                        fontsize=15,
                    )

        ax.set_title(
            &#34;THK, RMS : &#34;
            + str(int(self.rmsthk[-1]))
            + &#34;, STD : &#34;
            + str(int(self.stdthk[-1])),
            size=15,
        )
        ax.axis(&#34;off&#34;)

        #########################################################

        ax = fig.add_subplot(2, 3, 2)
        velsurf_mag = self.getmag(self.uvelsurf, self.vvelsurf).numpy()
        im1 = ax.imshow(
            velsurf_mag, origin=&#34;lower&#34;, vmin=0, vmax=np.nanmax(velsurfobs_mag)
        )
        plt.colorbar(im1, format=&#34;%.2f&#34;)
        ax.set_title(
            &#34;MOD VEL, RMS : &#34;
            + str(int(self.rmsvel[-1]))
            + &#34;, STD : &#34;
            + str(int(self.stdvel[-1])),
            size=15,
        )
        ax.axis(&#34;off&#34;)

        ########################################################

        ax = fig.add_subplot(2, 3, 3)
        im1 = ax.imshow(self.divflux, origin=&#34;lower&#34;, vmin=-15, vmax=5)
        plt.colorbar(im1, format=&#34;%.2f&#34;)
        ax.set_title(
            &#34;MOD DIV, RMS : %5.1f , STD : %5.1f&#34;
            % (self.rmsdiv[-1], self.stddiv[-1]),
            size=15,
        )
        ax.axis(&#34;off&#34;)

        #########################################################

        ax = fig.add_subplot(2, 3, 4)
        im1 = ax.imshow(self.usurf - usurfobs, origin=&#34;lower&#34;, vmin=-10, vmax=10)
        plt.colorbar(im1, format=&#34;%.2f&#34;)
        ax.set_title(
            &#34;DELTA USURF, RMS : %5.1f , STD : %5.1f&#34;
            % (self.rmsusurf[-1], self.stdusurf[-1]),
            size=15,
        )
        ax.axis(&#34;off&#34;)

        ########################################################

        ax = fig.add_subplot(2, 3, 5)
        im1 = ax.imshow(
            velsurfobs_mag, origin=&#34;lower&#34;, vmin=0, vmax=np.nanmax(velsurfobs_mag)
        )
        plt.colorbar(im1, format=&#34;%.2f&#34;)
        ax.set_title(&#34;OBS VEL (TARGET)&#34;, size=15)
        ax.axis(&#34;off&#34;)

        #######################################################

        ax = fig.add_subplot(2, 3, 6)
        im1 = ax.imshow(self.strflowctrl, origin=&#34;lower&#34;, vmin=50, vmax=110)
        plt.colorbar(im1, format=&#34;%.2f&#34;)
        ax.set_title(&#34;strflowctrl&#34;, size=15)
        ax.axis(&#34;off&#34;)

        #########################################################

        plt.tight_layout()

        if plot_live:
            plt.show()
        else:
            plt.savefig(
                os.path.join(
                    self.config.working_dir, &#34;resu-opti-&#34; + str(i).zfill(4) + &#34;.png&#34;
                ),
                pad_inches=0,
            )
            plt.close(&#34;all&#34;)</code></pre>
</details>
</dd>
<dt id="igm.igm.update_plot_profiles"><code class="name flex">
<span>def <span class="ident">update_plot_profiles</span></span>(<span>self, i, plot_live)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot_profiles(self, i, plot_live):

    from scipy.interpolate import RectBivariateSpline

    fthk = RectBivariateSpline(self.x, self.y, np.transpose(self.thk))

    N = len(self.profile)
    N1 = int(np.sqrt(N)) + 1
    N2 = N1
    fig, axs = plt.subplots(N1, N2, figsize=(N1 * 10, N2 * 5))
    #            fig, axs = plt.subplots(N,1,figsize=(10,N*4))
    for j, p in enumerate(self.profile):
        if j &gt; 0:
            jj = j // N1
            ii = j % N1
            axs[ii, jj].set_title(&#34; PROFILE N° : &#34; + str(j))
            axs[ii, jj].plot(p[:, 0], p[:, 3], &#34;-k&#34;)
            axs[ii, jj].plot(p[:, 0], fthk(p[:, 1], p[:, 2], grid=False), &#34;-b&#34;)
            axs[ii, jj].axis(&#34;equal&#34;)
    plt.tight_layout()

    if plot_live:
        plt.show()
    else:
        plt.savefig(
            os.path.join(
                self.config.working_dir, &#34;S1-pro-&#34; + str(i).zfill(4) + &#34;.png&#34;
            ),
            pad_inches=0,
        )
        plt.close(&#34;all&#34;)</code></pre>
</details>
</dd>
<dt id="igm.igm.update_reconstruct_3dvel_tf"><code class="name flex">
<span>def <span class="ident">update_reconstruct_3dvel_tf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.function()
def update_reconstruct_3dvel_tf(self):

    # Reconstruct the horizontal velocity field from basal and surface velocity assuming a SIA-like profile
    fshear = []
    U = []
    V = []
    W = []

    fshear.append(tf.zeros_like(self.thk))

    for k in range(1, self.height.shape[0]):
        fshear.append(
            fshear[-1]
            + tf.where(k &lt; self.nz, self.dz[k - 1], 0.0) * (self.depth[k] ** 3)
        )

    norm = fshear[-1]

    for k in range(0, self.height.shape[0]):
        fshear[k] /= tf.where(self.nz &gt; 1, norm, 1.0)

    for k in range(0, self.height.shape[0]):
        U.append(self.uvelbase + fshear[k] * (self.uvelsurf - self.uvelbase))
        V.append(self.vvelbase + fshear[k] * (self.vvelsurf - self.vvelbase))

    self.U.assign(tf.stack(U, axis=0))
    self.V.assign(tf.stack(V, axis=0))

    Ui = tf.pad(self.U, [[0, 0], [0, 0], [1, 1]], &#34;SYMMETRIC&#34;)
    Vj = tf.pad(self.V, [[0, 0], [1, 1], [0, 0]], &#34;SYMMETRIC&#34;)

    ######### THis methods reconstruct the vertical velocity using divflux,
    ######### and assuming a SIA-like profile like x- and y- components

    slopsurfx, slopsurfy = self.compute_gradient_tf(self.usurf, self.dx, self.dx)
    sloptopgx, sloptopgy = self.compute_gradient_tf(self.topg, self.dx, self.dx)

    divflux = self.compute_divflux(self.ubar, self.vbar, self.thk, self.dx, self.dx)

    self.wvelbase = self.uvelbase * sloptopgx + self.vvelbase * sloptopgy
    self.wvelsurf = -divflux + self.uvelsurf * slopsurfx + self.vvelsurf * slopsurfy

    for k in range(0, self.height.shape[0]):
        W.append(self.wvelbase + fshear[k] * (self.wvelsurf - self.wvelbase))

    self.W.assign(tf.stack(W, axis=0))

    ### This methods integrates the imcompressiblity conditoons

    # W.append( tf.zeros_like(self.thk) )

    # for k in range(1,self.height.shape[0]):
    #     W.append( W[-1] + tf.where( k&lt;self.nz, \
    #                                 self.dz[k-1] * ( - (Ui[k-1,:, 2:] - Ui[k-1,:,:-2]) / (2*self.dx) \
    #                                                  - (Vj[k-1,2:, :] - Vj[k-1,:-2,:]) / (2*self.dx) ), \
    #                                 0.0 )
    #             )

    # self.W.assign( tf.stack(W,axis=0) )</code></pre>
</details>
</dd>
<dt id="igm.igm.update_smb"><code class="name flex">
<span>def <span class="ident">update_smb</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>update_mass balance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_smb(self, force=False):
    &#34;&#34;&#34;
    update_mass balance
    &#34;&#34;&#34;

    if not hasattr(self, &#34;already_called_update_smb&#34;):
        self.tlast_mb = -1.0e5000
        self.tcomp[&#34;Mass balance&#34;] = []
        if len(self.config.type_mass_balance) &gt; 0:
            if hasattr(self, &#34;init_smb_&#34; + self.config.type_mass_balance):
                getattr(self, &#34;init_smb_&#34; + self.config.type_mass_balance)()
        self.already_called_update_smb = True

    if (force) | ((self.t.numpy() - self.tlast_mb) &gt;= self.config.mb_update_freq):

        if self.config.verbosity == 1:
            print(&#34;Construct mass balance at time : &#34;, self.t.numpy())

        self.tcomp[&#34;Mass balance&#34;].append(time.time())

        if len(self.config.type_mass_balance) &gt; 0:
            getattr(self, &#34;update_smb_&#34; + self.config.type_mass_balance)()
        else:
            self.smb.assign(tf.zeros_like(self.topg))

        if hasattr(self, &#34;icemask&#34;):
            self.smb.assign(self.smb * self.icemask)

        if not self.config.mb_scaling == 1:
            self.smb.assign(self.smb * self.config.mb_scaling)

        self.tlast_mb = self.t.numpy()

        if self.config.stop:
            mb_np = self.smb.numpy()

        self.tcomp[&#34;Mass balance&#34;][-1] -= time.time()
        self.tcomp[&#34;Mass balance&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_smb_nn"><code class="name flex">
<span>def <span class="ident">update_smb_nn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function update the smb using the neural network emulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_smb_nn(self):
    &#34;&#34;&#34;
    function update the smb using the neural network emulator
    &#34;&#34;&#34;

    # this is not a nice implementation, but for now, it does the job
    self.mask = tf.ones_like(self.thk)
    for i in range(12):
        vars(self)[&#34;air_temp_&#34; + str(i)] = self.air_temp[i]
        vars(self)[&#34;precipitation_&#34; + str(i)] = self.precipitation[i]

    X = tf.expand_dims(
        tf.stack(
            [
                vars(self)[f] / self.smb_fieldbounds[f]
                for f in self.smb_mapping[&#34;fieldin&#34;]
            ],
            axis=-1,
        ),
        axis=0,
    )

    Y = self.smb_model.predict_on_batch(X)

    # this will return the smb, the only output of the smb nn emulator
    for kk, f in enumerate(self.smb_mapping[&#34;fieldout&#34;]):
        vars(self)[f].assign(Y[0, :, :, kk] * self.smb_fieldbounds[f])</code></pre>
</details>
</dd>
<dt id="igm.igm.update_smb_simple"><code class="name flex">
<span>def <span class="ident">update_smb_simple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>mass balance 'simple' parametrized by ELA, ablation and accumulation gradients, and max acuumulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_smb_simple(self):
    &#34;&#34;&#34;
    mass balance &#39;simple&#39; parametrized by ELA, ablation and accumulation gradients, and max acuumulation
    &#34;&#34;&#34;

    ela = np.float32(self.ela(self.t))
    gradabl = np.float32(self.gradabl(self.t))
    gradacc = np.float32(self.gradacc(self.t))
    maxacc = np.float32(self.maxacc(self.t))

    smb = self.usurf - ela
    smb *= tf.where(tf.less(smb, 0), gradabl, gradacc)
    smb = tf.clip_by_value(smb, -100, maxacc)
    smb = tf.where(self.icemask &gt; 0.5, smb, -10)

    self.smb.assign(smb)</code></pre>
</details>
</dd>
<dt id="igm.igm.update_t_dt"><code class="name flex">
<span>def <span class="ident">update_t_dt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>compute time step to satisfy the CLF condition and hit requested saving times</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_t_dt(self):
    &#34;&#34;&#34;
    compute time step to satisfy the CLF condition and hit requested saving times
    &#34;&#34;&#34;
    if self.config.verbosity == 1:
        print(&#34;Update DT from the CFL condition at time : &#34;, self.t.numpy())

    if not hasattr(self, &#34;already_called_update_t_dt&#34;):
        self.tcomp[&#34;Time step&#34;] = []
        self.already_called_update_t_dt = True

        self.tsave = np.ndarray.tolist(
            np.arange(self.config.tstart, self.config.tend, self.config.tsave)
        ) + [self.config.tend]
        self.itsave = 0

    self.tcomp[&#34;Time step&#34;].append(time.time())

    velomax = max(
        tf.math.reduce_max(tf.math.abs(self.ubar)),
        tf.math.reduce_max(tf.math.abs(self.vbar)),
    ).numpy()

    if velomax &gt; 0:
        self.dt_target = min(self.config.cfl * self.dx / velomax, self.config.dtmax)
    else:
        self.dt_target = self.config.dtmax

    self.dt = self.dt_target

    if self.tsave[self.itsave + 1] &lt;= self.t.numpy() + self.dt:
        self.dt = self.tsave[self.itsave + 1] - self.t.numpy()
        self.t.assign(self.tsave[self.itsave + 1])
        self.saveresult = True
        self.itsave += 1
    else:
        self.t.assign(self.t.numpy() + self.dt)
        self.saveresult = False

    self.it += 1

    self.tcomp[&#34;Time step&#34;][-1] -= time.time()
    self.tcomp[&#34;Time step&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_thk"><code class="name flex">
<span>def <span class="ident">update_thk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>update ice thickness solving dh/dt + d(u h)/dx + d(v h)/dy = f using
upwind finite volume, update usurf and slopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_thk(self):
    &#34;&#34;&#34;
    update ice thickness solving dh/dt + d(u h)/dx + d(v h)/dy = f using
    upwind finite volume, update usurf and slopes
    &#34;&#34;&#34;

    if not hasattr(self, &#34;already_called_update_icethickness&#34;):
        self.tcomp[&#34;Transport&#34;] = []
        self.already_called_update_icethickness = True

    if self.config.verbosity == 1:
        print(&#34;Ice thickness equation at time : &#34;, self.t.numpy())

    self.tcomp[&#34;Transport&#34;].append(time.time())

    # compute the divergence of the flux
    self.divflux = self.compute_divflux(
        self.ubar, self.vbar, self.thk, self.dx, self.dx
    )

    # Forward Euler with projection to keep ice thickness non-negative
    self.thk.assign(tf.maximum(self.thk + self.dt * (self.smb - self.divflux), 0))

    self.usurf.assign(self.topg + self.thk)

    self.slopsurfx, self.slopsurfy = self.compute_gradient_tf(
        self.usurf, self.dx, self.dx
    )

    self.tcomp[&#34;Transport&#34;][-1] -= time.time()
    self.tcomp[&#34;Transport&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_topg"><code class="name flex">
<span>def <span class="ident">update_topg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>update bedrock due to glacial errosion,
eroson rate are proportional to a power
of the sliding velocity magnitude</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_topg(self):
    &#34;&#34;&#34;
    update bedrock due to glacial errosion,
    eroson rate are proportional to a power
    of the sliding velocity magnitude
    &#34;&#34;&#34;

    if self.config.erosion_include:

        if not hasattr(self, &#34;already_called_update_topg&#34;):
            self.tlast_erosion = self.config.tstart
            self.tcomp[&#34;Erosion&#34;] = []
            self.already_called_update_topg = True

        if (self.t.numpy() - self.tlast_erosion) &gt;= self.config.erosion_update_freq:

            if self.config.verbosity == 1:
                print(&#34;Erode bedrock at time : &#34;, self.t.numpy())

            self.tcomp[&#34;Erosion&#34;].append(time.time())

            self.velbase_mag = self.getmag(self.uvelbase, self.vvelbase)

            self.dtopgdt.assign(self.config.erosion_cst * (self.velbase_mag ** self.config.erosion_exp))

            self.topg.assign(self.topg - (self.t.numpy() - self.tlast_erosion) * self.dtopgdt)

            print(&#39;max erosion is :&#39;, np.max( np.abs ( self.dtopgdt ) ) )

            self.usurf.assign(self.topg + self.thk)

            self.tlast_erosion = self.t.numpy()

            self.tcomp[&#34;Erosion&#34;][-1] -= time.time()
            self.tcomp[&#34;Erosion&#34;][-1] *= -1</code></pre>
</details>
</dd>
<dt id="igm.igm.update_vert_disc_tf"><code class="name flex">
<span>def <span class="ident">update_vert_disc_tf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.function()
def update_vert_disc_tf(self):

    # nz is the index of the first node above the ice surface
    nz = tf.ones(self.thk.shape, &#34;int32&#34;) * (self.height.shape[0] - 1)
    for k in range(self.height.shape[0] - 1, -1, -1):
        nz = tf.where(self.height[k] &gt; self.thk, k, nz)
    self.nz.assign(tf.where(self.thk &gt;= self.ddz[0], nz, 1))

    # depth is the depth of ice at any grid point, otherwise it is zero
    depth = []
    for k in range(0, self.height.shape[0]):
        depth.append(
            tf.where(
                (self.thk &gt;= self.ddz[0]) &amp; (k &lt; self.nz),
                self.thk - self.height[k],
                0.0,
            )
        )
    self.depth.assign(tf.stack(depth, axis=0))

    # dz is the  vertical spacing,
    dz = []
    for k in range(0, self.height.shape[0] - 1):
        dz.append(tf.ones_like(self.thk) * self.ddz[k])
    self.dz.assign(tf.stack(dz, axis=0))</code></pre>
</details>
</dd>
<dt id="igm.igm.whatsize"><code class="name flex">
<span>def <span class="ident">whatsize</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def whatsize(self, n):
    s = float(n.size * n.itemsize) / (10 ** 6)
    print(&#34;%1.0f Mbytes&#34; % s)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#initialization-contains-all-to-initialize-variables">INITIALIZATION : contains all to initialize variables</a></li>
<li><a href="#io-ncdf-files-for-data-inputoutput-using-netcdf-file-format">I/O NCDF : Files for data Input/Output using NetCDF file format</a></li>
<li><a href="#compute-t-and-dt-function-to-compute-adaptive-time-step-and-time">COMPUTE T AND DT : Function to compute adaptive time-step and time</a></li>
<li><a href="#iceflow-containt-the-function-that-serve-compute-the-emulated-iceflow">ICEFLOW : Containt the function that serve compute the emulated iceflow</a></li>
<li><a href="#climate-templates-for-function-updating-climate">CLIMATE : Templates for function updating climate</a></li>
<li><a href="#mass-balance-simple-mass-balance">MASS BALANCE : Simple mass balance</a></li>
<li><a href="#erosion-erosion-law">EROSION : Erosion law</a></li>
<li><a href="#transport-this-handles-the-mass-conservation">TRANSPORT : This handles the mass conservation</a></li>
<li><a href="#3dvel-this-permits-to-export-reconsctruted-3d-ice-velocity-field">3DVEL
: This permits to export reconsctruted 3D ice velocity field</a></li>
<li><a href="#opti-all-for-the-optimization-data-assimilation">OPTI : All for the optimization / data assimilation</a></li>
<li><a href="#plot-plotting-functions">PLOT : Plotting functions</a></li>
<li><a href="#print-info-handle-the-printing-of-output-during-computation">PRINT INFO : handle the printing of output during computation</a></li>
<li><a href="#run-the-main-function-that-wrap-all-functions-within-an-time-iterative-loop">RUN : the main function that wrap all functions within an time-iterative loop</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="igm.str2bool" href="#igm.str2bool">str2bool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="igm.igm" href="#igm.igm">igm</a></code></h4>
<ul class="">
<li><code><a title="igm.igm.animate_result" href="#igm.igm.animate_result">animate_result</a></code></li>
<li><code><a title="igm.igm.compute_divflux" href="#igm.igm.compute_divflux">compute_divflux</a></code></li>
<li><code><a title="igm.igm.compute_flow_direction_for_anisotropic_smoothing" href="#igm.igm.compute_flow_direction_for_anisotropic_smoothing">compute_flow_direction_for_anisotropic_smoothing</a></code></li>
<li><code><a title="igm.igm.compute_gradient_tf" href="#igm.igm.compute_gradient_tf">compute_gradient_tf</a></code></li>
<li><code><a title="igm.igm.compute_rms_std_optimization" href="#igm.igm.compute_rms_std_optimization">compute_rms_std_optimization</a></code></li>
<li><code><a title="igm.igm.getmag" href="#igm.igm.getmag">getmag</a></code></li>
<li><code><a title="igm.igm.init_3dvel" href="#igm.igm.init_3dvel">init_3dvel</a></code></li>
<li><code><a title="igm.igm.init_smb_nn" href="#igm.igm.init_smb_nn">init_smb_nn</a></code></li>
<li><code><a title="igm.igm.init_smb_simple" href="#igm.igm.init_smb_simple">init_smb_simple</a></code></li>
<li><code><a title="igm.igm.initialize" href="#igm.igm.initialize">initialize</a></code></li>
<li><code><a title="igm.igm.initialize_fields" href="#igm.igm.initialize_fields">initialize_fields</a></code></li>
<li><code><a title="igm.igm.initialize_iceflow" href="#igm.igm.initialize_iceflow">initialize_iceflow</a></code></li>
<li><code><a title="igm.igm.load_ncdf_data" href="#igm.igm.load_ncdf_data">load_ncdf_data</a></code></li>
<li><code><a title="igm.igm.load_thk_profiles" href="#igm.igm.load_thk_profiles">load_thk_profiles</a></code></li>
<li><code><a title="igm.igm.make_data_holes" href="#igm.igm.make_data_holes">make_data_holes</a></code></li>
<li><code><a title="igm.igm.optimize" href="#igm.igm.optimize">optimize</a></code></li>
<li><code><a title="igm.igm.output_ncdf_optimize_final" href="#igm.igm.output_ncdf_optimize_final">output_ncdf_optimize_final</a></code></li>
<li><code><a title="igm.igm.plot_computational_pie" href="#igm.igm.plot_computational_pie">plot_computational_pie</a></code></li>
<li><code><a title="igm.igm.plot_cost_functions" href="#igm.igm.plot_cost_functions">plot_cost_functions</a></code></li>
<li><code><a title="igm.igm.plot_opti_diff" href="#igm.igm.plot_opti_diff">plot_opti_diff</a></code></li>
<li><code><a title="igm.igm.print_all_comp_info" href="#igm.igm.print_all_comp_info">print_all_comp_info</a></code></li>
<li><code><a title="igm.igm.print_comp_info_live" href="#igm.igm.print_comp_info_live">print_comp_info_live</a></code></li>
<li><code><a title="igm.igm.print_info" href="#igm.igm.print_info">print_info</a></code></li>
<li><code><a title="igm.igm.read_config_param" href="#igm.igm.read_config_param">read_config_param</a></code></li>
<li><code><a title="igm.igm.read_config_param_3dvel" href="#igm.igm.read_config_param_3dvel">read_config_param_3dvel</a></code></li>
<li><code><a title="igm.igm.read_config_param_climate" href="#igm.igm.read_config_param_climate">read_config_param_climate</a></code></li>
<li><code><a title="igm.igm.read_config_param_erosion" href="#igm.igm.read_config_param_erosion">read_config_param_erosion</a></code></li>
<li><code><a title="igm.igm.read_config_param_iceflow" href="#igm.igm.read_config_param_iceflow">read_config_param_iceflow</a></code></li>
<li><code><a title="igm.igm.read_config_param_optimize" href="#igm.igm.read_config_param_optimize">read_config_param_optimize</a></code></li>
<li><code><a title="igm.igm.read_config_param_output_ncdf" href="#igm.igm.read_config_param_output_ncdf">read_config_param_output_ncdf</a></code></li>
<li><code><a title="igm.igm.read_config_param_plot" href="#igm.igm.read_config_param_plot">read_config_param_plot</a></code></li>
<li><code><a title="igm.igm.read_config_param_smb" href="#igm.igm.read_config_param_smb">read_config_param_smb</a></code></li>
<li><code><a title="igm.igm.read_config_param_t_dt" href="#igm.igm.read_config_param_t_dt">read_config_param_t_dt</a></code></li>
<li><code><a title="igm.igm.read_fields_and_bounds" href="#igm.igm.read_fields_and_bounds">read_fields_and_bounds</a></code></li>
<li><code><a title="igm.igm.restart" href="#igm.igm.restart">restart</a></code></li>
<li><code><a title="igm.igm.run" href="#igm.igm.run">run</a></code></li>
<li><code><a title="igm.igm.run_opti" href="#igm.igm.run_opti">run_opti</a></code></li>
<li><code><a title="igm.igm.stop" href="#igm.igm.stop">stop</a></code></li>
<li><code><a title="igm.igm.update_3dvel" href="#igm.igm.update_3dvel">update_3dvel</a></code></li>
<li><code><a title="igm.igm.update_climate" href="#igm.igm.update_climate">update_climate</a></code></li>
<li><code><a title="igm.igm.update_iceflow" href="#igm.igm.update_iceflow">update_iceflow</a></code></li>
<li><code><a title="igm.igm.update_ncdf_3d_ex" href="#igm.igm.update_ncdf_3d_ex">update_ncdf_3d_ex</a></code></li>
<li><code><a title="igm.igm.update_ncdf_ex" href="#igm.igm.update_ncdf_ex">update_ncdf_ex</a></code></li>
<li><code><a title="igm.igm.update_ncdf_optimize" href="#igm.igm.update_ncdf_optimize">update_ncdf_optimize</a></code></li>
<li><code><a title="igm.igm.update_ncdf_ts" href="#igm.igm.update_ncdf_ts">update_ncdf_ts</a></code></li>
<li><code><a title="igm.igm.update_plot" href="#igm.igm.update_plot">update_plot</a></code></li>
<li><code><a title="igm.igm.update_plot_inversion" href="#igm.igm.update_plot_inversion">update_plot_inversion</a></code></li>
<li><code><a title="igm.igm.update_plot_profiles" href="#igm.igm.update_plot_profiles">update_plot_profiles</a></code></li>
<li><code><a title="igm.igm.update_reconstruct_3dvel_tf" href="#igm.igm.update_reconstruct_3dvel_tf">update_reconstruct_3dvel_tf</a></code></li>
<li><code><a title="igm.igm.update_smb" href="#igm.igm.update_smb">update_smb</a></code></li>
<li><code><a title="igm.igm.update_smb_nn" href="#igm.igm.update_smb_nn">update_smb_nn</a></code></li>
<li><code><a title="igm.igm.update_smb_simple" href="#igm.igm.update_smb_simple">update_smb_simple</a></code></li>
<li><code><a title="igm.igm.update_t_dt" href="#igm.igm.update_t_dt">update_t_dt</a></code></li>
<li><code><a title="igm.igm.update_thk" href="#igm.igm.update_thk">update_thk</a></code></li>
<li><code><a title="igm.igm.update_topg" href="#igm.igm.update_topg">update_topg</a></code></li>
<li><code><a title="igm.igm.update_vert_disc_tf" href="#igm.igm.update_vert_disc_tf">update_vert_disc_tf</a></code></li>
<li><code><a title="igm.igm.whatsize" href="#igm.igm.whatsize">whatsize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>